[
  {
    "title": "Web3 Functions - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/guides/custom-logic-triggers/web3-functions",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nTutorials\nWhat tasks can be automated?\nDefining function inputs\nCustom logic triggers\nSmart Contract Resolvers\nWeb3 Functions\nDedicated msg.sender\nSingle Execution Task\nMulti contract execution\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nWeb3 Functions\nIn order to automate smart contracts based on off-chain data & computation, check out our Web3 Functions section. \nPrevious\nSmart Contract Resolvers\nNext\nDedicated msg.sender\nLast modified 2mo ago"
  },
  {
    "title": "Smart Contract Resolvers - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/guides/custom-logic-triggers/smart-contract-resolvers",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nTutorials\nWhat tasks can be automated?\nDefining function inputs\nCustom logic triggers\nSmart Contract Resolvers\nWeb3 Functions\nDedicated msg.sender\nSingle Execution Task\nMulti contract execution\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nSmart Contract Resolvers\nHere is how a simple smart contract resolver looks like. This resolver is responsible for checking the lastExecuted state of a simple counter in another smart contract. And if 3 minutes have passed since the last execution, this resolver will prompt Gelato to execute.\nCheck out the code for Counter and CounterResolver .\nCounterResolver.sol \ncontract CounterResolver {\n    ICounter public immutable counter;\n​\n    constructor(ICounter _counter) {\n        counter = _counter;\n    }\n​\n    function checker()\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        uint256 lastExecuted = counter.lastExecuted();\n​\n        canExec = (block.timestamp - lastExecuted) > 180;\n        \n        execPayload = abi.encodeCall(ICounter.increaseCount, (1));\n    }\n}\nA resolver should always return 2 things:\n1.\nbool canExec : whether Gelato should execute the task.\n2.\nbytes execData :  data that executors should use for the execution.\nResolvers can also accept arguments. This is useful as you can potentially \"re-use\" your resolver when creating multiple tasks. \nUsing the same example as above:\n    function checker(address _counter)\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        uint256 lastExecuted = ICounter(_counter).lastExecuted();\n​\n        canExec = (block.timestamp - lastExecuted) > 180;\n​\n        execPayload = abi.encodeCall(ICounter.increaseCount, (1));\n    }\nInstead of a hardcoded COUNTER address, you can pass counterAddress as an argument. \nCommon patterns and best practices\nChecking multiple functions in one Resolver\nLet's say you want to automate your yield compounding for multiple pools. To avoid creating multiple tasks and having different resolvers, you could keep a list of the pools and iterate through each of the pools to see if they should be compounded. Take a look at this example.\nfunction checker()\n\texternal\n\tview\n\treturns (bool canExec, bytes memory execPayload)\n{\n\tuint256 delay = harvester.delay();\n\t\n\tfor (uint256 i = 0; i < vaults.length(); i++) {\n\t\tIVault vault = IVault(getVault(i));\n​\n\t\tcanExec = block.timestamp >= vault.lastDistribution().add(delay);\n​\n\t\texecPayload = abi.encodeWithSelector(\n\t\t\tIHarvester.harvestVault.selector,\n\t\t\taddress(vault)\n\t\t);\n​\n\t\tif (canExec) return(true, execPayload);\n\t\t\n\t}\t\n\t\n\treturn(false, bytes(\"No vaults to harvest\");\n​\n}\nThis resolver will return true when a certain time has elapsed since the last distribution of a pool, together with the payload to compound that specific pool. \nLogs using custom return messages\nThe Gelato Automate UI has a feature which provides logs which show what the Gelato Executors are seeing in real time. \nUsing custom return messages, you can always check where in your smart contract Resolver the logic is currently \"stuck\", i.e. why isn't the Resolver returning true.\n    function checker()\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        uint256 lastExecuted = counter.lastExecuted();\n​\n        if(block.timestamp - lastExecuted < 180) return(false, bytes(\"Time not elapsed\");\n​\n        execPayload = abi.encodeCall(ICounter.increaseCount, (1));\n        return(true, execPayload);\n    }\nLimit the Gas Price of your execution\nOn networks such as Ethereum, gas will get expensive at certain times. If what you are automating is not time-sensitive and don't mind having your transaction mined at a later point, you can limit the gas price used in your execution in your resolver.\nfunction checker()\n\texternal\n\tview\n\treturns (bool canExec, bytes memory execPayload)\n{\n\t// condition here\n\t\n\tif(tx.gasprice > 80 gwei) return (false, bytes(\"Gas price too high\"));\n}\n​\nThis way, Gelato will not execute your transaction if the gas price is higher than 80 GWEI. \nPrevious\nCustom logic triggers\nNext\nWeb3 Functions\nLast modified 2mo ago\nON THIS PAGE\nCommon patterns and best practices\nChecking multiple functions in one Resolver\nLogs using custom return messages\nLimit the Gas Price of your execution"
  },
  {
    "title": "Petting Aavegotchis - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/template-real-world-examples/petting-aavegotchis",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nYield vault harvesting\nRewards Payout\nPetting Aavegotchis\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nPetting Aavegotchis\nGotchiCare\n​GotchiCare uses Gelato Autoamte to provide an automated Aavegotchi petting service.\nGelato calls exec here which pets the Aavegotchis and settles the fee. \n  function exec(CareInfo calldata _careInfo) external {\n    require(msg.sender == executor, \"Carer: Only executor\");\n​\n    bytes32 _receipt = getReceipt(_careInfo.owner, _careInfo);\n​\n    require(\n      caringOwners.contains(_careInfo.owner),\n      \"Carer: exec: Owner has not started\"\n    );\n    require(\n      _careInfo.owner == ownerOfReceipt[_receipt],\n      \"Carer: exec: Receipt does not match\"\n    );\n​\n    operator.pet(_careInfo.gotchis, _careInfo.owner);\n​\n    payWages(_careInfo.owner, _careInfo.rate);\n​\n \n    CareInfo memory newCareInfo = CareInfo(\n      _careInfo.owner,\n      _careInfo.pets.add(1),\n      _careInfo.rate,\n      _careInfo.gotchis\n    );\n​\n      updateOwnerInfo(newCareInfo);\n​\n  }\nThis resolver loops through an array of subscribed users. For each user, it checks if their aavegotchi's petting time has reached. \n  function checker()\n    external\n    view\n    returns (bool canExec, bytes memory execPayload)\n  {\n    address[] memory _caringOwners = careCentre.getCaringOwners();\n    uint256 _length = _caringOwners.length;\n​\n    for (uint256 i = 0; i < _length; i++) {\n      ICareCentre.CareInfo memory _careInfo = careCentre.getCareInfoByOwner(\n        _caringOwners[i]\n      );\n​\n      if (!ownerHasBalance(_caringOwners[i], _careInfo.rate)) continue;\n      if (!isApproved(_caringOwners[i])) continue;\n​\n      uint256[] memory _gotchis = _careInfo.gotchis;\n​\n      uint256 _lastInteracted = gotchiFacet\n        .getAavegotchi(_gotchis[0])\n        .lastInteracted;\n​\n      uint256 _nextInteract = _lastInteracted + 12 hours;\n​\n      if (block.timestamp >= _nextInteract) {\n        canExec = true;\n​\n        execPayload = abi.encodeWithSelector(\n          ICareCentre.exec.selector,\n          _careInfo\n        );\n​\n        return (canExec, execPayload);\n      }\n    }\n​\n    canExec = false;\n  }\n​\nPrevious\nRewards Payout\nNext\nCode Repositories\nLast modified 1yr ago"
  },
  {
    "title": "Rewards Payout - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/template-real-world-examples/rewards-payout",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nYield vault harvesting\nRewards Payout\nPetting Aavegotchis\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nRewards Payout\nUnicly\n​Unicly uses Gelato Automate for daily rewards generation for stakers.\nGelato calls this addRewards in their staking contract recurrently once everyday. \nfunction addRewards(address rewardToken, uint256 amount) override external poolExists(rewardToken) {\n        require(amount > 0, \"UnicStaking: Amount must be greater than zero\");\n        IERC20Upgradeable(rewardToken).safeTransferFrom(msg.sender, address(this), amount);\n        RewardPool storage pool = pools[rewardToken];\n        pool.totalRewardAmount = pool.totalRewardAmount.add(amount);\n        emit AddRewards(rewardToken, amount);\n}\nSince the condition to call this function is time-dependent, writing a resolver is not required.  \nYou can create a task through the Gelato Automate UI directly.\nOn the task creation page, select the Time option for \"When\" and input your desired interval between executions. \nPrevious\nYield vault harvesting\nNext\nPetting Aavegotchis\nLast modified 1yr ago"
  },
  {
    "title": "Yield vault harvesting - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/template-real-world-examples/yield-vault-harvesting",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nYield vault harvesting\nRewards Payout\nPetting Aavegotchis\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nYield vault harvesting\nETHA Lend\n​ETHA is using Gelato Automate for automated yield harvesting. \nThis is the function which Gelato will be calling. harvestVault claims yield generated from a pool and re-deposits them back into the pool.\nfunction harvestVault(IVault vault) public onlyAfterDelay(vault) {\n\t// Amount to Harvest\n\tuint256 afterFee = vault.harvest();\n\trequire(afterFee > 0, \"!Yield\");\n​\n\tIERC20 from = vault.rewards();\n\tIERC20 to = vault.target();\n​\n\taddress connector = getBestConnector(\n\t\taddress(from),\n\t\taddress(to),\n\t\tafterFee\n\t);\n​\n\t// Quickswap path\n\taddress[] memory path;\n​\n\tif (connector == address(0)) {\n\t\tpath = new address[](2);\n\t\tpath[0] = address(from);\n\t\tpath[1] = address(to);\n\t} else {\n\t\tpath = new address[](3);\n\t\tpath[0] = address(from);\n\t\tpath[1] = connector;\n\t\tpath[2] = address(to);\n\t}\n​\n\t// Swap underlying to target\n\tfrom.approve(address(ROUTER), afterFee);\n\tuint256 received = ROUTER.swapExactTokensForTokens(\n\t\tafterFee,\n\t\t1,\n\t\tpath,\n\t\taddress(this),\n\t\tblock.timestamp + 1\n\t)[path.length - 1];\n​\n\t// Send profits to vault\n\tto.approve(address(vault), received);\n\tvault.distribute(received);\n​\n\temit Harvested(address(vault), msg.sender);\n}\nETHA uses this resolver below to check for ready to be harvested pools. \nfunction checker()\n\texternal\n\tview\n\treturns (bool canExec, bytes memory execPayload)\n{\n\tuint256 delay = harvester.delay();\n​\n\tfor (uint256 i = 0; i < vaults.length(); i++) {\n\t\tIVault vault = IVault(getVault(i));\n​\n\t\tcanExec = block.timestamp >= vault.lastDistribution().add(delay);\n​\n\t\texecPayload = abi.encodeWithSelector(\n\t\t\tIHarvester.harvestVault.selector,\n\t\t\taddress(vault)\n\t\t);\n​\n\t\tif (canExec) break;\n\t}\n}\n​\nThe resolver loops through an array of pools. And for each vault, if a defined delay has elapsed since the previous harvest time, canExec will return true , prompting Gelato to execute the task. execPayload will be the data to the function call harvestVault(address vault) and its argument is the address of the vault to be harvested.\nPrevious\nTemplate real-world examples\nNext\nRewards Payout\nLast modified 1yr ago"
  },
  {
    "title": "Multi contract execution - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/guides/multi-contract-execution",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nTutorials\nWhat tasks can be automated?\nDefining function inputs\nCustom logic triggers\nDedicated msg.sender\nSingle Execution Task\nMulti contract execution\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nMulti contract execution\nWith dedicated msg.sender enabled, you can make use of its multi-call function batchExecuteCall to execute multiple functions on different contracts. \n    function batchExecuteCall(\n        address[] calldata _targets,\n        bytes[] calldata _datas,\n        uint256[] calldata _values\n    ) external payable override onlyAuth {\n        uint256 length = _targets.length;\n        require(\n            length == _datas.length && length == _values.length,\n            \"OpsProxy: Length mismatch\"\n        );\n​\n        for (uint256 i; i < length; i++)\n            _executeCall(_targets[i], _datas[i], _values[i]);\n    }\nTo do so, you will need to create a task with your dedicated msg.sender as the target contract address.\nGet your dedicated msg.sender\nCopy the address of your dedicated msg.sender which can be found in the user drop-down.\nCreate a task calling your dedicated msg.sender\nPaste the ABI below into the ABI field and select batchExecuteCall as the function to be automated. \n[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_datas\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"batchExecuteCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]\nYou can either predefine the arguments or have a resolver return the data.\nIf you are using a resolver, you must return an ABI encoded payload of the batchExecuteCall function.\nHere is an example resolver that returns a payload that calls increaseCount on 2 different contracts.\ninterface IOpsProxy {\n    function batchExecuteCall(\n        address[] calldata targets,\n        bytes[] calldata datas,\n        uint256[] calldata values\n    ) external payable;\n}\n​\ninterface ICounter {\n    function increaseCount(uint256 _amount) external;\n}\n​\ncontract BatchExecCallResolver {\n​\n    address public immutable counter1;\n    address public immutable counter2;\n    \n    constructor(address _counter1, address _counter2){\n        counter1 = _counter1;\n        counter2 = _counter2;\n    }\n    \n    function checker()\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        address[] memory targets = new address[](2);\n        targets[0] = counter1;\n        targets[1] = counter2;\n​\n        bytes[] memory datas = new bytes[](2);\n        datas[0] = abi.encodeWithSelector(ICounter.increaseCount.selector, [1]);\n        datas[1] = abi.encodeWithSelector(ICounter.increaseCount.selector, [2]);\n​\n        uint256[] memory values = new address[](2);\n        values[0] = 0;\n        values[1] = 0;\n​\n        execPayload = abi.encodeWithSelector(\n            IOpsProxy.batchExecuteCall.selector,\n            [targets, datas, values]\n        );\n        \n        return (true, execPayload);\n    }    \n}\n​\n​\nPrevious\nSingle Execution Task\nNext\nMonitoring Automate Tasks\nLast modified 1mo ago\nON THIS PAGE\nGet your dedicated msg.sender\nCreate a task calling your dedicated msg.sender"
  },
  {
    "title": "Single Execution Task - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/guides/single-execution-task",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nTutorials\nWhat tasks can be automated?\nDefining function inputs\nCustom logic triggers\nDedicated msg.sender\nSingle Execution Task\nMulti contract execution\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nSingle Execution Task\nSometimes, you might want to have Gelato call your function only once. If so, you can make use of the SingleExec module which automatically cancels the task for you after one execution.\nThe task will still be canceled if the execution reverts on-chain\nHere is how you can enable SingleExec when creating your task across the various task creation methods.\nGelato Automate UI\nOpen up the Advanced Settings panel when creating a new task and select Single execution task:\nAccessing the single execution task option in Advanced Settings\nGelato Automate SDK\nSet singleExec flag to true  when calling createTask.  \nconst { taskId, tx }: TaskTransaction = await automate.createTask({\n  execAddress: counter.address,\n  execSelector: selector,\n  resolverAddress: counter.address,\n  resolverData: resolverData,\n  dedicatedMsgSender: true,\n  name: \"Automated counter using resolver\",\n  dedicatedMsgSender: true,\n  singleExec: true\n});\nSmart Contract\nInclude SingleExec module in ModuleData.modules . Check out the full code here.\nModuleData memory moduleData = ModuleData({\n    modules: new Module[](2),\n    args: new bytes[](2)\n});\n​\nmoduleData.modules[0] = Module.PROXY;\nmoduleData.modules[1] = Module.SINGLE_EXEC;\n​\nmoduleData.args[0] = _proxyModuleArg();\nmoduleData.args[1] = _singleExecModuleArg();\n​\nbytes32 id = _createTask(\n    address(this),\n    execData,\n    moduleData,\n    address(0)\n);\nPrevious\nDedicated msg.sender\nNext\nMulti contract execution\nLast modified 1mo ago\nON THIS PAGE\nGelato Automate UI\nGelato Automate SDK\nSmart Contract"
  },
  {
    "title": "Dedicated msg.sender - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/guides/dedicated-msg.sender",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nTutorials\nWhat tasks can be automated?\nDefining function inputs\nCustom logic triggers\nDedicated msg.sender\nSingle Execution Task\nMulti contract execution\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nDedicated msg.sender\nAdding security by restricting who can execute a particular function\nDuring task creation, you will see an address which will be the msg.sender during your task executions.\nIf you are the owner of the target contract, we recommend that you have a msg.sender restriction on your smart contract with your dedicated msg.sender whitelisted. This adds additional security as only you, the contract owner can create a task to call your function.\nmsg.sender restrictions should be added to the function that Gelato will call during execution, not the checker function.\nYou can have this restriction by inheriting AutomateReady​\nAutomateReady exposes a modifier onlyDedicatedMsgSender which restricts msg.sender to only task executions created by taskCreator defined in the constructor.\n    modifier onlyDedicatedMsgSender() {\n        require(msg.sender == dedicatedMsgSender, \"Only dedicated msg.sender\");\n        _;\n    }\nIf you would like to have additional callers for your function. You can implement a whitelist like so.\n    mapping(address => bool) public whitelisted;\n​\n    modifier onlyWhitelisted() {\n        require(\n            whitelisted[msg.sender] || msg.sender == dedicatedMsgSender,\n            \"Only whitelisted\"\n        );\n        _;\n    }\n​\nPrevious\nWeb3 Functions\nNext\nSingle Execution Task\nLast modified 1mo ago"
  },
  {
    "title": "Defining function inputs - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/guides/defining-function-inputs",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nTutorials\nWhat tasks can be automated?\nDefining function inputs\nCustom logic triggers\nDedicated msg.sender\nSingle Execution Task\nMulti contract execution\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nDefining function inputs\nIf the function you are automating accepts arguments you have two alternative ways that you can define the arguments. \nPre-define inputs (No resolver)\nPre-defining the function arguments would mean that every time Gelato calls the function, it would be using the same argument. \nDynamic inputs via Resolver\nBy using a resolver, you can dynamically encode the arguments of the function you are automating. \nHere is an example:\nThis is the function we are automating. increaseCount increases a counter on the smart contract by amount which is the argument.\n    function increaseCount(uint256 amount) external {\n        require(\n            ((block.timestamp - lastExecuted) > 300),\n            \"Counter: increaseCount: Time not elapsed\"\n        );\n​\n        count += amount;\n        lastExecuted = block.timestamp;\n    }\nThis resolver returns the data to the function call increaseCount.\n    function checker()\n        external\n        view\n        override\n        returns (bool canExec, bytes memory execData)\n    {\n        uint256 lastExecuted = ICounter(COUNTER).lastExecuted();\n​\n        canExec = (block.timestamp - lastExecuted) > 300;\n        \n        uint256 countToIncrease = ICounter(COUNTER).count * 2\n​\n        execPayload = abi.encodeCall(\n            ICounter.increaseCount,\n            (countToIncrease)\n        );\n    }\n​\nThe increment on each execution is different every time as countToIncrease is different after every execution. \nPrevious\nWhat tasks can be automated?\nNext\nCustom logic triggers\nLast modified 1mo ago\nON THIS PAGE\nPre-define inputs (No resolver)\nDynamic inputs via Resolver"
  },
  {
    "title": "Gelato Automate SDK - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/methods-for-submitting-your-task/gelato-automate-sdk",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGelato Automate UI\nGelato Automate SDK\nSmart Contract\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nGelato Automate SDK\nCreate automated task executions using our typescript SDK:\nNPM Package\nnpm: @gelatonetwork/automate-sdk\nnpm\nHow to use\nInstall automate-sdk:\nyarn add @gelatonetwork/automate-sdk\nImport AutomateSDK:\nimport { AutomateSDK } from \"@gelatonetwork/automate-sdk\";\nInstantiate the SDK with your signer:\nconst automate = new AutomateSDK(chainId, signer);\nUse createTask to automate your function calls:\ninterface CreateTaskOptions {\n  name: string;             // your task name\n​\n  // Function to execute\n  execAddress: string;      // address of your target smart contract\n  execSelector: string;     // function selector to execute on your target smart contract\n  execAbi?: string;         // ABI of your target smart contract\n​\n  // Proxy caller\n  dedicatedMsgSender: boolean;  // task will be called via a dedicated msg.sender which you can whitelist (recommended: true)\n​\n  // Optional: Pre-defined / static target smart contract inputs\n  execData?: string;        // exec call data \n  \n  // Optional: Dynamic target smart contract inputs (using a resolver)\n  resolverAddress?: string; // resolver contract address\n  resolverData?: string;    // resolver call data (encoded data with function selector)\n  resolverAbi?: string;     // your resolver contract ABI\n​\n  // Optional: Time based task params\n  interval?: number;        // execution interval in seconds\n  startTime?: number;       // start timestamp in seconds or 0 to start immediately (default: 0)\n  \n  // Optional: Single execution task\n  singleExec?: boolean;     // task cancels itself after 1 execution if true.\n  \n  // Optional: Payment params\n  useTreasury?: boolean;    // use false if your task is self-paying (default: true)\n}\n​\nconst params: CreateTaskOptions = { name, execAddress, execSelector, interval };\nconst { taskId, tx }: TaskTransaction = await automate.createTask(params);\nExamples\nDeploy a contract & automate your function call:\n// Deploying Counter contract\nconst counterFactory = await hre.ethers.getContractFactory(\"Counter\");\nconst counter = await counterFactory.deploy(GELATO_ADDRESSES[chainId].automate);\nawait counter.deployed();\n​\n// Call Counter.increaseCount(42) every 10 minutes\nconst  { taskId, tx }: TaskTransaction = await automate.createTask({\n  execAddress: counter.address,\n  execSelector: counter.interface.getSighash(\"increaseCount(uint256)\"),\n  execData: counter.interface.encodeFunctionData(\"increaseCount\", [42]),\n  execAbi: counter.interface.format(\"json\") as string,\n  interval: 10 * 60, // execute every 10 minutes\n  name: \"Automated counter every 10min\",\n  dedicatedMsgSender: true\n});​\nUse a resolver contract to automate your function call:\nIf you need more configurable execution condition and/or dynamic input data, you can create a task using a resolver function (learn how to write a resolver).\n// Prepare Task data to automate\nconst counter = new Contract(COUNTER_ADDRESSES, counterAbi, signer);\nconst resolver = new Contract(COUNTER_RESOLVER_ADDRESSES, counterResolverAbi, signer);\nconst selector = counter.interface.getSighash(\"increaseCount(uint256)\");\nconst resolverData = resolver.interface.getSighash(\"checker()\");\n​\n// Create task\nconst { taskId, tx }: TaskTransaction = await automate.createTask({\n  execAddress: counter.address,\n  execSelector: selector,\n  resolverAddress: resolver.address,\n  resolverData: resolverData,\n  name: \"Automated counter using resolver\",\n  dedicatedMsgSender: true\n});\nEnable dedicated msg.sender:\nTo have a custom msg.sender that you can whitelist on your contract, you can enable the dedicatedMsgSender flag.\n// Prepare Task data to automate\nconst counter = new Contract(COUNTER_ADDRESSES, counterAbi, signer);\nconst resolver = new Contract(COUNTER_RESOLVER_ADDRESSES, counterResolverAbi, signer);\nconst selector = counter.interface.getSighash(\"increaseCount(uint256)\");\nconst resolverData = resolver.interface.getSighash(\"checker()\");\n​\n// Create task\nconst { taskId, tx }: TaskTransaction = await automate.createTask({\n  execAddress: counter.address,\n  execSelector: selector,\n  resolverAddress: resolver.address,\n  resolverData: resolverData,\n  dedicatedMsgSender: true,\n  name: \"Automated counter using resolver\",\n});\n​\n// Get dedicated proxy address to whitelist\nconst { address, isDeployed } = await automate.getDedicatedMsgSender()\nMore examples in our Hello World repository:\nGitHub - gelatodigital/automate-sdk-hello-world: Create Hello World tasks using Gelato Ops SDK\nGitHub\nPrevious\nGelato Automate UI\nNext\nSmart Contract\nLast modified 1mo ago\nON THIS PAGE\nNPM Package\nHow to use\nExamples"
  },
  {
    "title": "Gelato Automate UI - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/methods-for-submitting-your-task/gelato-automate-ui",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGelato Automate UI\nGelato Automate SDK\nSmart Contract\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nGelato Automate UI\nEasy-to-use interface for you to create and manage your tasks\nTo submit a task, head to the Gelato Automate UI.\nClick on New Task.\nChoose a name for your task. (e.g. \"Harvest vault every 10 minutes\")\nExecution contract details\nFill in the contract address which has the function you want to automate.\nSelect the function you want to automate. \nIf your function accepts arguments\nChoose how you want your arguments to be passed. \nIf you are not sure about this, see \nDefining function inputs\n​\nDedicated msg.sender\nThe system will inform you of the address of msg.sender when your task is being executed. \nIf you are not sure about this, see \nDedicated msg.sender\n​\nWhen to execute\nPre-defined inputs\nWith pre-defined inputs chosen, you will see two options:\nTime - Task will be repeatedly executed at the interval frequency you specify after the start time you enter. \nWhenever possible - Task will be executed continuously whenever the transaction will not fail.\nMake sure the function can only be executed from time to time if \"Whenever possible\" is selected\nDynamic inputs via resolver\nIf you are using a resolver, fill in the resolver address that is deployed.\nPaying for fees\nChoose how you would like to pay for the execution fees for your task. \nDeposit some tokens if \"Gelato Balance\" is chosen.\nIf you are not sure about this, see \nPaying for your transactions\n​\nTask name (optional)\nYou will be prompted to enter a task name with some suggestions based on your contract. This is optional but if you have multiple tasks it will be much easier to track which task does what if you give it a name. Names are not stored on-chain.\nWhen you click Create Task you will be asked to sign a message to confirm the name and then sign a transaction to create your task on-chain. \n​\nDone!\nOnce your task creation transaction has been confirmed you will be redirected to the Task Page:\nHere you can see your task's details and monitor its task logs and executions.\nPrevious\nMethods for submitting your task\nNext\nGelato Automate SDK\nLast modified 1mo ago\nON THIS PAGE\nExecution contract details\nDedicated msg.sender\nWhen to execute\nPre-defined inputs\nDynamic inputs via resolver\nPaying for fees\nTask name (optional)\nDone!"
  },
  {
    "title": "Relay Context Contracts - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/non-erc-2771/callwithsyncfee/relay-context-contracts",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n3⃣\nsponsoredCall\n2⃣\ncallWithSyncFee\n🍧\nRelay Context Contracts\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🍧\nRelay Context Contracts\nGetting your smart contracts compatible with Gelato Relay's callWithSyncFee\nAfter reading this page: \nYou'll learn how to use our helper functions to get useful information from directly within your target contract. \nThese allow you access to the feeCollector, feeToken address , and fee amount from within your target contract.\nWhen using callWithSyncFee, you need to pay Gelato's fee collecting contract when your target function is called, otherwise your relay request will not execute. To carry out this payment, your target contract needs to know the address of the fee collector so that you can transfer funds during the call. Furthermore, you need to know in what token to pay the fee in, and how much to pay the fee collector. \nGelato Relay appends this useful information to the end of the calldata, when using the callWithSyncFee SDK method.  Gelato Relay's Context contracts give you helper functions which you can use via inheritance in your target contract allowing you to decode information from the relay calldata, giving you access to:\n uint256 _getFee(): a value denoting how much fee to pay.\n address _getFeeToken(): the address of the token the fee is paid in.\naddress _getFeeCollector(): the address to which to send your payment.\nNOTE: \nIf you need target function needs to know all three variables from the relay calldata, see GelatoRelayContext. \nIf you only need the feeCollector address (i.e. you already encode the fee and feeToken inside your own function parameters), see GelatoRelayFeeCollector.\nGetting Started\nInstalling relay-context \nrelay-context is an extremely simple way to create a Gelato Relay compatible smart contract, with just one import. \nnpm: @gelatonetwork/relay-context\nnpm\nTerminal\nNote: please make sure to use version v3.0.0 and above.\nnpm install --save-dev @gelatonetwork/relay-context\nor\nyarn add -D @gelatonetwork/relay-context\nSmart Contract\n1\nimport {\n2\n    GelatoRelayContext \n3\n} from \"@gelatonetwork/relay-context/contracts/GelatoRelayContext.sol\";\nfor GelatoRelayContext.\nOR:\nimport {\n    GelatoRelayFeeCollector\n} from \"@gelatonetwork/relay-context/contracts/GelatoRelayFeeCollector.sol\";\nfor GelatoRelayFeeCollector.\nGelatoRelayContext\nGelatoRelayContext allows your smart contract to retrieve the following information from the relay calldata :\n1.\nGelato's fee collector address, a contract specifically deployed for collecting relay fees securely. This allows a smart contract to transfer fees directly if you are using the syncFee payment method.\n2.\nThe fee token address specifying which address the fee will be paid in, which Gelato resolved from the original relay-SDK request body.\n3.\nThe fee itself, which includes the gas cost + Gelato's fee on top.\nBelow is an example:\n1\n// SPDX-License-Identifier: MIT\n2\npragma solidity 0.8.17;\n3\n​\n4\nimport {\n5\n    GelatoRelayContext\n6\n} from \"@gelatonetwork/relay-context/contracts/GelatoRelayContext.sol\";\n7\n​\n8\n// Inheriting GelatoRelayContext gives access to:\n9\n// 1. onlyGelatoRelay modifier\n10\n// 2. payment methods, i.e. _transferRelayFee\n11\n// 3. _getFeeCollector(), _getFeeToken(), _getFee()\n12\ncontract Counter is GelatoRelayContext {\n13\n    uint256 public counter;\n14\n    \n15\n    event IncrementCounter();\n16\n    \n17\n    // `increment` is the target function to call\n18\n    // this function increments a counter variable after payment to Gelato\n19\n    function increment() external onlyGelatoRelay {\n20\n        // Remember to autheticate your call since you are not using ERC-2771\n21\n        // _yourAuthenticationLogic()\n22\n            \n23\n        // Payment to Gelato\n24\n        // NOTE: be very careful here!\n25\n        // if you do not use the onlyGelatoRelay modifier,\n26\n        // anyone could encode themselves as the fee collector\n27\n        // in the low-level data and drain tokens from this contract.\n28\n        _transferRelayFee();\n29\n​\n30\n        counter++;\n31\n​\n32\n        emit IncrementCounter();\n33\n    }\n34\n}\nLine 12 inherits the GelatoRelayContext contract, giving access to these features:\nVerifying the caller:\nonlyGelatoRelay: a modifier which will only allow Gelato Relay to call this function.\n_isGelatoRelay(address _forwarder): a function which returns true if the address matches Gelato Relay's address.\nDecoding the calldata:\n_getFeeCollector() : a function to retrieve the fee collector address.\n_getFee(): a function to retrieve the fee that Gelato will charge. \n_getFeeToken(): a function to retrieve the address of the token used for fee payment.\nTransferring Fees to Gelato:\nAs you are using the callWithSyncFee SDK method, you can use the below helper functions to pay directly to Gelato:\n_transferRelayFee(): a function which transfers the fee amount to Gelato, with no cap. \n_transferRelayFeeCapped(uint256 _maxFee): a function which transfers the fee amount to Gelato which a set cap from the argument maxFee in wei. This helps limit fees on function calls in case of gas volatility or just for general budgeting.\nGelatoRelayFeeCollector\nWhy are there two different contracts that I can inherit? \nYou can choose to inherit either GelatoRelayContext or GelatoRelayFeeCollector. GelatoRelayContext gives you access to all three pieces of information: feeCollector, feeToken, and fee, whereas GelatoRelayFeeCollector assumes only the feeCollector address is appended to the calldata.\nWhich contract should I inherit?\nIn the majority of scenarios, inheriting from GelatoRelayContext is recommended. This approach provides the most convenient way to handle fees, as it only requires you to call either the _transferRelayFee() or _transferRelayFeeCapped(uint256 _maxFee) method. All other processes are managed seamlessly behind the scenes.\nIf the fee is known in advance - for instance, if you have already queried our fee oracle for the fee amount and a user has given their approval on this amount and the token to be used for payment via a front-end interface - you would only need to inform your smart contract where to direct this fee. In this case, you would require only the feeCollector address. For this purpose, please inherit from GelatoRelayFeeCollector. Refer to the following details.\nRecommendation: maximum fee signing\nThe fee oracle allows you to query and display a fee to your users before sending their transaction via Gelato Relay. Therefore, you could also give them the option to sign off on a certain fee. In this case, you might want to pass the fee you receive from the oracle directly to your target function as an argument.\nThis makes sense, but be wary that due to gas price volatility, a smoother UX might be to query the fee oracle and calculate a maximum fee by adding some overhead, and displaying this maximum fee to the user. This way, if gas prices do fluctuate more than normal, you can be certain that your user's transaction is executed. You can choose to set a very large overhead, or a smaller one, depending on your own trade-off between execution likelihood and cost to the user. This way, you can also integrate a fee check from inside target function to avoid any overpayments. \nGelatoRelayFeeCollector Integration\nGelatoRelayFeeCollector allows your smart contract to retrieve the following information from the relay calldata:\nGelato's fee collector address, a contract specifically deployed for collecting relay fees securely. This allows a smart contract to transfer fees directly if you are using the syncFee payment method.\nBelow is an example:\n1\n// SPDX-License-Identifier: MIT\n2\npragma solidity 0.8.17;\n3\n​\n4\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n5\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n6\nimport {\n7\n    SafeERC20\n8\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n9\nimport {\n10\n    GelatoRelayFeeCollector\n11\n} from \"@gelatonetwork/relay-context/contracts/GelatoRelayFeeCollector.sol\";\n12\n​\n13\ncontract Counter is GelatoRelayFeeCollector {\n14\n    using SafeERC20 for IERC20;\n15\n    uint256 public counter;\n16\n    \n17\n    event IncrementCounter();\n18\n    \n19\n    // `increment` is the target function to call\n20\n    // this function increments a counter variable after payment to Gelato\n21\n    function increment() external onlyGelatoRelay {\n22\n        // Remember to autheticate your call since you are not using ERC-2771\n23\n        // _yourAuthenticationLogic()\n24\n​\n25\n        // Retreiving the feeCollector address, using the nativeToken\n26\n        address feeCollector = _getFeeCollector();\n27\n        address nativeToken = \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\"; \n28\n        // Hardcoding the fee to 100 wei - NOTE: this is just for example\n29\n        // If you do not pay enough to feeCollector, \n30\n        // your relay request will not go through\n31\n        // In reality, you should pass in user signatures TODO\n32\n        uint256 fee = 100;\n33\n        \n34\n        // Payment to Gelato\n35\n        // NOTE: be very careful here!\n36\n        // if you do not use the onlyGelatoRelay modifier,\n37\n        // anyone could encode themselves as the fee collector\n38\n        // in the low-level data and drain tokens from this contract.\n39\n        transfer(nativeToken, feeCollector, fee);\n40\n​\n41\n        counter++;\n42\n​\n43\n        emit IncrementCounter();\n44\n    }\n45\n    \n46\n    \n47\n    function transfer(\n48\n        address _token,\n49\n        address _to,\n50\n        uint256 _amount\n51\n    ) internal {\n52\n        if (_amount == 0) return;\n53\n        _token == NATIVE_TOKEN\n54\n            ? Address.sendValue(payable(_to), _amount)\n55\n            : IERC20(_token).safeTransfer(_to, _amount);\n56\n    }\n57\n}\nLine 13 inherits the GelatoRelayFeeCollector contract, giving access to these features:\nVerifying the caller:\nonlyGelatoRelay: a modifier which will only allow Gelato Relay to call this function.\n_isGelatoRelay(address _forwarder): a function which returns true if the address matches Gelato Relay's address.\nDecoding the calldata:\n_getFeeCollector(): a function to retrieve the fee collector address.\nPrevious\ncallWithSyncFee\nNext\nGelato's Fee Oracle\nLast modified 4mo ago\nON THIS PAGE\nGetting Started\nInstalling relay-context\nGelatoRelayContext\nGelatoRelayFeeCollector\nWhy are there two different contracts that I can inherit?\nWhich contract should I inherit?\nGelatoRelayFeeCollector Integration"
  },
  {
    "title": "Smart Contract - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/methods-for-submitting-your-task/smart-contract#automatetaskcreator-functions",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGelato Automate UI\nGelato Automate SDK\nSmart Contract\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nSmart Contract\nUsing Automate programatically\nTasks created via this route cannot be named\nSmart Contracts can also create and cancel tasks on Gelato Automate.\nYou can find a list of example smart contracts here. \nAutomateTaskCreator functions\nHere are the functions exposed by AutomateTaskCreator which you can use when setting up your smart contract.\n_createTask()\nInteracts and creates a task on the Gelato Automate smart contract.\n    function _createTask(\n        address execAddress, \n        bytes memory execDataOrSelector, \n        ModuleData memory moduleData,\n        address feeToken \n    ) internal returns (bytes32 taskId);\nexecAddress - Address of the contract which Gelato will call.\nexecDataOrSelector - Signature of function which Gelato will call / execution data (If Resolver Module is not used. More about modules below)  \nmoduleData - Modules that are enabled for the task. (More about ModuleData below)\nfeeToken - Use address(0) if using Gelato balance. Use 0xeeeeee... for ETH or native tokens.\nModuleData\nstruct ModuleData {\n        Module[] modules;\n        bytes[] args;\n}\n Modules are conditions /  specifications about your task. These are the current available Modules.\nenum Module {\n    RESOLVER,  \n    TIME, \n    PROXY, \n    SINGLE_EXEC \n}\nRESOLVER - Define dynamic conditions and execution data. \nSmart Contract Resolvers\n​\nTIME - Repeated execution at a specific time and interval.\nPROXY - Your function will be called by a dedicated msg.sender.\nDedicated msg.sender\n​\nSINGLE_EXEC - Task is cancelled after one execution.\nEach Module would require additional arguments which is an encoded data. \nYou can use these helper functions to get the arguments for each Module. \n    function _resolverModuleArg(address _resolverAddress, bytes memory _resolverData)\n​\n    function _timeModuleArg(uint256 _startTime, uint256 _interval)\n    \n    function _proxyModuleArg()\n    \n    function _singleExecModuleArg()\nCrafting ModuleData will look like this if we want to create a task which utilise RESOLVER ,PROXY & SINGLE_EXEC Module.\n        ModuleData memory moduleData = ModuleData({\n            modules: new Module[](3),\n            args: new bytes[](3)\n        });\n​\n        moduleData.modules[0] = Module.RESOLVER;\n        moduleData.modules[1] = Module.PROXY;\n        moduleData.modules[2] = Module.SINGLE_EXEC\n​\n        moduleData.args[0] = _resolverModuleArg(\n            address(this),\n            abi.encodeCall(this.checker, ())\n        );\n        moduleData.args[1] = _proxyModuleArg();\n        moduleData.args[2] = _singleExecModuleArg();\nModule[] must follow the order RESOLVER, TIME, PROXY, SINGLE_EXEC\n_cancelTask()\nCancels a task owned by the smart contract.\n    function _cancelTask(bytes32 _taskId) internal\nonlyDedicatedMsgSender\nFunction modifier to restrict msg.sender to only task executions created by taskCreator (defined in constructor). \nDedicated msg.sender\n​\n    modifier onlyDedicatedMsgSender() {\n        require(msg.sender == dedicatedMsgSender, \"Only dedicated msg.sender\");\n        _;\n    }\nPROXY module must be enabled. Or else the msg.sender will be the Automate smart contract in \nContract Addresses\n​\n_depositFunds()\n    function _depositFunds(uint256 _amount, address _token) internal\nDeposit funds into the contract's Gelato balance. \nwithdrawFunds()\n    function withdrawFunds(uint256 _amount, address _token) external \nWithdraw funds from the contract's Gelato balance. Only fundsOwner defined in the constructor can call this function.\n​\nPrevious\nGelato Automate SDK\nNext\nGuides\nLast modified 1mo ago\nON THIS PAGE\nAutomateTaskCreator functions\n_createTask()\nModuleData\n_cancelTask()\nonlyDedicatedMsgSender\n_depositFunds()\nwithdrawFunds()"
  },
  {
    "title": "Using the UI - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/understanding-web3-functions/create-a-web3-function-task/using-the-ui",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n1⃣\nTrigger Types\n2⃣\nTypescript Function\n3⃣\nSolidity Function\n4⃣\nAutomated Transactions\n5⃣\nCreate a Web3 Function Task\n⏩\nUsing the UI\n⏩\nUsing a Smart Contract\n⏩\nUsing the Automate SDK\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n⏩\nUsing the UI\nCreating a Web3 Function Task via the UI\nThis method is ideal for developers or operators who prefer a graphical interface for task configuration. For instance, if you're a developer who wants to quickly test a function or a non-technical person looking to schedule a recurring job without writing any code.\nIn order to create a task that will automatically run your Web3 Function on your behalf, go to https://app.gelato.network/ and click on the \"Create Task\" button.\nTo learn about creating Typescript function tasks from the UI: \nCreating Typescript Function Task\n​\nTo learn about creating Solidity function tasks from the UI: \nCreating Solidity Function Tasks\n​\nTo learn about creating Automated Transaction Tasks from the UI: \nInitiate an Automated Transaction\n​\nSingle Execution Task\nIf you want to have Gelato call your function only once. If so, you can open up the Advanced Settings panel when creating a new task and select Single execution task\nThe task will still be canceled if the execution reverts on-chain\nPrevious\nCreate a Web3 Function Task\nNext\nUsing a Smart Contract\nLast modified 1mo ago\nON THIS PAGE\nCreating a Web3 Function Task via the UI\nSingle Execution Task"
  },
  {
    "title": "Deploying your VRF Instance - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/vrf/quick-start/deploying-your-vrf-instance",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\n📙\nUnderstanding VRF\n❔\nHow does Gelato VRF Work?\n🔓\nSecurity Considerations\n📄\nTemplate\n🚀\nQuick Start\n🚢\nDeploying your VRF Instance\n💡\nMigrating from Chainlink VRF\n💰\nPricing & Rate Limits\n✅\nSupported Networks\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🚢\nDeploying your VRF Instance\nDeploying your Gelato VRF instance is a straightforward process. Here's a step-by-step guide to get you started:\n1. Gather Necessary Addresses\nBefore you begin, make sure you have the address of your requester contract at hand. This will be essential for the deployment process.\n2.  Access the VRF Deployment Portal\nNavigate to the Gelato VRF app.\n3. Choose your VRF Type\nWhen prompted to select the VRF type, opt for \"Gelato VRF\". If you previously deployed a Chainlink consumer contract and wish to transition, refer to the Migrating from Chainlink VRF section.4. Select Deployment Network\nEnsure you choose the same network where both your VRF requester and receiver contracts are deployed.\n5. Specify the Request Contract\nYou'll be asked to provide the address of the Request Contract to which the Gelato nodes should respond. Enter the address you gathered in step 1.\n6. Launch your VRF Instance\nOnce all details are correctly entered, go ahead and launch your Gelato VRF instance.\nPrevious\nQuick Start\nNext\nMigrating from Chainlink VRF\nLast modified 1mo ago\nON THIS PAGE\n1. Gather Necessary Addresses\n2. Access the VRF Deployment Portal\n3. Choose your VRF Type\n5. Specify the Request Contract\n6. Launch your VRF Instance"
  },
  {
    "title": "Private Typescript Functions - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/quick-start/writing-typescript-functions/private-typescript-functions",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n➡\nWriting Typescript Functions\n⏩\nEvent Trigger\n⏩\nPrivate Typescript Functions\n➡\nTest, Deploy & Run Typescript functions\n➡\nWriting Solidity Functions\n➡\nTest, Deploy & Run Solidity Functions\n➡\nInitiate an Automated Transaction\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n⏩\nPrivate Typescript Functions\nDeployed Typescript Functions are public\nWhen you deploy a Typescript Function the code is stored and pinned on IPFS making it accessible to everyone. If you would prefer to conceal your code, one approach is to store your code in a private Github Gist. Subsequently, this code can be retrieved and executed through a Web3 Function.\nNote: this approach introduces a dependency on Github's availability. We aim to directly support private Web3 Function deployments in the future.\nPrivate Typescript Function example\nThis Typescript Function fetches onRun.js (Github gist containing concealed code) with its gist id and executes it during runtime. Check out the example on GitHub here.\nThe code in onRun.jsmust be in JavaScript\nprivate-w3f/index.ts\nimport {\n  Web3Function,\n  Web3FunctionContext,\n  Web3FunctionResult,\n} from \"@gelatonetwork/web3-functions-sdk\";\nimport { Octokit } from \"octokit\";\n​\n// import dependencies used in onRun.js\nimport { ethers } from \"ethers\";\nimport ky from \"ky\";\n​\nWeb3Function.onRun(async (context: Web3FunctionContext) => {\n  const { secrets } = context;\n​\n  const gistId = (await secrets.get(\"GIST_ID\")) as string;\n​\n  const octokit = new Octokit();\n​\n  let onRunScript: string | undefined;\n​\n  // fetch onRun.js from private github gist\n  try {\n    const gistDetails = await octokit.rest.gists.get({\n      gist_id: gistId,\n    });\n​\n    const files = gistDetails.data.files;\n​\n    if (!files) throw new Error(`No files in gist`);\n​\n    for (const file of Object.values(files)) {\n      if (file?.filename === \"onRun.js\" && file.content) {\n        onRunScript = file.content;\n        break;\n      }\n    }\n​\n    if (!onRunScript) throw new Error(`No onRun.js`);\n  } catch (err) {\n    return {\n      canExec: false,\n      message: `Error fetching gist: ${err.message}`,\n    };\n  }\n​\n  // run onRun.js\n  try {\n    /**\n     * context are passed into onRun.js.\n     * onRun.js will have access to all userArgs, secrets & storage\n     */\n    const onRunFunction = new Function(\"context\", \"ky\", \"ethers\", onRunScript);\n    const onRunResult: Web3FunctionResult = await onRunFunction(\n      context,\n      ky,\n      ethers\n    );\n​\n    if (onRunResult) {\n      return onRunResult;\n    } else {\n      return { canExec: false, message: `No result returned` };\n    }\n  } catch (err) {\n    console.log(err);\n    return {\n      canExec: false,\n      message: `Error running gist: ${err.message}`,\n    };\n  }\n});\nWriting onRun.js\nCheck out an example of a GitHub gist with onRun.js here.\n1. onRun.js file structure\nonRun.js should return a promise.\nonRun.js\nreturn (async () => {\n  // ... your code here\n})();\n2. Using dependencies\nDependencies that are used in onRun.js should be imported into the Web3 Function index.ts file, not in onRun.js.\nprivate-w3f/index.ts\n// import dependencies used in onRun.js\nimport { ethers } from \"ethers\";\nimport ky from \"ky\";\n3. Accessing Web3 Function Context\nWeb3 Function context which includes, secrets, userArgs, multiChainProvider can be accessed normally in onRun.js .\nonRun.js\nreturn (async () => {\n    const {secrets, userArgs, multiChainProvider} = context\n})();\n4. Return Web3 Function result\nResults returned in onRun.js will be bubbled up and returned in the private Web3 Function.\nonRun.js\nreturn {\n  canExec: true,\n  callData: [\n    {\n      to: oracleAddress,\n      data: oracle.interface.encodeFunctionData(\"updatePrice\", [price]),\n    },\n  ],\n}j\nCreating private Typescript Function task\nSecrets (strict)\nGIST_ID (Github gist id to fetch onRun.js from)\nMake sure to store your GitHub gist id as a secret.\nArguments (not strict)\nSince GitHub gists are editable, you can have a userArgs to be a JSON string so that arguments can be editable without re-deploying a web3 function with a different schema.\nprivate-w3f/schema.json\n{\n  \"web3FunctionVersion\": \"2.0.0\",\n  \"runtime\": \"js-1.0\",\n  \"memory\": 128,\n  \"timeout\": 30,\n  \"userArgs\": {\n    \"args\": \"string\"\n  }\n}\nExample args when creating your task:\n{\n  \"args\": \"{\\\"currency\\\":\\\"ethereum\\\",\\\"oracle\\\":\\\"0x71B9B0F6C999CBbB0FeF9c92B80D54e4973214da\\\"}\"\nPrevious\nEvent Trigger\nNext\nTest, Deploy & Run Typescript functions\nLast modified 2mo ago\nON THIS PAGE\nDeployed Typescript Functions are public\nPrivate Typescript Function example\nWriting onRun.js\n1. onRun.js file structure\n2. Using dependencies\n3. Accessing Web3 Function Context\n4. Return Web3 Function result\nCreating private Typescript Function task\nSecrets (strict)\nArguments (not strict)"
  },
  {
    "title": "Using a Smart Contract - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/understanding-web3-functions/create-a-web3-function-task/using-a-smart-contract",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n1⃣\nTrigger Types\n2⃣\nTypescript Function\n3⃣\nSolidity Function\n4⃣\nAutomated Transactions\n5⃣\nCreate a Web3 Function Task\n⏩\nUsing the UI\n⏩\nUsing a Smart Contract\n⏩\nUsing the Automate SDK\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n⏩\nUsing a Smart Contract\nUsing a Smart contract\nYou can create a task that uses Web3 Function from your smart contract as well.\nIf your project involves complex interactions and you need the task creation to be a part of an on-chain transaction, you would directly interact with a smart contract.\nWeb3 Function secrets are not available for smart contract created tasks.\nTo create a Web3 Function task with your smart contract, you can inherit AutomateTaskCreator which has helper functions to easily create your task. \nPass the Module.PROXY & Module.WEB3_FUNCTION as modules in ModuleData\n       ModuleData memory moduleData = ModuleData({\n            modules: new Module[](2),\n            args: new bytes[](2)\n        });\n        \n        moduleData.modules[0] = Module.PROXY;\n        moduleData.modules[1] = Module.WEB3_FUNCTION;\nUse _web3FunctionModuleArg to encode arguments for WEB3_FUNCTION module. \n    function _web3FunctionModuleArg(\n        string memory _web3FunctionHash, // IPFS CID of deployed web3Function\n        bytes calldata _web3FunctionArgsHex // Abi encoded web3 function arguments\n    ) \nHere is how you can encode your Web3Function arguments to get web3FunctionArgsHex.\nIn this example, the Web3Function has 2 arguments, counterW3fAddress & count . \nschema.json\n{\n  \"web3FunctionVersion\": \"2.0.0\",\n  \"runtime\": \"js-1.0\",\n  \"memory\": 128,\n  \"timeout\": 30,\n  \"userArgs\": {\n    \"counterW3fAddress\": \"string\",\n    \"count\": \"number\"\n  }\n}\nIn your contract, you would encode the arguments according to the sequence defined in schema.json .\n    function _getWeb3FunctionArgsHex(\n        address counterW3fAddress,\n        uint256 count\n    ) \n    internal \n    pure \n    returns (bytes memory web3FunctionArgsHex) {\n        web3FunctionArgsHex = abi.encode(counterW3fAddress, count)\n    }\nThe full code can be found here.\n    function createTask(\n        string memory _web3FunctionHash,\n        bytes calldata _web3FunctionArgsHex\n    ) external {\n        require(taskId == bytes32(\"\"), \"Already started task\");\n​\n        bytes memory execData = abi.encodeCall(this.increaseCount, (1));\n​\n        ModuleData memory moduleData = ModuleData({\n            modules: new Module[](2),\n            args: new bytes[](2)\n        });\n        moduleData.modules[0] = Module.PROXY;\n        moduleData.modules[1] = Module.WEB3_FUNCTION;\n​\n        moduleData.args[0] = _proxyModuleArg();\n        moduleData.args[1] = _web3FunctionModuleArg(\n            _web3FunctionHash,\n            _web3FunctionArgsHex\n        );\n​\n        bytes32 id = _createTask(\n            address(this),\n            execData,\n            moduleData,\n            address(0)\n        );\n​\n        taskId = id;\n        emit CounterTaskCreated(id);\n    }\nAdditional Info\nTasks created via this route cannot be named\nSmart Contracts can also create and cancel tasks.\nYou can find a list of example smart contracts here. \nHere are the functions exposed by AutomateTaskCreator which you can use when setting up your smart contract.\n_createTask()\nInteracts and creates a task on the Gelato Automate smart contract.\n    function _createTask(\n        address execAddress, \n        bytes memory execDataOrSelector, \n        ModuleData memory moduleData,\n        address feeToken \n    ) internal returns (bytes32 taskId);\nexecAddress - Address of the contract which Gelato will call.\nexecDataOrSelector - Signature of function which Gelato will call / execution data (If Resolver Module is not used. More about modules below)  \nmoduleData - Modules that are enabled for the task. (More about ModuleData below)\nfeeToken - Use address(0) if using Gelato 1balance. Use 0xeeeeee... for ETH or native tokens.\nModuleData\nstruct ModuleData {\n        Module[] modules;\n        bytes[] args;\n}\n Modules are conditions /  specifications about your task. These are the current available Modules.\nenum Module {\n    RESOLVER,\n    PROXY,\n    SINGLE_EXEC,\n    WEB3_FUNCTION,\n    TRIGGER\n}\nRESOLVER - Define dynamic conditions and execution data.\nTIME - Repeated execution at a specific time and interval.\nPROXY - Your function will be called by a dedicated msg.sender.\nDedicated msg.sender\n​\nSINGLE_EXEC - Task is cancelled after one execution.\nWEB3_FUNCTION - Define a Typescript function to get off-chain execution data.\nTRIGGER - Define your execution trigger (Time interval, Event, every block, ...)\nEach Module would require additional arguments which is an encoded data.\nIncluding Module.Proxy in moduleData is mandatory, otherwise task creation will fail.\nYou can use these helper functions to get the arguments for each Module.\n    function _resolverModuleArg(address _resolverAddress, bytes memory _resolverData)\n​\n    function _proxyModuleArg()\n    \n    function _singleExecModuleArg()\n    \n    function _timeTriggerModuleArg(uint128 _start, uint128 _interval)\n    \n    function _cronTriggerModuleArg(string memory _expression)\n    \n    function _blockTriggerModuleArg()\n    \n    function _eventTriggerModuleArg(\n        address _address,\n        bytes32[][] memory _topics,\n        uint256 _blockConfirmations\n    ) internal pure returns (bytes memory)\nCrafting ModuleData will look like this if we want to create a task which utilise RESOLVER ,PROXY & SINGLE_EXEC Module.\n        ModuleData memory moduleData = ModuleData({\n            modules: new Module[](3),\n            args: new bytes[](3)\n        });\n​\n        moduleData.modules[0] = Module.RESOLVER;\n        moduleData.modules[1] = Module.PROXY;\n        moduleData.modules[2] = Module.SINGLE_EXEC\n​\n        moduleData.args[0] = _resolverModuleArg(\n            address(this),\n            abi.encodeCall(this.checker, ())\n        );\n        moduleData.args[1] = _proxyModuleArg();\n        moduleData.args[2] = _singleExecModuleArg();\nModule[] must follow the order RESOLVER, PROXY, SINGLE_EXEC,   WEB3_FUNCTION, TRIGGER\n_cancelTask()\nCancels a task owned by the smart contract.\n    function _cancelTask(bytes32 _taskId) internal\nonlyDedicatedMsgSender\nFunction modifier to restrict msg.sender to only task executions created by taskCreator (defined in constructor). Learn more about it at \nSecurity Considerations\n​\n    modifier onlyDedicatedMsgSender() {\n        require(msg.sender == dedicatedMsgSender, \"Only dedicated msg.sender\");\n        _;\n    }\n_depositFunds1Balance()\n    function    function _depositFunds1Balance(\n        uint256 _amount,\n        address _token,\n        address _sponsor\n    )\nDeposit funds into the Gelato 1balance contract.\nThe _depositFunds1Balance method is only available on Polygon\nSingle Execution Task\nIf you want to have Gelato call your function only once. If so, you can Include SingleExec module in ModuleData.modules . Check out the full code here.\nModuleData memory moduleData = ModuleData({\n    modules: new Module[](2),\n    args: new bytes[](2)\n});\n​\nmoduleData.modules[0] = Module.PROXY;\nmoduleData.modules[1] = Module.SINGLE_EXEC;\n​\nmoduleData.args[0] = _proxyModuleArg();\nmoduleData.args[1] = _singleExecModuleArg();\n​\nbytes32 id = _createTask(\n    address(this),\n    execData,\n    moduleData,\n    address(0)\n);\nPrevious\nUsing the UI\nNext\nUsing the Automate SDK\nLast modified 1mo ago\nON THIS PAGE\nUsing a Smart contract\nAdditional Info\n_createTask()\nModuleData\n_cancelTask()\nonlyDedicatedMsgSender\n_depositFunds1Balance()\nSingle Execution Task"
  },
  {
    "title": "Relay Context Contracts ERC2771 - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/erc-2771-recommended/callwithsyncfeeerc2771/relay-context-contracts-erc2771#transferring-fees-to-gelato",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n1⃣\nsponsoredCallERC2771\n2⃣\ncallWithSyncFeeERC2771\n🍧\nRelay Context Contracts ERC2771\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🍧\nRelay Context Contracts ERC2771\nGetting your smart contracts compatible with Gelato Relay's callWithSyncFeeERC2771\nIf you are using @gelatonetwork/relay-sdk v3 or contracts from the package @gelatonetwork/relay-context v2 please follow this migration guide to migrate to the new versions.\nAfter reading this page: \nYou'll learn how to use our helper functions to get useful information from directly within your target contract. \nThese allow you access to the feeCollector, feeToken address , fee, and _msgSenderamount from within your target contract.\nWhen using callWithSyncFeeERC2771, you need to pay Gelato's fee collecting contract when your target function is called, otherwise your relay request will not execute. To carry out this payment, your target contract needs to know the address of the fee collector so that you can transfer funds during the call. Furthermore, you need to know in what token to pay the fee in, and how much to pay the fee collector. \nGelato Relay appends this useful information to the end of the calldata, when using the callWithSyncFeeERC2771 SDK method.  Gelato Relay's Context contracts give you helper functions which you can use via inheritance in your target contract allowing you to decode information from the relay calldata, giving you access to:\n uint256 _getFee(): a value denoting how much fee to pay.\n address _getFeeToken(): the address of the token the fee is paid in.\naddress _getFeeCollector(): the address to which to send your payment.\naddress _getMsgSender(): the address of the off-chain signer.\nNOTE: \nIf you need target function needs to know all four variables from the relay calldata, see GelatoRelayContextERC2771. \nIf you only need the feeCollector address (i.e. you already encode the fee and feeToken inside your own function parameters), see GelatoRelayFeeCollectorERC2771.\nGetting Started\nInstalling relay-context \nrelay-context is an extremely simple way to create a Gelato Relay compatible smart contract, with just one import.\nnpm: @gelatonetwork/relay-context\nnpm\nTerminal\nNote: please make sure to use version v3.0.0 and above.\nnpm install --save-dev @gelatonetwork/relay-context\nor\nyarn add -D @gelatonetwork/relay-context\nSmart Contract\n1\nimport {\n2\n    GelatoRelayContextERC2771 \n3\n} from \"@gelatonetwork/relay-context/contracts/GelatoRelayContextERC2771.sol\";\nfor GelatoRelayContextERC2771.\nOR:\nimport {\n    GelatoRelayFeeCollectorERC2771\n} from \"@gelatonetwork/relay-context/contracts/GelatoRelayFeeCollectorERC2771.sol\";\nfor GelatoRelayFeeCollectorERC2771.\nGelatoRelayContextERC2771\nGelatoRelayContextERC2771 allows your smart contract to retrieve the following information from the relay calldata:\n1.\nGelato's fee collector address, a contract specifically deployed for collecting relay fees securely. This allows a smart contract to transfer fees directly if you are using the syncFee payment method.\n2.\nThe fee token address specifying which address the fee will be paid in, which Gelato resolved from the original relay-SDK request body.\n3.\nThe fee itself, which includes the gas cost + Gelato's 10% fee on top.\n4.\nThe _getMsgSender() address, the off-chain signer address. \nBelow is an example:\n1\n// SPDX-License-Identifier: MIT\n2\npragma solidity 0.8.17;\n3\n​\n4\nimport {\n5\n    GelatoRelayContextERC2771\n6\n} from \"@gelatonetwork/relay-context/contracts/GelatoRelayContextERC2771.sol\";\n7\n​\n8\ncontract Counter is GelatoRelayContextERC2771 {\n9\n    mapping(address => uint256) public counter;\n10\n    \n11\n    event IncrementCounter();\n12\n    \n13\n    // `increment` is the target function to call\n14\n    // this function increments a counter variable after payment to Gelato\n15\n    function increment() external onlyGelatoRelay {\n16\n        // Payment to Gelato\n17\n        // NOTE: be very careful here!\n18\n        // if you do not use the onlyGelatoRelay modifier,\n19\n        // anyone could encode themselves as the fee collector\n20\n        // in the low-level data and drain tokens from this contract.\n21\n        _transferRelayFee();\n22\n​\n23\n        counter[_getMsgSender()] += 1;\n24\n​\n25\n        emit IncrementCounter();\n26\n    }\n27\n}\nLine 21 inherits the GelatoRelayContextERC2771 contract, giving access to these features:\nVerifying the caller:\nonlyGelatoRelay: a modifier which will only allow Gelato Relay to call this function.\n_isGelatoRelay(address _forwarder): a function which returns true if the address matches Gelato Relay's address.\nDecoding the calldata:\n_getFeeCollector() : a function to retrieve the fee collector address.\n_getFee(): a function to retrieve the fee that Gelato will charge. \n_getFeeToken(): a function to retrieve the address of the token used for fee payment.\n_getMsgSender(): a function to retrieve the off-chain signer address.\n_getMsgData():  a function to access the original msg.data without appended information.\nTransferring Fees to Gelato\nAs you are using the callWithSyncFeeERC2771 SDK method, you can use the below helper functions to pay directly to Gelato:\n_transferRelayFee(): a function which transfers the fee amount to Gelato, with no cap. \n_transferRelayFeeCapped(uint256 _maxFee): a function which transfers the fee amount to Gelato which a set cap from the argument maxFee in wei. This helps limit fees on function calls in case of gas volatility or just for general budgeting.\nGelatoRelayFeeCollectorERC2771\nWhy are there two different contracts that I can inherit? \nYou can choose to inherit either GelatoRelayContextERC2771 or GelatoRelayFeeCollectorERC2771. GelatoRelayContextERC2771 gives you access to all four pieces of information: feeCollector, feeToken, fee, and msg.sender whereas GelatoRelayFeeCollectorERC2771 assumes only the feeCollector and the msg.sender addresses are appended to the calldata.\nWhich contract should I inherit?\nIn the majority of scenarios, inheriting from GelatoRelayContextERC2771 is recommended. This approach provides the most convenient way to handle fees, as it only requires you to call either the _transferRelayFee() or _transferRelayFeeCapped(uint256 _maxFee) method. All other processes are managed seamlessly behind the scenes.\nIf the fee is known in advance - for instance, if you have already queried our fee oracle for the fee amount and a user has given their approval on this amount and the token to be used for payment via a front-end interface - you would only need to inform your smart contract where to direct this fee. In this case, you would require only the feeCollector address. For this purpose, please inherit from GelatoRelayFeeCollectorERC2771. Refer to the following details.\nRecommendation: maximum fee signing\nThe fee oracle allows you to query and display a fee to your users before sending their transaction via Gelato Relay. Therefore, you could also give them the option to sign off on a certain fee. In this case, you might want to pass the fee you receive from the oracle directly to your target function as an argument.\nThis makes sense, but be wary that due to gas price volatility, a smoother UX might be to query the fee oracle and calculate a maximum fee by adding some overhead, and displaying this maximum fee to the user. This way, if gas prices do fluctuate more than normal, you can be certain that your user's transaction is executed. You can choose to set a very large overhead, or a smaller one, depending on your own trade-off between execution likelihood and cost to the user. This way, you can also integrate a fee check from inside target function to avoid any overpayments. \nGelatoRelayFeeCollectorERC2771 Integration\nGelatoRelayFeeCollector allows your smart contract to retrieve the following information from the relay calldata:\n1.\nGelato's fee collector address, a contract specifically deployed for collecting relay fees securely. This allows a smart contract to transfer fees directly if you are using the syncFee payment method.\n2.\nThe _getMsgSender() address, the off-chain signer address. \nBelow is an example:\n1\n// SPDX-License-Identifier: MIT\n2\npragma solidity 0.8.17;\n3\n​\n4\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n5\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n6\nimport {\n7\n    SafeERC20\n8\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n9\nimport {\n10\n    GelatoRelayFeeCollectorERC2771\n11\n} from \"@gelatonetwork/relay-context/contracts/GelatoRelayFeeCollectorERC2771.sol\";\n12\n​\n13\ncontract Counter is GelatoRelayFeeCollectorERC2771 {\n14\n    using SafeERC20 for IERC20;\n15\n    mapping(address => uint256) public counter;\n16\n    \n17\n    event IncrementCounter();\n18\n    \n19\n    // `increment` is the target function to call\n20\n    // this function increments a counter variable after payment to Gelato\n21\n    function increment() external onlyGelatoRelay {\n22\n        // Retreiving the feeCollector address, using the nativeToken\n23\n        address feeCollector = _getFeeCollector();\n24\n        address nativeToken = \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\"; \n25\n        // Hardcoding the fee to 100 wei - NOTE: this is just for example\n26\n        // If you do not pay enough to feeCollector, \n27\n        // your relay request will not go through\n28\n        // In reality, you should pass in user signatures TODO\n29\n        uint256 fee = 100;\n30\n        \n31\n        // Payment to Gelato\n32\n        // NOTE: be very careful here!\n33\n        // if you do not use the onlyGelatoRelay modifier,\n34\n        // anyone could encode themselves as the fee collector\n35\n        // in the low-level data and drain tokens from this contract.\n36\n        transfer(nativeToken, feeCollector, fee);\n37\n​\n38\n        counter[_getMsgSender()] += 1;\n39\n        emit IncrementCounter();\n40\n    }\n41\n    \n42\n    \n43\n    function transfer(\n44\n        address _token,\n45\n        address _to,\n46\n        uint256 _amount\n47\n    ) internal {\n48\n        if (_amount == 0) return;\n49\n        _token == NATIVE_TOKEN\n50\n            ? Address.sendValue(payable(_to), _amount)\n51\n            : IERC20(_token).safeTransfer(_to, _amount);\n52\n    }\n53\n}\nLine 13 inherits the GelatoRelayFeeCollectorERC2771 contract, giving access to these features:\nVerifying the caller:\nonlyGelatoRelay: a modifier which will only allow Gelato Relay to call this function.\n_isGelatoRelay(address _forwarder): a function which returns true if the address matches Gelato Relay's address.\nDecoding the calldata:\n_getFeeCollector() : a function to retrieve the fee collector address.\n_getMsgSender(): a function to retrieve the off-chain signer address.\n_getMsgData():  a function to access the original msg.data without appended information.\nPrevious\ncallWithSyncFeeERC2771\nNext\nNon-ERC-2771\nLast modified 4mo ago\nON THIS PAGE\nGetting Started\nInstalling relay-context\nGelatoRelayContextERC2771\nGelatoRelayFeeCollectorERC2771\nWhy are there two different contracts that I can inherit?\nWhich contract should I inherit?\nGelatoRelayFeeCollectorERC2771 Integration"
  },
  {
    "title": "Event Trigger - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/quick-start/writing-typescript-functions/event-trigger",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n➡\nWriting Typescript Functions\n⏩\nEvent Trigger\n⏩\nPrivate Typescript Functions\n➡\nTest, Deploy & Run Typescript functions\n➡\nWriting Solidity Functions\n➡\nTest, Deploy & Run Solidity Functions\n➡\nInitiate an Automated Transaction\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n⏩\nEvent Trigger\nEvent Context\nFor event triggered typescript functions, use the Web3FunctionEventContext instead of the regular Web3FunctionContext on your onRun handler.\n\nThe context will then include a log property containing your full event log that you can parse and process.\nEvent Triggered Typescript Function example\nevent/index.ts\nimport { Interface } from \"@ethersproject/abi\";\nimport { Web3Function, Web3FunctionEventContext } from \"@gelatonetwork/web3-functions-sdk\";\n​\nconst NFT_ABI = [\n  \"event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)\",\n];\n​\nWeb3Function.onRun(async (context: Web3FunctionEventContext) => {\n  // Get event log from Web3FunctionEventContext\n  const { log } = context;\n  \n  // Parse your event from ABI\n  const nft = new Interface(NFT_ABI);\n  const event = nft.parseLog(log);\n​\n  // Handle event data\n  const { from, to, tokenId } = event.args;\n  console.log(`Transfer of NFT #${tokenId} from ${from} to ${to} detected`);\n  \n  return { canExec: false, message: `Event processed ${log.transactionHash}` };\n});\nTesting locally\nTo test your event triggered typescript function, you can add a log.json file in your web3 function directory:\nCopy in the log.json file the raw data of the event you want to test:\nevent/log.json\n{\n  \"blockNumber\": 48758053,\n  \"blockHash\": \"0x6794a56583329794f184d50862019ecf7b6d8ba6b3210f68ca4b91a8fa81817d\",\n  \"transactionIndex\": 29,\n  \"removed\": false,\n  \"address\": \"0xb74de3F91e04d0920ff26Ac28956272E8d67404D\",\n  \"data\": \"0x\",\n  \"topics\": [\n    \"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",\n    \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"0x000000000000000000000000eec2ba9b9f0202c63bba29ea9a4ce5c23f9865fd\",\n    \"0x0000000000000000000000000000000000000000000000000000000000001099\"\n  ],\n  \"transactionHash\": \"0x2c500a55f5c24d587e73805975d91395634a971dca5939f43d34d774d0f7147b\",\n  \"logIndex\": 343\n}\nThe data in log.json will be injected in your event context in local runs via CLI:\nnpx w3f test event/index.ts --logs\nWeb3Function running logs:\n> Transfer of NFT #4249 from 0x0000000000000000000000000000000000000000 to 0xeeC2ba9B9F0202c63bba29Ea9A4Ce5c23f9865FD detected\n​\nWeb3Function Result:\n ✓ Return value: {\"canExec\":false,\"message\":\"Event processed 0x2c500a55f5c24d587e73805975d91395634a971\nPrevious\nWriting Typescript Functions\nNext\nPrivate Typescript Functions\nLast modified 2mo ago\nON THIS PAGE\nEvent Context\nEvent Triggered Typescript Function example\nTesting locally"
  },
  {
    "title": "eth_supportedEntryPoints - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/account-abstraction/bundler-api-endpoints/eth_supportedentrypoints",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\neth_sendUserOperation\neth_estimateUserOperationGas\neth_getUserOperationByHash\neth_getUserOperationReceipt\neth_supportedEntryPoints\neth_maxPriorityFeePerGas\neth_chainId\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\neth_supportedEntryPoints\nPlease refer to 1Balance & Relay to create a sponsorApiKey.\nPOST\nhttps://api.gelato.digital/\n/bundlers/{chainId}/rpc\neth_supportedEntryPoints\n\nReturns an array of EntryPoint addresses supported by the bundler.\n\nParameters\nPath\nchainId*\nnumber\nTarget network chain identifier.\nQuery\nsponsorApiKey*\nstring\n1Balance API key which covers transaction costs.\nBody\nExample\nSchema\n{​\n  \"id\": 0,​\n  \"jsonrpc\": \"2.0\",​\n  \"method\": \"eth_supportedEntryPoints\"​\n​}\nResponses\n200: OK\nSuccessful response\n400: Bad Request\nValidation error\nPrevious\neth_getUserOperationReceipt\nNext\neth_maxPriorityFeePerGas\nLast modified 1mo ago"
  },
  {
    "title": "eth_maxPriorityFeePerGas - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/account-abstraction/bundler-api-endpoints/eth_maxpriorityfeepergas",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\neth_sendUserOperation\neth_estimateUserOperationGas\neth_getUserOperationByHash\neth_getUserOperationReceipt\neth_supportedEntryPoints\neth_maxPriorityFeePerGas\neth_chainId\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\neth_maxPriorityFeePerGas\nPlease refer to 1Balance & Relay to create a sponsorApiKey.\nThis method is implemented for compatibility reasons and always returns zero.\nPOST\nhttps://api.gelato.digital/\n/bundlers/{chainId}/rpc\neth_maxPriorityFeePerGas\n\nReturns an estimated priority fee per gas.\n\nParameters\nPath\nchainId*\nnumber\nTarget network chain identifier.\nQuery\nsponsorApiKey*\nstring\n1Balance API key which covers transaction costs.\nBody\nExample\nSchema\n{​\n  \"id\": 0,​\n  \"jsonrpc\": \"2.0\",​\n  \"method\": \"eth_maxPriorityFeePerGas\"​\n​}\nResponses\n200: OK\nSuccessful response\n400: Bad Request\nValidation error\nPrevious\neth_supportedEntryPoints\nNext\neth_chainId\nLast modified 1mo ago"
  },
  {
    "title": "SyncFee Payment Tokens - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/payment-and-fees/syncfee-payment-tokens",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n1⃣\n1Balance & Relay\n2⃣\nSyncFee Payment Tokens\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n2⃣\nSyncFee Payment Tokens\nLearn what payment tokens you can use in your transactions.\nWhen utilizing the callWithSyncFeeERC2771 or callWithSyncFee relay methods, you have the option to pay transaction fees with a token other than the native one. In addition to the native token, support is also extended to the wrapped native token, and on mainnets, the major ERC20 tokens. Please refer to the table below for the full array of supported tokens.\nMainnets\nNetwork\nPayment Tokens\nAll networks\nNATIVE:  0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\nArbitrum\nWETH:    0x82af49447d8a07e3bd95bd0d56f35241523fbab1\nDAI:     0xda10009cbd5d07dd0cecc66161fc93d7c9000da1\nUSDC.e:  0xff970a61a04b1ca14834a43f5de4533ebddb5cc8\nUSDC:    0xaf88d065e77c8cc2239327c5edb3a432268e5831\nUSDT:    0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9\nWBTC:    0x2f2a2543b76a4166549f7aab2e75bef0aefc5b0f\nAvalanche\nWAVAX:   0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7\nDAI.e:   0xd586e7f844cea2f87f50152665bcbc2c279d8d70\nUSDC.e:  0xa7d7079b0fead91f3e65f86e8915cb59c1a4c664\nUSDC:    0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e\nUSDT.e:  0xc7198437980c041c805a1edcba50c1ce5db95118\nUSDT:    0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7\nWBTC.e:  0x50b7545627a5162f82a992c33b87adc75187b218\nWETH.e:  0x49d5c2bdffac6ce2bfdb6640f4f80f226bc10bab\n\n\nBase \nWETH:    0x4200000000000000000000000000000000000006\nUSDbC:   0xd9aaec86b65d86f6a7b5b1b0c42ffa531710b6ca\nBNB\nWBNB:    0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\nBUSD:    0xe9e7cea3dedca5984780bafc599bd69add087d56\nBSC-USD: 0x55d398326f99059ff775485246999027b3197955\nHERO:    0xd40bedb44c081d2935eeba6ef5a3c8a31a1bbe13\nCAKE:    0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82\nBTCB:    0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c\nUSDC:    0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d\nEthereum\nWETH:    0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\nDAI:     0x6b175474e89094c44da98b954eedeac495271d0f\nUSDC:    0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\nUSDT:    0xdac17f958d2ee523a2206206994597c13d831ec7\nWBTC:    0x2260fac5e5542a773aa44fbcfedf7c193bc2c599\nGnosis\nWXDAI:   0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d\nGNO:     0x9C58BAcC331c9aa871AFD802DB6379a98e80CEdb\nUSDC:    0xDDAfbb505ad214D7b80b1f830fcCc89B60fb7A83\nUSDT:    0x4ECaBa5870353805a9F068101A40E0f32ed605C6\nWETH:    0x6A023CCd1ff6F2045C3309768eAd9E68F978f6e1\nLinea \nWETH:    0xe5D7C2a44FfDDf6b295A15c148167daaAf5Cf34f\nOptimism\nWETH:    0x4200000000000000000000000000000000000006\nDAI:     0xda10009cbd5d07dd0cecc66161fc93d7c9000da1\nUSDC:    0x7f5c764cbc14f9669b88837ca1490cca17c31607\nUSDT:    0x94b008aa00579c1307b0ef2c499ad98a8ce58e58\nWBTC:    0x68f180fcce6836688e9084f035309e29bf0a2095\nSNX:     0x8700daec35af8ff88c16bdf0418774cb3d7599b4\nAELIN:   0x61baadcf22d2565b0f471b291c475db5555e0b76\nFRAX:    0x2e3d870790dc77a83dd1d18184acc7439a53f475\nPolygon \nWMATIC:  0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270\nDAI:     0x8f3cf7ad23cd3cadbd9735aff958023239c6a063\nUSDC:    0x2791bca1f2de4661ed88a30c99a7a9449aa84174\nUSDT:    0xc2132d05d31c914a87c6611c10748aeb04b58e8f\nWBTC:    0x1bfd67037b42cf73acf2047067bd4f2c47d9bfd6\nWETH:    0x7ceb23fd6bc0add59e62ac25578270cff1b9f619\nPolygon zkEVM \nWETH:    0x4F9A0e7FD2Bf6067db6994CF12E4495Df938E6e9\nUSDC:    0xA8CE8aee21bC2A48a5EF670afCc9274C7bbbC035\nzkSync Era\nWETH:    0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91\nUSDC:    0x3355df6D4c9C3035724Fd0e3914dE96A5a83aaf4\nZora\nWETH:    0x4200000000000000000000000000000000000006\nShibarium\nWBONE:   0xC76F4c819D820369Fb2d7C1531aB3Bb18e6fE8d8\n​\nTestnets\nNetwork\nPayment Tokens\nAll networks\nNATIVE:  0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\nGelato OP Testnet\nWETH:    0x4200000000000000000000000000000000000006\nAstar zKatana\nWETH:    0x22f92e5a6219bEf9Aa445EBAfBeB498d2EAdBF01\nTangible Unreal\nWETH:    0x22f92e5a6219bEf9Aa445EBAfBeB498d2EAdBF01\nArbitrum Goerli\nWETH:    0xEe01c0CD76354C383B8c7B4e65EA88D00B06f36f\nBase Goelri\nWETH:    0x44D627f900da8AdaC7561bD73aA745F132450798\nGoerli\nWETH:    0x44D627f900da8AdaC7561bD73aA745F132450798\nChiado\nWXDAI:   0x18c8a7ec7897177E4529065a7E7B0878358B3BfF\nLinea Goerli\nWETH:    0x2C1b868d6596a18e32E61B901E4060C872647b6C\nMumbai\nWMATIC:  0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889\nOptimism Goerli\nWETH:    0x4200000000000000000000000000000000000006\nPolygon zkEVM  Goerli\nWETH:    0xeE589e91401066068AF129B0005aC3EF69E3fdB4\nzkSync Era Goerli\nWETH:    0x20b28B1e4665FFf290650586ad76E977EAb90c5D\nPrevious\n1Balance & Relay\nNext\nAPI\nLast modified 2mo ago\nON THIS PAGE\nMainnets\nTestnets"
  },
  {
    "title": "eth_getUserOperationReceipt - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/account-abstraction/bundler-api-endpoints/eth_getuseroperationreceipt",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\neth_sendUserOperation\neth_estimateUserOperationGas\neth_getUserOperationByHash\neth_getUserOperationReceipt\neth_supportedEntryPoints\neth_maxPriorityFeePerGas\neth_chainId\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\neth_getUserOperationReceipt\nPlease refer to 1Balance & Relay to create a sponsorApiKey.\nPOST\nhttps://api.gelato.digital/\n/bundlers/{chainId}/rpc\neth_getUserOperationReceipt\n\nReturns a UserOperationReceipt given a userOpHash.\n\nParameters\nPath\nchainId*\nnumber\nTarget network chain identifier.\nQuery\nsponsorApiKey*\nstring\n1Balance API key which covers transaction costs.\nBody\nExample\nSchema\n{​\n  \"id\": 0,​\n  \"jsonrpc\": \"2.0\",​\n  \"method\": \"eth_getUserOperationReceipt\",​\n  \"params\": [​\n    \"0xa501bf1cbb27adecb09aef8adb58ab5fe423be7975d5a4f687408525e4cabee9\"​\n  ]​\n​}\nResponses\n200: OK\nSuccessful response\n400: Bad Request\nValidation error\nPrevious\neth_getUserOperationByHash\nNext\neth_supportedEntryPoints\nLast modified 1mo ago"
  },
  {
    "title": "eth_getUserOperationByHash - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/account-abstraction/bundler-api-endpoints/eth_getuseroperationbyhash",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\neth_sendUserOperation\neth_estimateUserOperationGas\neth_getUserOperationByHash\neth_getUserOperationReceipt\neth_supportedEntryPoints\neth_maxPriorityFeePerGas\neth_chainId\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\neth_getUserOperationByHash\nPlease refer to 1Balance & Relay to create a sponsorApiKey.\nPOST\nhttps://api.gelato.digital/\n/bundlers/{chainId}/rpc\neth_getUserOperationByHash\n\nReturns a UserOperation given a userOpHash.\n\nParameters\nPath\nchainId*\nnumber\nTarget network chain identifier.\nQuery\nsponsorApiKey*\nstring\n1Balance API key which covers transaction costs.\nBody\nExample\nSchema\n{​\n  \"id\": 0,​\n  \"jsonrpc\": \"2.0\",​\n  \"method\": \"eth_getUserOperationByHash\",​\n  \"params\": [​\n    \"0xa501bf1cbb27adecb09aef8adb58ab5fe423be7975d5a4f687408525e4cabee9\"​\n  ]​\n​}\nResponses\n200: OK\nSuccessful response\n400: Bad Request\nValidation error\nPrevious\neth_estimateUserOperationGas\nNext\neth_getUserOperationReceipt\nLast modified 1mo ago"
  },
  {
    "title": "eth_estimateUserOperationGas - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/account-abstraction/bundler-api-endpoints/eth_estimateuseroperationgas",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\neth_sendUserOperation\neth_estimateUserOperationGas\neth_getUserOperationByHash\neth_getUserOperationReceipt\neth_supportedEntryPoints\neth_maxPriorityFeePerGas\neth_chainId\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\neth_estimateUserOperationGas\nPlease refer to 1Balance & Relay to create a sponsorApiKey.\nThe estimated preVerificationGas is always zero as it is not required by the bundler. Instead, transaction fees are settled post-execution which avoids overcharging the user. Other implementations unconditionally charge users the entire preVerificationGas amount since this is not metered by the EntryPoint.\nSee Advantages & Highlights.\nPrevious\neth_sendUserOperation\nNext\neth_getUserOperationByHash\nLast modified 1mo ago"
  },
  {
    "title": "eth_sendUserOperation - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/account-abstraction/bundler-api-endpoints/eth_senduseroperation",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\neth_sendUserOperation\neth_estimateUserOperationGas\neth_getUserOperationByHash\neth_getUserOperationReceipt\neth_supportedEntryPoints\neth_maxPriorityFeePerGas\neth_chainId\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\neth_sendUserOperation\nPlease refer to 1Balance & Relay to create a sponsorApiKey.\nThe maxFeePerGas and paymasterAndData fields must be zero to avoid on-chain EntryPoint fee payments. This decreases overhead and leads to gas savings.\nSee Advantages & Highlights.\nPOST\nhttps://api.gelato.digital/\n/bundlers/{chainId}/rpc\neth_sendUserOperation\n\nSends a UserOperation to the specified network.\n\nParameters\nPath\nchainId*\nnumber\nTarget network chain identifier.\nQuery\nsponsorApiKey*\nstring\n1Balance API key which covers transaction costs.\nretries\nnumber\nNumber of times to retry failing transactions.\nBody\nExample\nSchema\n{​\n  \"id\": 0,​\n  \"jsonrpc\": \"2.0\",​\n  \"method\": \"eth_sendUserOperation\",​\n  \"params\": [​\n    {​\n      \"sender\": \"string\",​\n      \"nonce\": \"string\",​\n      \"initCode\": \"string\",​\n      \"callData\": \"string\",​\n      \"signature\": \"string\",​\n      \"paymasterAndData\": \"0x\",​\n      \"callGasLimit\": \"string\",​\n      \"verificationGasLimit\": \"string\",​\n      \"preVerificationGas\": \"0x0\",​\n      \"maxFeePerGas\": \"0x0\",​\n      \"maxPriorityFeePerGas\": \"string\"​\n    },​\n    \"0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789\"​\n  ]​\n​}\nResponses\n200: OK\nSuccessful response\n400: Bad Request\nValidation error\nPrevious\nBundler API Endpoints\nNext\neth_estimateUserOperationGas\nLast modified 1mo ago"
  },
  {
    "title": "Private Typescript Functions - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/quick-start/writing-typescript-functions/private-typescript-functions",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n➡\nWriting Typescript Functions\n⏩\nEvent Trigger\n⏩\nPrivate Typescript Functions\n⏩\nCallbacks\n➡\nTest, Deploy & Run Typescript functions\n➡\nWriting Solidity Functions\n➡\nTest, Deploy & Run Solidity Functions\n➡\nInitiate an Automated Transaction\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n⏩\nPrivate Typescript Functions\nDeployed Typescript Functions are public\nWhen you deploy a Typescript Function the code is stored and pinned on IPFS making it accessible to everyone. If you would prefer to conceal your code, one approach is to store your code in a private Github Gist. Subsequently, this code can be retrieved and executed through a Web3 Function.\nNote: this approach introduces a dependency on Github's availability. We aim to directly support private Web3 Function deployments in the future.\nPrivate Typescript Function example\nThis Typescript Function fetches onRun.js (Github gist containing concealed code) with its gist id and executes it during runtime. Check out the example on GitHub here.\nThe code in onRun.jsmust be in JavaScript\nprivate-w3f/index.ts\nimport {\n  Web3Function,\n  Web3FunctionContext,\n  Web3FunctionResult,\n} from \"@gelatonetwork/web3-functions-sdk\";\nimport { Octokit } from \"octokit\";\n​\n// import dependencies used in onRun.js\nimport { ethers } from \"ethers\";\nimport ky from \"ky\";\n​\nWeb3Function.onRun(async (context: Web3FunctionContext) => {\n  const { secrets } = context;\n​\n  const gistId = (await secrets.get(\"GIST_ID\")) as string;\n​\n  const octokit = new Octokit();\n​\n  let onRunScript: string | undefined;\n​\n  // fetch onRun.js from private github gist\n  try {\n    const gistDetails = await octokit.rest.gists.get({\n      gist_id: gistId,\n    });\n​\n    const files = gistDetails.data.files;\n​\n    if (!files) throw new Error(`No files in gist`);\n​\n    for (const file of Object.values(files)) {\n      if (file?.filename === \"onRun.js\" && file.content) {\n        onRunScript = file.content;\n        break;\n      }\n    }\n​\n    if (!onRunScript) throw new Error(`No onRun.js`);\n  } catch (err) {\n    return {\n      canExec: false,\n      message: `Error fetching gist: ${err.message}`,\n    };\n  }\n​\n  // run onRun.js\n  try {\n    /**\n     * context are passed into onRun.js.\n     * onRun.js will have access to all userArgs, secrets & storage\n     */\n    const onRunFunction = new Function(\"context\", \"ky\", \"ethers\", onRunScript);\n    const onRunResult: Web3FunctionResult = await onRunFunction(\n      context,\n      ky,\n      ethers\n    );\n​\n    if (onRunResult) {\n      return onRunResult;\n    } else {\n      return { canExec: false, message: `No result returned` };\n    }\n  } catch (err) {\n    console.log(err);\n    return {\n      canExec: false,\n      message: `Error running gist: ${err.message}`,\n    };\n  }\n});\nWriting onRun.js\nCheck out an example of a GitHub gist with onRun.js here.\n1. onRun.js file structure\nonRun.js should return a promise.\nonRun.js\nreturn (async () => {\n  // ... your code here\n})();\n2. Using dependencies\nDependencies that are used in onRun.js should be imported into the Web3 Function index.ts file, not in onRun.js.\nprivate-w3f/index.ts\n// import dependencies used in onRun.js\nimport { ethers } from \"ethers\";\nimport ky from \"ky\";\n3. Accessing Web3 Function Context\nWeb3 Function context which includes, secrets, userArgs, multiChainProvider can be accessed normally in onRun.js .\nonRun.js\nreturn (async () => {\n    const {secrets, userArgs, multiChainProvider} = context\n})();\n4. Return Web3 Function result\nResults returned in onRun.js will be bubbled up and returned in the private Web3 Function.\nonRun.js\nreturn {\n  canExec: true,\n  callData: [\n    {\n      to: oracleAddress,\n      data: oracle.interface.encodeFunctionData(\"updatePrice\", [price]),\n    },\n  ],\n}j\nCreating private Typescript Function task\nSecrets (strict)\nGIST_ID (Github gist id to fetch onRun.js from)\nMake sure to store your GitHub gist id as a secret.\nArguments (not strict)\nSince GitHub gists are editable, you can have a userArgs to be a JSON string so that arguments can be editable without re-deploying a web3 function with a different schema.\nprivate-w3f/schema.json\n{\n  \"web3FunctionVersion\": \"2.0.0\",\n  \"runtime\": \"js-1.0\",\n  \"memory\": 128,\n  \"timeout\": 30,\n  \"userArgs\": {\n    \"args\": \"string\"\n  }\n}\nExample args when creating your task:\n{\n  \"args\": \"{\\\"currency\\\":\\\"ethereum\\\",\\\"oracle\\\":\\\"0x71B9B0F6C999CBbB0FeF9c92B80D54e4973214da\\\"}\"\nPrevious\nEvent Trigger\nNext\nCallbacks\nLast modified 2mo ago\nON THIS PAGE\nDeployed Typescript Functions are public\nPrivate Typescript Function example\nWriting onRun.js\n1. onRun.js file structure\n2. Using dependencies\n3. Accessing Web3 Function Context\n4. Return Web3 Function result\nCreating private Typescript Function task\nSecrets (strict)\nArguments (not strict)"
  },
  {
    "title": "Callbacks - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/quick-start/writing-typescript-functions/callbacks",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n➡\nWriting Typescript Functions\n⏩\nEvent Trigger\n⏩\nPrivate Typescript Functions\n⏩\nCallbacks\n➡\nTest, Deploy & Run Typescript functions\n➡\nWriting Solidity Functions\n➡\nTest, Deploy & Run Solidity Functions\n➡\nInitiate an Automated Transaction\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n⏩\nCallbacks\nCallbacks can be used to manage the outcome of your transaction submission. This advanced feature enables your functions to adapt based on the execution status, whether successful or not, thus providing a robust way to handle different scenarios that may occur during task execution. Let’s explore the two types of callbacks available:\nCallback Function Example:\nimport {\n  Web3Function,\n  Web3FunctionContext,\n  Web3FunctionFailContext,\n  Web3FunctionSuccessContext,\n} from \"@gelatonetwork/web3-functions-sdk\";\nimport { Contract } from \"@ethersproject/contracts\";\nimport ky from \"ky\"; // Using ky for HTTP requests\n​\nconst ORACLE_ABI = [\n  \"function lastUpdated() external view returns(uint256)\",\n  \"function updatePrice(uint256)\",\n];\n​\n// Callback for successful execution\nWeb3Function.onSuccess(async (context: Web3FunctionSuccessContext) => {\n  const { transactionHash } = context;\n  //onSuccess Logic goes here\n});\n​\n// Callback for handling failures\nWeb3Function.onFail(async (context: Web3FunctionFailContext) => {\n  const { reason, transactionHash, callData } = context;\n  //onFail Logic goes here\n});\n​\n// Main function logic\nWeb3Function.onRun(async (context: Web3FunctionContext) => {\n  const { userArgs, multiChainProvider } = context;\n​\n  // Core logic goes here to prepare callData\n  \n  \n  return {\n    canExec: false,\n    message: \"Nothing to execute yet\"\n  };\n});\nTypes of Callbacks\nonSuccess Callback\nThis callback gets invoked after a successful on-chain execution. It’s especially useful for tracking successful transactions or for further processing after a task completes.\nWeb3Function.onSuccess(async (context: Web3FunctionSuccessContext) => {\n  const { transactionHash } = context;\n  console.log(\"onSuccess: txHash: \", transactionHash);\n});\nThe Web3FunctionSuccessContext offers access to the transactionHash, allowing you to reference and track the successful transaction within your application.\nonFail Callback\nTriggered when an on-chain execution encounters issues such as \nInsufficientFunds: When the account executing the function does not have enough balance to cover the transaction fees.\nSimulationFailed: If the execution simulation (a pre-run of the transaction) fails, indicating that the actual transaction might also fail.\nExecutionReverted: When the actual transaction is executed on the blockchain but is reverted due to a condition in the smart contract code or because it runs out of gas.\nThis callback is crucial for handling errors and implementing fallback logic.\nWeb3Function.onFail(async (context: Web3FunctionFailContext) => {\n  const { reason } = context;\n​\n  if (reason === \"ExecutionReverted\") {\n    console.log(`onFail: ${reason} txHash: ${context.transactionHash}`);\n  } else if (reason === \"SimulationFailed\") {\n    console.log(\n      `onFail: ${reason} callData: ${JSON.stringify(context.callData)}`\n    );\n  } else {\n    console.log(`onFail: ${reason}`);\n  }\n});\nIn the context of the onFail callback:\nreason: This is a string indicating why the failure occurred.\n transactionHash: Provided when the reason for failure is ExecutionReverted, this is the unique identifier of the reverted transaction.\ncallData: Available when the reason is SimulationFailed, this is the data that was used during the function run, which can be useful for debugging the failure.\nTesting Your Callbacks\nYou can test your callbacks locally using specific flags during the test execution. This helps in ensuring that your callbacks function as intended before deployment.\nFor onFail Callback:\nyarn test src/web3-functions/callbacks/index.ts --logs --onFail\nWeb3Function building...\n​\nWeb3Function Build result:\n ✓ Schema: web3-functions\\oracle-callback\\schema.json\n ✓ Built file: C:\\Users\\aniru\\OneDrive\\Desktop\\Gelato_internship\\w3f-example\\web3-functions-hardhat-template\\.tmp\\index.js\n ✓ File size: 0.64mb\n ✓ Build time: 150.48ms\n​\nWeb3Function user args validation:\n ✓ currency: ethereum\n ✓ oracle: 0x71B9B0F6C999CBbB0FeF9c92B80D54e4973214da\n​\nWeb3Function running logs:\n> userArgs:  undefined\n> onFail: SimulationFailed callData: [{\"to\":\"0x0000000000000000000000000000000000000000\",\"data\":\"0x00000000\"}]\n​\nWeb3Function onFail result:\n ✓ Success\n​\nWeb3Function Runtime stats:\n ✓ Duration: 0.20s\n ✓ Memory: 0.00mb\n ✓ Storage: 0.04kb\n ✓ Network: 0 req [ DL: 0.00kb / UL:  0.00kb]\n ✓ Rpc calls: 0\nDone in 1.33s.\nFor onSuccesssCallback\nyarn test src/web3-functions/callbacks/index.ts --logs --onSuccess\nWeb3Function Build result:\n ✓ Schema: web3-functions\\oracle-callback\\schema.json\n ✓ Built file: C:\\Users\\aniru\\OneDrive\\Desktop\\Gelato_internship\\w3f-example\\web3-functions-hardhat-template\\.tmp\\index.js\n ✓ File size: 0.64mb\n ✓ Build time: 143.00ms\n​\nWeb3Function user args validation:\n ✓ currency: ethereum\n ✓ oracle: 0x71B9B0F6C999CBbB0FeF9c92B80D54e4973214da\n​\nWeb3Function running logs:\n> userArgs:  undefined\n> onSuccess: txHash:  undefined\n​\nWeb3Function onSuccess result:\n ✓ Success\n​\nWeb3Function Runtime stats:\n ✓ Duration: 0.19s\n ✓ Memory: 0.00mb\n ✓ Storage: 0.04kb\n ✓ Network: 0 req [ DL: 0.00kb / UL:  0.00kb]\n ✓ Rpc calls: 0\nDone in 1.47s.\n​\nPrevious\nPrivate Typescript Functions\nNext\nTest, Deploy & Run Typescript functions\nLast modified 1mo ago\nON THIS PAGE\nCallback Function Example:\nTypes of Callbacks\nTesting Your Callbacks"
  },
  {
    "title": "Using the UI - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/understanding-web3-functions/create-a-web3-function-task/using-the-ui",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n1⃣\nTrigger Types\n2⃣\nTypescript Function\n3⃣\nSolidity Function\n4⃣\nAutomated Transactions\n5⃣\nCreate a Web3 Function Task\n⏩\nUsing the UI\n⏩\nUsing a Smart Contract\n⏩\nUsing the Automate SDK\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n⏩\nUsing the UI\nCreating a Web3 Function Task via the UI\nThis method is ideal for developers or operators who prefer a graphical interface for task configuration. For instance, if you're a developer who wants to quickly test a function or a non-technical person looking to schedule a recurring job without writing any code.\nIn order to create a task that will automatically run your Web3 Function on your behalf, go to https://app.gelato.network/ and click on the \"Create Task\" button.\nTo learn about creating Typescript function tasks from the UI: \nCreating Typescript Function Task\n​\nTo learn about creating Solidity function tasks from the UI: \nCreating Solidity Function Tasks\n​\nTo learn about creating Automated Transaction Tasks from the UI: \nInitiate an Automated Transaction\n​\nSingle Execution Task\nIf you want to have Gelato call your function only once. If so, you can open up the Advanced Settings panel when creating a new task and select Single execution task\nThe task will still be canceled if the execution reverts on-chain\nPrevious\nCreate a Web3 Function Task\nNext\nUsing a Smart Contract\nLast modified 1mo ago\nON THIS PAGE\nCreating a Web3 Function Task via the UI\nSingle Execution Task"
  },
  {
    "title": "Using a Smart Contract - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/understanding-web3-functions/create-a-web3-function-task/using-a-smart-contract",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n1⃣\nTrigger Types\n2⃣\nTypescript Function\n3⃣\nSolidity Function\n4⃣\nAutomated Transactions\n5⃣\nCreate a Web3 Function Task\n⏩\nUsing the UI\n⏩\nUsing a Smart Contract\n⏩\nUsing the Automate SDK\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n⏩\nUsing a Smart Contract\nUsing a Smart contract\nYou can create a task that uses Web3 Function from your smart contract as well.\nIf your project involves complex interactions and you need the task creation to be a part of an on-chain transaction, you would directly interact with a smart contract.\nWeb3 Function secrets are not available for smart contract created tasks.\nTo create a Web3 Function task with your smart contract, you can inherit AutomateTaskCreator which has helper functions to easily create your task. \nPass the Module.PROXY & Module.WEB3_FUNCTION as modules in ModuleData\n       ModuleData memory moduleData = ModuleData({\n            modules: new Module[](2),\n            args: new bytes[](2)\n        });\n        \n        moduleData.modules[0] = Module.PROXY;\n        moduleData.modules[1] = Module.WEB3_FUNCTION;\nUse _web3FunctionModuleArg to encode arguments for WEB3_FUNCTION module. \n    function _web3FunctionModuleArg(\n        string memory _web3FunctionHash, // IPFS CID of deployed web3Function\n        bytes calldata _web3FunctionArgsHex // Abi encoded web3 function arguments\n    ) \nHere is how you can encode your Web3Function arguments to get web3FunctionArgsHex.\nIn this example, the Web3Function has 2 arguments, counterW3fAddress & count . \nschema.json\n{\n  \"web3FunctionVersion\": \"2.0.0\",\n  \"runtime\": \"js-1.0\",\n  \"memory\": 128,\n  \"timeout\": 30,\n  \"userArgs\": {\n    \"counterW3fAddress\": \"string\",\n    \"count\": \"number\"\n  }\n}\nIn your contract, you would encode the arguments according to the sequence defined in schema.json .\n    function _getWeb3FunctionArgsHex(\n        address counterW3fAddress,\n        uint256 count\n    ) \n    internal \n    pure \n    returns (bytes memory web3FunctionArgsHex) {\n        web3FunctionArgsHex = abi.encode(counterW3fAddress, count)\n    }\nThe full code can be found here.\n    function createTask(\n        string memory _web3FunctionHash,\n        bytes calldata _web3FunctionArgsHex\n    ) external {\n        require(taskId == bytes32(\"\"), \"Already started task\");\n​\n        bytes memory execData = abi.encodeCall(this.increaseCount, (1));\n​\n        ModuleData memory moduleData = ModuleData({\n            modules: new Module[](2),\n            args: new bytes[](2)\n        });\n        moduleData.modules[0] = Module.PROXY;\n        moduleData.modules[1] = Module.WEB3_FUNCTION;\n​\n        moduleData.args[0] = _proxyModuleArg();\n        moduleData.args[1] = _web3FunctionModuleArg(\n            _web3FunctionHash,\n            _web3FunctionArgsHex\n        );\n​\n        bytes32 id = _createTask(\n            address(this),\n            execData,\n            moduleData,\n            address(0)\n        );\n​\n        taskId = id;\n        emit CounterTaskCreated(id);\n    }\nAdditional Info\nTasks created via this route cannot be named\nSmart Contracts can also create and cancel tasks.\nYou can find a list of example smart contracts here. \nHere are the functions exposed by AutomateTaskCreator which you can use when setting up your smart contract.\n_createTask()\nInteracts and creates a task on the Gelato Automate smart contract.\n    function _createTask(\n        address execAddress, \n        bytes memory execDataOrSelector, \n        ModuleData memory moduleData,\n        address feeToken \n    ) internal returns (bytes32 taskId);\nexecAddress - Address of the contract which Gelato will call.\nexecDataOrSelector - Signature of function which Gelato will call / execution data (If Resolver Module is not used. More about modules below)  \nmoduleData - Modules that are enabled for the task. (More about ModuleData below)\nfeeToken - Use address(0) if using Gelato 1balance. Use 0xeeeeee... for ETH or native tokens.\nModuleData\nstruct ModuleData {\n        Module[] modules;\n        bytes[] args;\n}\n Modules are conditions /  specifications about your task. These are the current available Modules.\nenum Module {\n    RESOLVER,\n    PROXY,\n    SINGLE_EXEC,\n    WEB3_FUNCTION,\n    TRIGGER\n}\nRESOLVER - Define dynamic conditions and execution data.\nTIME - Repeated execution at a specific time and interval.\nPROXY - Your function will be called by a dedicated msg.sender.\nDedicated msg.sender\n​\nSINGLE_EXEC - Task is cancelled after one execution.\nWEB3_FUNCTION - Define a Typescript function to get off-chain execution data.\nTRIGGER - Define your execution trigger (Time interval, Event, every block, ...)\nEach Module would require additional arguments which is an encoded data.\nIncluding Module.Proxy in moduleData is mandatory, otherwise task creation will fail.\nYou can use these helper functions to get the arguments for each Module.\n    function _resolverModuleArg(address _resolverAddress, bytes memory _resolverData)\n​\n    function _proxyModuleArg()\n    \n    function _singleExecModuleArg()\n    \n    function _timeTriggerModuleArg(uint128 _start, uint128 _interval)\n    \n    function _cronTriggerModuleArg(string memory _expression)\n    \n    function _blockTriggerModuleArg()\n    \n    function _eventTriggerModuleArg(\n        address _address,\n        bytes32[][] memory _topics,\n        uint256 _blockConfirmations\n    ) internal pure returns (bytes memory)\nCrafting ModuleData will look like this if we want to create a task which utilise RESOLVER ,PROXY & SINGLE_EXEC Module.\n        ModuleData memory moduleData = ModuleData({\n            modules: new Module[](3),\n            args: new bytes[](3)\n        });\n​\n        moduleData.modules[0] = Module.RESOLVER;\n        moduleData.modules[1] = Module.PROXY;\n        moduleData.modules[2] = Module.SINGLE_EXEC\n​\n        moduleData.args[0] = _resolverModuleArg(\n            address(this),\n            abi.encodeCall(this.checker, ())\n        );\n        moduleData.args[1] = _proxyModuleArg();\n        moduleData.args[2] = _singleExecModuleArg();\nModule[] must follow the order RESOLVER, PROXY, SINGLE_EXEC,   WEB3_FUNCTION, TRIGGER\n_cancelTask()\nCancels a task owned by the smart contract.\n    function _cancelTask(bytes32 _taskId) internal\nonlyDedicatedMsgSender\nFunction modifier to restrict msg.sender to only task executions created by taskCreator (defined in constructor). Learn more about it at \nSecurity Considerations\n​\n    modifier onlyDedicatedMsgSender() {\n        require(msg.sender == dedicatedMsgSender, \"Only dedicated msg.sender\");\n        _;\n    }\n_depositFunds1Balance()\n    function    function _depositFunds1Balance(\n        uint256 _amount,\n        address _token,\n        address _sponsor\n    )\nDeposit funds into the Gelato 1balance contract.\nThe _depositFunds1Balance method is only available on Polygon\nSingle Execution Task\nIf you want to have Gelato call your function only once. If so, you can Include SingleExec module in ModuleData.modules . Check out the full code here.\nModuleData memory moduleData = ModuleData({\n    modules: new Module[](2),\n    args: new bytes[](2)\n});\n​\nmoduleData.modules[0] = Module.PROXY;\nmoduleData.modules[1] = Module.SINGLE_EXEC;\n​\nmoduleData.args[0] = _proxyModuleArg();\nmoduleData.args[1] = _singleExecModuleArg();\n​\nbytes32 id = _createTask(\n    address(this),\n    execData,\n    moduleData,\n    address(0)\n);\nPrevious\nUsing the UI\nNext\nUsing the Automate SDK\nLast modified 1mo ago\nON THIS PAGE\nUsing a Smart contract\nAdditional Info\n_createTask()\nModuleData\n_cancelTask()\nonlyDedicatedMsgSender\n_depositFunds1Balance()\nSingle Execution Task"
  },
  {
    "title": "Event Trigger - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/quick-start/writing-typescript-functions/event-trigger",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n➡\nWriting Typescript Functions\n⏩\nEvent Trigger\n⏩\nPrivate Typescript Functions\n⏩\nCallbacks\n➡\nTest, Deploy & Run Typescript functions\n➡\nWriting Solidity Functions\n➡\nTest, Deploy & Run Solidity Functions\n➡\nInitiate an Automated Transaction\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n⏩\nEvent Trigger\nEvent Context\nFor event triggered typescript functions, use the Web3FunctionEventContext instead of the regular Web3FunctionContext on your onRun handler.\n\nThe context will then include a log property containing your full event log that you can parse and process.\nEvent Triggered Typescript Function example\nevent/index.ts\nimport { Interface } from \"@ethersproject/abi\";\nimport { Web3Function, Web3FunctionEventContext } from \"@gelatonetwork/web3-functions-sdk\";\n​\nconst NFT_ABI = [\n  \"event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)\",\n];\n​\nWeb3Function.onRun(async (context: Web3FunctionEventContext) => {\n  // Get event log from Web3FunctionEventContext\n  const { log } = context;\n  \n  // Parse your event from ABI\n  const nft = new Interface(NFT_ABI);\n  const event = nft.parseLog(log);\n​\n  // Handle event data\n  const { from, to, tokenId } = event.args;\n  console.log(`Transfer of NFT #${tokenId} from ${from} to ${to} detected`);\n  \n  return { canExec: false, message: `Event processed ${log.transactionHash}` };\n});\nTesting locally\nTo test your event triggered typescript function, you can add a log.json file in your web3 function directory:\nCopy in the log.json file the raw data of the event you want to test:\nevent/log.json\n{\n  \"blockNumber\": 48758053,\n  \"blockHash\": \"0x6794a56583329794f184d50862019ecf7b6d8ba6b3210f68ca4b91a8fa81817d\",\n  \"transactionIndex\": 29,\n  \"removed\": false,\n  \"address\": \"0xb74de3F91e04d0920ff26Ac28956272E8d67404D\",\n  \"data\": \"0x\",\n  \"topics\": [\n    \"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",\n    \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"0x000000000000000000000000eec2ba9b9f0202c63bba29ea9a4ce5c23f9865fd\",\n    \"0x0000000000000000000000000000000000000000000000000000000000001099\"\n  ],\n  \"transactionHash\": \"0x2c500a55f5c24d587e73805975d91395634a971dca5939f43d34d774d0f7147b\",\n  \"logIndex\": 343\n}\nThe data in log.json will be injected in your event context in local runs via CLI:\nnpx w3f test event/index.ts --logs\nWeb3Function running logs:\n> Transfer of NFT #4249 from 0x0000000000000000000000000000000000000000 to 0xeeC2ba9B9F0202c63bba29Ea9A4Ce5c23f9865FD detected\n​\nWeb3Function Result:\n ✓ Return value: {\"canExec\":false,\"message\":\"Event processed 0x2c500a55f5c24d587e73805975d91395634a971\nPrevious\nWriting Typescript Functions\nNext\nPrivate Typescript Functions\nLast modified 2mo ago\nON THIS PAGE\nEvent Context\nEvent Triggered Typescript Function example\nTesting locally"
  },
  {
    "title": "Custom logic triggers - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/guides/custom-logic-triggers",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nTutorials\nWhat tasks can be automated?\nDefining function inputs\nCustom logic triggers\nSmart Contract Resolvers\nWeb3 Functions\nDedicated msg.sender\nSingle Execution Task\nMulti contract execution\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nCustom logic triggers\nWhat is a resolver and when do you need it?\nA resolver is a smart contract in which developers can embed their logic of \"when\" an execution should occur and what data should executors use for the execution. Gelato will query these resolvers periodically to check if it is time to execute. \nYou need a resolver if\nYou want to define the conditions of \"when\" Gelato should execute your task.\nYou want to have different arguments for the function you are automating on each execution.\nYou do not need a resolver if\nYou simply want to repeatedly call a smart contract function with the same or without arguments (e.g. every 1 hour). \nIf you just want Gelato to try to execute a particular function in case it does NOT revert\nWe give developers the freedom to choose what kind of resolver they want to use. \n​\nSmart contract resolver\nA smart contract resolver is deployed on the corresponding network. (e.g. Ethereum Mainnet, Fantom) If you feel more comfortable writing in solidity, or have a simple condition that only uses on-chain data, you could go with this option.\n(BETA) Web3 Functions\nWeb3 Functions enables you to define conditions and generate payload for execution based on off-chain data. (e.g. API calls & subgraph queries).\nPrevious\nDefining function inputs\nNext\nSmart Contract Resolvers\nLast modified 2mo ago\nON THIS PAGE\nWhat is a resolver and when do you need it?\nSmart contract resolver\n(BETA) Web3 Functions"
  },
  {
    "title": "Legacy Automate Migration Guide - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/legacy-automate-migration-guide",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nLegacy Automate Migration Guide\nDeprecation Notice: Gelato Functions is set to replace Automate, providing enhanced automation capabilities, access to off-chain data, unified payments across networks, and a performance boost. Migrate your tasks to Gelato Functions before Legacy Automate's end of life on June 30th, 2024 for uninterrupted service.\nGelato Functions replacing Automate\nWith the launch of Gelato Functions we are deprecating our Automate service.\nThe key benefits of Gelato Functions include:\n\n\nAccess off-chain data & computation via Typescript Functions\nUnified payments across all networks via 1Balance\nListen to on-chain Events to trigger your Functions\nSupport for many more networks\nMuch higher performance and lower latencies\nEnhanced UX, DevX and analytics\nTo get these benefits users need to migrate their tasks from Automate (now Legacy Automate) to Gelato Functions.\nWhen should I migrate?\nLegacy Automate will be deprecated 30th June 2024 so users should plan to migrate to Functions before this date.\nLegacy Automate: Key Changes\nFrom 1st December 2023, some Legacy Automate tasks will be expired and won’t be checked anymore. Check conditions for expired tasks. \nFrom 1st January 2024, Automate Legacy transactions will cost 50% higher than on new Gelato Functions. Check details on cost changes. \nCost changes\nGelato Functions unifies your transaction costs across all networks using our 1Balance system. For each execution of your target contract you will be billed the USDC equivalent of your gas costs plus a fee - the fee varies depending on the network and your subscription plan.\nFees will be applied to all Automate Legacy transactions from 1st January 2024. These fees will be 50% higher than those on Gelato Functions.\n\n\nTask Expiries\nAs part of the migration we are going to introduce task expiries from 1st December 2023 - any Legacy Automate tasks that meet the following conditions will be automatically cancelled.\n\n\nTestnets\n\n\nTasks expire after 30 days without any execution\n\n\nMainnets\n\n\nTasks expire after 120 days without any execution\n\n\nIf you have any concerns about these limits please do not hesitate to reach out to us.\n\n\nNaming Updates\nWe have updated what some things are called in Functions, but they are directly equivalent. The most notable one is that Resolvers are now called Solidity Functions - the smart contract code that determines if your target contract can be executed and with what payload.\nThe flow for creating a new task has been changed to follow more of an “if this then that” pattern and allows you to also use Typescript functions that tap into off-chain APIs to also determine when target contracts should be executed and with what payloads.\n\n\nHow do I migrate a task from Legacy Automate to Functions?\nThe exact steps you need to go through will depend on the precise characteristics of your existing tasks. Here is some general guidance - if you have any questions or require further support please contact us for assistance.\n1. Smart contract changes (optional)\nIf you are inheriting AutomateReady or OpsReady in your target contracts, upgrade them to use the new version of AutomateReady​\nIf you are whitelisting Gelato as an restricted msg.sender, update your whitelisting to use your new dedicated msg.sender:\nCheck your dedicated msg.sender address on each network here: https://app.gelato.network/settings​\n🔐\nSecurity Considerations\n2. Create your new tasks on app.gelato.network\nConnect to app.gelato.network to create your new tasks\nIf you were using “Resolver”, they are now called “Solidity functions”\nif you were using \"Predefined Inputs\", they are now called \"Automated Transactions\"\n3. Deposit into 1Balance\nDeposit $USDC into your 1Balance to pay for your transactions across all networks \nSet up low balance e-mail alert\n1Balance Alerts\nGelato Network\nYour tasks are now up and running on the new Gelato Functions \n✅\n​\n4. Cancel old tasks & withdraw remaining balance\nConnect to Automate Legacy app and check the modal listing all your current active tasks\nManually \"Pause\" all your old tasks\nWithdraw your assets on each network where you still hold any balance on Gelato TaskTreasury\nAdvanced user migration\nCreating tasks via Smart Contract\nUpgrade your Smart Contracts to use the latest version AutomateTaskCreator​\nIf you were relying on Time Module, it has been replaced by Trigger Module, which allows similar configurations\nfunction _timeTriggerModuleArg(uint128 _start, uint128 _interval)\nNote that it’s now required to use the Proxy Module on all your task creations, to enforce stricter security\nCreating tasks via SDK\nMake sure to upgrade to use the latest version of the automate-sdk:\nyarn add @gelatonetwork/automate-sdk\nYou can create task using the same createTask method\nif you were using startTime & interval, these options are now available inside the trigger configuration:\ntrigger: {\n  type: TriggerType.TIME; // time interval trigger\n  interval: number; // task interval in ms\n  start: number; // task start timestamp, task will start immediately if undefined or 0\n}\nPrevious\nContract Addresses\nNext - GELATO DAO\nDAO & Token (GEL)\nLast modified 1mo ago\nON THIS PAGE\nGelato Functions replacing Automate\nWhen should I migrate?\nLegacy Automate: Key Changes\nCost changes\nTask Expiries\nNaming Updates\nHow do I migrate a task from Legacy Automate to Functions?\nAdvanced user migration"
  },
  {
    "title": "Tutorials - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/guides/tutorials",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nTutorials\nWhat tasks can be automated?\nDefining function inputs\nCustom logic triggers\nDedicated msg.sender\nSingle Execution Task\nMulti contract execution\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nTutorials\nBasic Example\nFor this basic example we'll be executing a task to a regular schedule.\nInteractive Example\nStep-by-step Example\nIf you prefer a more interactive experience, please follow the Tutorial on the official Gelato Automate website. In this tutorial, you will get to mint a Gelato ice cream NFT which you can \"lick\", but only every 5 minutes, otherwise you get \"brainfreeze\". We recommend you do the Tutorial on Polygon or Goerli. \nTo accomplish this, you can create a task to automate this licking using Gelato in order to not having to do it manually yourself. \n\n\nLook out for this graphic to get started:\n\n\n​\nIn-depth Tutorials\nMany use cases involve writing a resolver to enable Gelato to constantly evaluate whether the conditions for your task to be executed have been met. \nIn this excellent tutorial, you learn a real-world use case - automating a NFT rental marketplace - using Gelato Automate and Truffle:\nWeb3 Unleashed: How to Automate Your Smart Contracts - Truffle Suite\nPrevious\nGuides\nNext\nWhat tasks can be automated?\nLast modified 1mo ago\nON THIS PAGE\nBasic Example\nIn-depth Tutorials"
  },
  {
    "title": "What tasks can be automated? - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/guides/what-tasks-can-be-automated",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nTutorials\nWhat tasks can be automated?\nDefining function inputs\nCustom logic triggers\nDedicated msg.sender\nSingle Execution Task\nMulti contract execution\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nWhat tasks can be automated?\nFunctions that can be automated should follow these properties:\nThey need to be functions that are usually called by the development team or external keepers, not \"user facing\" functions called by users directly\nThey need to be either public or external\nThey do not have access restrictions like an onlyOwner modifier, unless the Automate contract is a whitelisted address\nThey do not require msg.sender to be tx.origin\nPrevious\nTutorials\nNext\nDefining function inputs\nLast modified 1mo ago"
  },
  {
    "title": "Contract Addresses - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/contract-addresses",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nContract Addresses\nGelato Automate addresses for each supported network.\nDeprecation Notice: Gelato Functions is set to replace Automate, providing enhanced automation capabilities, access to off-chain data, unified payments across networks, and a performance boost. Migrate your tasks to Gelato Functions before Legacy Automate's end of life on June 30th, 2024 for uninterrupted service.\nGelato Network is the entry point for Gelato Executors to execute transactions. The contract does several security checks and then calls the exec() function on the Automate(formerly Ops) contract. \nThe Automate smart contract then either calls your target smart contract directly or, if you use the dedicated msg.sender module, it will route the call via your dedicated msg.sender contract. \nNote: If you have an access restriction for your smart contract function and want to whitelist Gelato as a msg.sender,we automatically deploy your own dedicated msg.sender - the address to whitelist will be shown in the UI and can also be retrieved via the Automate SDK.\nMainnet\nContract\nAddress\nGelato Network\n0x3CACa7b48D0573D793d3b0279b5F0029180E83b6\nAutomate\n0xB3f5503f93d5Ef84b06993a1975B9D21B962892F\nTaskTreasury\n0x2807B4aE232b624023f87d0e237A3B1bf200Fd99\nPolygon / Matic\nContract\nAddress\nGelato Network\n0x7598e84B2E114AB62CAB288CE5f7d5f6bad35BbA\nAutomate\n0x527a819db1eb0e34426297b03bae11F2f8B3A19E\nTaskTreasury\n0x32DC6700AC87f6300277a63b0A4fDf132A8392bd\nFantom\nContract\nAddress\nGelato Network\n0xebA27A2301975FF5BF7864b99F55A4f7A457ED10\nAutomate\n0x6EDe1597c05A0ca77031cBA43Ab887ccf24cd7e8\nTaskTreasury\n0x0af13072280E10907911ce5d046c2DfA1B604d23\nArbitrum\nContract\nAddress\nGelato Network\n0x4775aF8FEf4809fE10bf05867d2b038a4b5B2146\nAutomate\n0xB3f5503f93d5Ef84b06993a1975B9D21B962892F\nTaskTreasury\n0xB2f34fd4C16e656163dADFeEaE4Ae0c1F13b140A\nAvalanche\nContract\nAddress\nGelato Network\n0x7C5c4Af1618220C090A6863175de47afb20fa9Df\nAutomate\n0x8aB6aDbC1fec4F18617C9B889F5cE7F28401B8dB\nTaskTreasury\n0xe167199A490b04042414aFD71830bBF165f44C09\nBNB Chain\nContract\nAddress\nGelato Network\n0x7C5c4Af1618220C090A6863175de47afb20fa9Df\nAutomate\n0x527a819db1eb0e34426297b03bae11F2f8B3A19E\nTaskTreasury\n0xbECe6A2101eC94E817c072622671B399A3508Ac1\n​\nGnosis\nContract\nAddress\nGelato Network\n0x29b6603D17B9D8f021EcB8845B6FD06E1Adf89DE\nAutomate\n0x8aB6aDbC1fec4F18617C9B889F5cE7F28401B8dB\nTaskTreasury\n0x04462c8ad55a3d970fd9b4944A2f4C7c15700883\nOptimism\nContract\nAddress\nGelato Network\n0x01051113D81D7d6DA508462F2ad6d7fD96cF42Ef\nAutomate\n0x340759c8346A1E6Ed92035FB8B6ec57cE1D82c2c\nTaskTreasury\n0xB3f5503f93d5Ef84b06993a1975B9D21B962892F\n​\nStaging\nGoerli\nContract\nAddress\nGelato Network\n0x683913B3A32ada4F8100458A3E1675425BdAa7DF\nAutomate\n0xc1C6805B857Bef1f412519C4A842522431aFed39\nTaskTreasury\n0xF381dfd7a139caaB83c26140e5595C0b85DDadCd\nArbitrum Goerli\nContract\nAddress\nGelato Network\n0xF82D64357D9120a760e1E4C75f646C0618eFc2F3\nAutomate\n0xa5f9b728ecEB9A1F6FCC89dcc2eFd810bA4Dec41\nTaskTreasury\n0x8aB6aDbC1fec4F18617C9B889F5cE7F28401B8dB\nOptimism Goerli\nContract\nAddress\nGelato Network\n0xF82D64357D9120a760e1E4C75f646C0618eFc2F3\nAutomate\n0x255F82563b5973264e89526345EcEa766DB3baB2\nTaskTreasury\n0x644CB00854EDC55FE8CCC9c1967BABb22F08Ad2f\nBase Goerli\nContract\nAddress\nGelato Network\n0xbe77Cd403Be3F2C7EEBC3427360D3f9e5d528F43\nAutomate\n0x2501648Bf32e6ea8804d4603e3794f651CCEceC0\nTaskTreasury\n0x8b8997c0d5cb5d117C636FebF35979AF6C3B46E5\nPolygon Mumbai\nContract\nAddress\nGelato Network\n0x25aD59adbe00C2d80c86d01e2E05e1294DA84823\nAutomate\n0xB3f5503f93d5Ef84b06993a1975B9D21B962892F\nTaskTreasury\n0x527a819db1eb0e34426297b03bae11F2f8B3A19E\nPrevious\nCode Repositories\nNext\nLegacy Automate Migration Guide\nLast modified 2mo ago\nON THIS PAGE\nMainnet\nPolygon / Matic\nFantom\nArbitrum\nAvalanche\nBNB Chain\nGnosis\nOptimism\nStaging\nGoerli\nArbitrum Goerli\nOptimism Goerli\nBase Goerli\nPolygon Mumbai"
  },
  {
    "title": "Code Repositories - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/code-repositories",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nCode Repositories\nDeprecation Notice: Gelato Functions is set to replace Automate, providing enhanced automation capabilities, access to off-chain data, unified payments across networks, and a performance boost. Migrate your tasks to Gelato Functions before Legacy Automate's end of life on June 30th, 2024 for uninterrupted service.\nAutomate Smart Contracts:\nGitHub - gelatodigital/automate: Automate arbitrary smart contracts with Gelato Automate\nGitHub\nAutomate SDK:\nGitHub - gelatodigital/automate-sdk: Gelato Automate SDK\nGitHub\nPrevious\nPetting Aavegotchis\nNext\nContract Addresses\nLast modified 2mo ago\nON THIS PAGE\nAutomate Smart Contracts:\nAutomate SDK:"
  },
  {
    "title": "Template real-world examples - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/template-real-world-examples",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nYield vault harvesting\nRewards Payout\nPetting Aavegotchis\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nTemplate real-world examples\nDeprecation Notice: Gelato Functions is set to replace Automate, providing enhanced automation capabilities, access to off-chain data, unified payments across networks, and a performance boost. Migrate your tasks to Gelato Functions before Legacy Automate's end of life on June 30th, 2024 for uninterrupted service.\nIn this section we provide some useful real-world examples that you can use to help you get started. Please click through below.\nPrevious\nMonitoring Automate Tasks\nNext\nYield vault harvesting\nLast modified 2mo ago"
  },
  {
    "title": "Monitoring Automate Tasks - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/monitoring-automate-tasks",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nMonitoring Automate Tasks\nLearn how to monitor your Web3 Function Task\nDeprecation Notice: Gelato Functions is set to replace Automate, providing enhanced automation capabilities, access to off-chain data, unified payments across networks, and a performance boost. Migrate your tasks to Gelato Functions before Legacy Automate's end of life on June 30th, 2024 for uninterrupted service.\nBesides the task logs available in the UI, Gelato Web3 Functions offer a more detailed and granular monitoring system providing status and logs APIs.\nTask Status URL\nProvided the ChainId and taskId,  this API will return the current Task status\nhttps://api.gelato.digital/tasks/automate/networks/{chainId}/tasks/{taskId}/status\nFor example, if your chainId, taskId are:\nchainId: 137\ntaskId: 0x1d029e6ac412e7b4544bb07a8f12ffc33c668d5ddfa3d479def13d548cd72c4b\nThen the URL to go to is:\nhttps://api.gelato.digital/tasks/automate/networks/137/tasks/0x1d029e6ac412e7b4544bb07a8f12ffc33c668d5ddfa3d479def13d548cd72c4b/status\nFor this taskId, here is the returned task information:\n{\n    \"task {     \n        \"chainId\":137,\n        \"taskId\":\n        \"0x1d029e6ac412e7b4544bb07a8f12ffc33c668d5ddfa3d479def13d548cd72c4b\",\n        \"taskState\":\"CheckPending\",\n        \"creationDate\":\"2022-10-27T09:22:01.434Z\",\n        \"lastCheckDate\":\"2023-06-15T06:03:05.501Z\",\n        \"lastCheckMessage\":\"!canExec\"\n        }\n}\nThe first thing to look at is the taskState key:\nTask states:\nFor the taskState key, these are the possible values:\nCheckPending: the task is pending simulation.\nExecPending: the task is executable and is awaiting inclusion into the blockchain.\nWaitingForConfirmation: the task was included into the blockchain but is still awaiting the required amount of blocks confirmations.\nExecSuccess: the task has been successfully executed.\nCancelled: the task has been canceled by the owner\nExecReverted: the task transaction has been reverted.\nTask  Logs URL\nProvided the ChainId and taskId,  this API will return the logs in the last 24 hours, the query param limit is optional\nhttps://api.gelato.digital/tasks/automate/networks/{chainId}/tasks/{taskId}/logs?limit=NrLogs\nFor example, if your chainId, taskId and NrLogs are:\nchainId: 137\ntaskId: 0x1d029e6ac412e7b4544bb07a8f12ffc33c668d5ddfa3d479def13d548cd72c4b\nNrLogs:2\nThen the URL to go to is:\nhttps://api.gelato.digital/tasks/automate/networks/137/tasks/0x1d029e6ac412e7b4544bb07a8f12ffc33c668d5ddfa3d479def13d548cd72c4b/logs?limit=2\nFor this taskId, here is the returned task information:\n{\n    \"logs\":[\n           {\n            \"date\":\"2023-06-15T06:05:38.975Z\",\n            \"state\":\"CheckPending\",\n            \"type\":\"ResolverCheck\",\n            \"message\":\"!canExec\"\n           },\n           {\n            \"date\":\"2023-06-15T06:05:24.349Z\",\n            \"state\":\"CheckPending\",\n            \"type\":\"ResolverCheck\",\n            \"message\":\"!canExec\"\n           }\n        ]\n}\nPrevious\nMulti contract execution\nNext\nTemplate real-world examples\nLast modified 2mo ago\nON THIS PAGE\nTask Status URL\nTask Logs URL"
  },
  {
    "title": "Guides - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/guides",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nTutorials\nWhat tasks can be automated?\nDefining function inputs\nCustom logic triggers\nDedicated msg.sender\nSingle Execution Task\nMulti contract execution\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nGuides\nDeprecation Notice: Gelato Functions is set to replace Automate, providing enhanced automation capabilities, access to off-chain data, unified payments across networks, and a performance boost. Migrate your tasks to Gelato Functions before Legacy Automate's end of life on June 30th, 2024 for uninterrupted service.\nPrevious\nSmart Contract\nNext\nTutorials\nLast modified 2mo ago"
  },
  {
    "title": "Execution & Balance Alerts - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/execution-and-balance-alerts",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nExecution & Balance Alerts\nDeprecation Notice: Gelato Functions is set to replace Automate, providing enhanced automation capabilities, access to off-chain data, unified payments across networks, and a performance boost. Migrate your tasks to Gelato Functions before Legacy Automate's end of life on June 30th, 2024 for uninterrupted service.\nAutomate provides an alerting service to enable you to get notified about your task executions, problems or when your balance is getting low. Alerting currently supports notifications in Telegram and Discord, with other channels on the way.\nTypes of notifications\nType\nDescription\nBalance\nIf your task uses Gelato Balance you need to ensure that you always have enough funds deposited, otherwise your executions will stop executing until you top-up. \n\nSet a balance alert to be notified when your funds are running low - you can use our default levels or set your own threshold.\nExecution Success\nGet notified every time your task executes a transaction successfully\nExecution Revert\nAlerts you if your task executes a transaction but it reverts\nSimulation Fail\nAlerts you when Automate has identified that your task should be executed but it is failing in simulation and would revert on-chain. These alerts are most suitable for scheduled or resolver tasks. \nSetting up Telegram Notifications\nYou can visit your notifications area to follow the steps listed below.\n1.\nAdd GelatoWatcherBot to your Telegram - if you have Telegram installed you can just click on the link to do this.  \n2.\nEnter the command /start\n3.\nThe bot will show you the main alerts that you can request by entering the command.\nTelegram bot will introduce to the main commands it supports\nWhen you enter each command the bot will step you through the inputs required to finish setting up the alert. \nYou can view the full list of commands at any time by entering /help\nTelegram Bot Commands\nCommand\nUsage\n/balance\nAlerts when your Gelato Balance drops below the minimum balance threshold. The default thresholds are listed here. \n​\nThe bot will prompt you for the wallet address that you use to create and manage your tasks. \n​\nTo provide multiple addresses enter each one as a new message to the bot.\n​\nIf you use the same wallet address across multiple networks, you will be alerted when any of these drop below the default thresholds.\n\nIf you would like to set your own threshold use the /balance_threshold command.\n/balance_threshold\nAlerts you when your Gelato Balance drops below the threshold you set on a specific network.\n\nAfter entering the /balance_threshold command the bot will prompt you to specify the chain IDs and your threshold level. Chain IDs are listed here. \n\n\nFor example to be alerted when your Gelato Balance drops below 0.15 ETH on mainnet you would enter 1,0.15\n/list_threshold\nList all custom and default balance thresholds of each network\n/stop_balance\nSwitch off all low balance alerts\n/simulation_fail\nNotifies you when your task is due to be executed but when Gelato simulates the transaction it determines that it will revert when executed on-chain. You will probably need to debug an issue with your target contract.\n\nThe bot will ask you to send the task id for your task in a new message. \n/stop_simulation_fail\nSwitch off all simulation failure notifications\n/exec_success\nNotifies each times your task executes a transaction. \n/stop_exec_success\nSwitch of all execution success notifications\n/exec_revert\nAlerts you to any on-chain reverts when Gelato has executed a transaction for your task.\n/stop_exec_revert\nSwitch of all revert notifications\nDiscord DM Notifications\nIn this mode you receive your alerts as DM's to your Discord handle. To activate:\n1.\nJoin our Gelato Discord server​\n2.\nChoose from the list of commands below\nIf you would prefer to receive alerts in a specific channel please see how to get Discord notifications in your server.\nCommand\nUsage\n/balance-dmaddress\nAlerts when your Gelato Balance drops below the default threshold for the specified wallet address. The default thresholds are listed below. \n​\nTo provide multiple addresses enter a new command to the bot for each address.\n​\nIf you use the same wallet address across multiple networks, you will be alerted when any of these drop below the default thresholds.\n\nTo set your own threshold use the /balance-threshold-dm command.\n/balance-threshold-dm chain_id threshold\nAlerts you when your Gelato Balance drops below the threshold you set on a specific network.\n\nUse the /balance-dm command to set the address(es) that you would like to monitor. \n\nChain IDs are listed here. \n\n\nFor example to be alerted when your Gelato Balance drops below 0.15 ETH on mainnet you would enter 1 0.15\n/list-threshold-dm\nList all custom and default balance thresholds of each network\n/stop-balance-dm\nSwitch off all low balance alerts\n/simulation-fail-dmtask_id\nNotifies you when your task with the specified task_id is due to be executed but when Gelato simulates the transaction it determines that it will revert when executed on-chain. You will probably need to debug an issue with your target contract.\n/stop-simulation-fail-dm\nSwitch off all simulation failure notifications\n/exec-success-dm task_id\nNotifies each times your task executes a transaction. \n/stop-exec-success-dm\nSwitch of all execution success notifications\n/exec-revert-dm task_id\nAlerts you to any on-chain reverts when Gelato has executed a transaction for your task.\n/stop-exec-revert-dm\nSwitch of all revert notifications\nDiscord notifications in your own server\n1.\nAdd our Gelato Bot to your server using this invite link (you need to be admin of the server)\n2.\nIf you want to receive notifications in a private channel, make sure to add Gelato Bot as a member in the channel where you want to receive the notification.\n3.\nEnter the following commands in the channel you want to receive alerts.\nCommand\nUsage\n/balance-channeladdress\nAlerts when your Gelato Balance drops below the default threshold for the specified wallet address. The default thresholds are listed below. \n​\nTo provide multiple addresses enter a new command to the bot for each address.\n​\nIf you use the same wallet address across multiple networks, you will be alerted when any of these drop below the default thresholds.\n\nTo set your own threshold use the /balance-threshold-dm command.\n/balance-threshold-channel chain_id threshold\nAlerts you when your Gelato Balance drops below the threshold you set on a specific network.\n\nUse the /balance-dm command to set the address(es) that you would like to monitor. \n\nChain IDs are listed here. \n\n\nFor example to be alerted when your Gelato Balance drops below 0.15 ETH on mainnet you would enter 1 0.15\n/list-threshold-channel\nList all custom and default balance thresholds of each network\n/stop-balance-channel\nSwitch off all low balance alerts\n/simulation-fail-channeltask_id\nNotifies you when your task with the specified task_id is due to be executed but when Gelato simulates the transaction it determines that it will revert when executed on-chain. You will probably need to debug an issue with your target contract.\n/stop-simulation-fail-channel\nSwitch off all simulation failure notifications\n/exec-success-channel task_id\nNotifies each times your task executes a transaction. \n/stop-exec-success-channel\nSwitch of all execution success notifications\n/exec-revert-channel task_id\nAlerts you to any on-chain reverts when Gelato has executed a transaction for your task.\n/stop-exec-revert-channel\nSwitch of all revert notifications\nDefault Thresholds\nUnless overridden these are the default levels that are used for each network.\nNetwork\nChain ID\nDefault Threshold\nEthereum\n1\n0.05 ETH\nPolygon\n137\n20 MATIC\nFantom\n250\n20 FTM\nArbitrum\n42161\n0.05 ETH\nAvalanche\n43114\n0.5 AVAX\nBNB Chain\n56\n0.05 BNB\nGnosis Chain\n100\n5 XDAI\nOptimism\n10\n0.05 ETH\nIf you need more notifications or new communication channels, your feedback and suggestions are always welcome. \nPrevious\nPaying for your transactions\nNext\nMethods for submitting your task\nLast modified 2mo ago\nON THIS PAGE\nTypes of notifications\nSetting up Telegram Notifications\nTelegram Bot Commands\nDiscord DM Notifications\nDiscord notifications in your own server\nDefault Thresholds"
  },
  {
    "title": "Methods for submitting your task - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/methods-for-submitting-your-task",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGelato Automate UI\nGelato Automate SDK\nSmart Contract\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nMethods for submitting your task\nDeprecation Notice: Gelato Functions is set to replace Automate, providing enhanced automation capabilities, access to off-chain data, unified payments across networks, and a performance boost. Migrate your tasks to Gelato Functions before Legacy Automate's end of life on June 30th, 2024 for uninterrupted service.\nYou can submit your tasks via any of the following routes:\n1.\n​Gelato Automate UI​\n2.\n​Gelato Automate SDK​\n3.\n​Smart Contract​\nPrevious\nExecution & Balance Alerts\nNext\nGelato Automate UI\nLast modified 2mo ago"
  },
  {
    "title": "Paying for your transactions - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/paying-for-your-transactions",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nPaying for your transactions\nDeprecation Notice: Gelato Functions is set to replace Automate, providing enhanced automation capabilities, access to off-chain data, unified payments across networks, and a performance boost. Migrate your tasks to Gelato Functions before Legacy Automate's end of life on June 30th, 2024 for uninterrupted service.\nWhen Gelato executes your transaction it needs to pay the transaction fees. The fees can be paid in one of two ways:\n1.\nFrom Gelato Balance\n2.\nTransaction pays for itself\nGelato currently accepts payment in the native network token or its wrapped version for each network that Automate supports. For example, on Ethereum you can pay either in ETH or WETH and on Polygon either in MATiC or WMATIC - and so on for all the other networks we support. \nGelato Balance\nThis is the easiest option. You simply deposit some tokens into Gelato for each of the network(s) on which you want to execute transactions. Each time an execution occurs, Gelato will deduct the costs from your Gelato Balance to cover the gas costs. In the future we will introduce a small Gelato fee.  \nIf your Gelato Balance is too low to cover the costs of your transaction it will not execute until you top-up your balance. We provide a notification service for you to receive alerts when your balance is running low.\nDeposit funds via UI\nYou can deposit funds into your Gelato Balance on the fund's page.\nDeposit funds via smart contract\nIf your smart contract will be the one creating tasks, it would need its own Gelato balance to pay for the task executions. \nIf you would like to have your smart contract deposit funds at any point of time into it's Gelato balance, inherit AutomateTaskCreator like so. Learn more about \nAutomateTaskCreator functions\n \ncontract Counter is AutomateTaskCreator {\n    \n    constructor(address _automate, address _fundsOwner) AutomateTaskCreator(_automate, _fundsOwner) {}\n​\n    function depositForCounter() external payable {\n        _depositFunds(msg.value, ETH);\n    }\n}\n​\nAutomateTaskCreator exposes withdrawFunds function to allow fundsOwner to withdraw from the contract's Gelato balance.\nTransaction pays for itself\nYou can also choose not to pre-deposit funds into your Gelato balance and have your function pay the fee during executions.\nThis can be done by inheriting AutomateReady.\ncontract CounterWT is AutomateReady {\n    uint256 public count;\n    uint256 public lastExecuted;\n​\n    constructor(address _automate, address _taskCreator)\n        AutomateReady(_automate, _taskCreator)\n    {}\n​\n    receive() external payable {}\n​\n    function increaseCount(uint256 amount) external onlyDedicatedMsgSender {\n        count += amount;\n        lastExecuted = block.timestamp;\n​\n        (uint256 fee, address feeToken) = _getFeeDetails();\n​\n        _transfer(fee, feeToken);\n    }\n}\n​\nIn the increaseCount function, we use _transfer inherited from AutomateReady to pay Gelato.\n_transfer has two parameters, fee and feeToken which has to be queried from the Automate contract by using getFeeDetails()\nPrevious\nSupported Networks\nNext\nExecution & Balance Alerts\nLast modified 1mo ago\nON THIS PAGE\nGelato Balance\nTransaction pays for itself"
  },
  {
    "title": "Supported Networks - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/vrf/supported-networks",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\n📙\nUnderstanding VRF\n❔\nHow does Gelato VRF Work?\n🔓\nSecurity Considerations\n📄\nTemplate\n🚀\nQuick Start\n💡\nMigrating from Chainlink VRF\n💰\nPricing & Rate Limits\n✅\nSupported Networks\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n✅\nSupported Networks\nPlease note that our support for the Goerli, Optimism Goerli, and Arbitrum Goerli test networks will be discontinued after December 31, 2023. We recommend users to transition their operations to Sepolia, Optimism Sepolia, or Arbitrum Sepolia to ensure uninterrupted service and support.\nThe following networks are supported:\nName\nDeployment\nEthereum\nMainnet\nGoerli\nSepolia\nPolygon\nMainnet\nMumbai\nFantom\nMainnet\nAvalanche\nMainnet\nBinance Smart Chain\nMainnet\nOptimism\nMainnet\nGoerli\nArbitrum\nMainnet\nGoerli\nGnosis\nMainnet\nTestnet\nZkSync\nMainnet\nGoerli\nPolygonzk\nMainnet\nBase\nMainnet\nGoerli\nLinea\nMainnet\nAstar\nzKatana\nIf you don't see a network that you'd like supported, feel free to reach out to us.\nPrevious\nPricing & Rate Limits\nNext - Services\nAutomate (Legacy)\nLast modified 1mo ago"
  },
  {
    "title": "Pricing & Rate Limits - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/vrf/pricing-and-rate-limits",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\n📙\nUnderstanding VRF\n❔\nHow does Gelato VRF Work?\n🔓\nSecurity Considerations\n📄\nTemplate\n🚀\nQuick Start\n💡\nMigrating from Chainlink VRF\n💰\nPricing & Rate Limits\n✅\nSupported Networks\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n💰\nPricing & Rate Limits\nOverview\nIn order for the network to be sustainable & decentralized, Gelato Nodes charge fees for running off-chain computation and executing transactions.\nOur default method is to pay for all your Web3 Function costs across all networks from a single balance using  Gelato 1Balance. \nTransaction Charges\nEach transaction that Gelato Nodes execute require a small fee to incentivize Nodes to adhere to the protocol and get your transactions included into your desired blockchain in a fast and secure fashion. \nTo achieve this, Nodes charge a fee as a percentage of total gas cost for the executed transaction. This varies across networks - Nodes charge higher premiums on cheaper networks and vice versa.\nNetwork\nPercentage Premium (%)\nEthereum\n20\nPolygon\n70\nBNB\n30\nAvalanche\n40\nFantom\n50\nArbitrum\n50\nOptimism\n50\nZkSync Era\n50\nGnosis\n100\nLinea\n50\nBase\n50\nPolygon zkEvm\n50\nTable 1 - Fee premiums as a percentage of total gas cost per network. Testnet transactions are subsidized by Gelato.\nThese transaction premiums can be customised for users. Please reach out to us here to discuss your needs.\nRequest Limits\nVRF requests are using Gelato Web3 functions under the hood, which subsidize the first 10.000 requests per months. If you target an higher number of requests, please check Web3 functions subscriptions plans to upgrade to an higher tier.\nPrevious\nMigrating from Chainlink VRF\nNext\nSupported Networks\nLast modified 1mo ago\nON THIS PAGE\nOverview\nTransaction Charges\nRequest Limits"
  },
  {
    "title": "Migrating from Chainlink VRF - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/vrf/migrating-from-chainlink-vrf",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\n📙\nUnderstanding VRF\n❔\nHow does Gelato VRF Work?\n🔓\nSecurity Considerations\n📄\nTemplate\n🚀\nQuick Start\n💡\nMigrating from Chainlink VRF\n💰\nPricing & Rate Limits\n✅\nSupported Networks\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n💡\nMigrating from Chainlink VRF\nAlready using Chainlink VRF? Here's how you can quickly and easily migrate to GelatoVRF.\n1. Understand the Implications\nWhile this migration option is available, be aware that it can lead to higher gas costs and added development intricacies. We advise this route only if:\nYou've already deployed a Chainlink VRF Consumer.\nYour Chainlink VRF Consumer has the capability to update its Coordinator address.\nOtherwise, for new integrations, we recommend directly implementing the Gelato VRF.\nInitiate Migration\nIf you're set on migrating an existing Chainlink VRF Consumer:\nBegin by creating your VRF task. In the \"VRF Type\" selection window, opt for \"VRF Compatibility\".\nChoose the blockchain network for deployment.\nYou will then be asked to deploy your Adapter contract:\nOnce deployed, the app will show you the address to which the adapter contract was deployed. You now need to replace the old Coordinator address in your contract by this address.\nFinally, select the Request Contract Gelato nodes should respond to.\nPrevious\nDeploying your VRF Instance\nNext\nPricing & Rate Limits\nLast modified 1mo ago\nON THIS PAGE\n1. Understand the Implications\nInitiate Migration"
  },
  {
    "title": "Quick Start - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/vrf/quick-start",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\n📙\nUnderstanding VRF\n❔\nHow does Gelato VRF Work?\n🔓\nSecurity Considerations\n📄\nTemplate\n🚀\nQuick Start\n🚢\nDeploying your VRF Instance\n💡\nMigrating from Chainlink VRF\n💰\nPricing & Rate Limits\n✅\nSupported Networks\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🚀\nQuick Start\nIn order to get your VRF up and running you will need to first make your contract VRF Compatible.\nStep 1: Set Up Your Development Environment\nEnsure you have either Foundry or Hardhat set up in your development environment.\nStep 2: Install the Gelato VRF Contracts\nDepending on your environment, use the following commands to import the Gelato VRF contracts:\nFor Hardhat users:  \nClone the repo here​\nInstall dependencies yarn install\nFill in .env with variables in .env.example\nFor Foundry users: forge install gelatodigital/vrf-contracts --no-commit\nStep 3: Inherit GelatoVRFConsumerBase Contract\nThe recommended approach to integrate Gelato VRF is by inheriting from the GelatoVRFConsumerBase smart contract. Here's a simple example to help you set it up:\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n​\nimport {GelatoVRFConsumerBase} from \"./GelatoVRFConsumerBase.sol\";\n​\ncontract YourContract is GelatoVRFConsumerBase {\n    // Your contract's code goes here\n}\nUnderstanding 1Balance\nBefore we dive into requesting randomness, it's crucial to understand the role of 1Balance in using Gelato VRF. The Gelato VRF services necessitate that your Gelato balance is sufficiently funded. This balance caters to Gas fees and rewards Gelato Nodes for their computational tasks. For details about costs and funding your account, do visit our 1balance documentation.\nNote: It's important to remember that the current 1Balance system does not support withdrawals after depositing funds. Ensure to deposit only the amount you plan to utilize for Gelato VRF operations.\nStep 4:  Request Randomness\nTo request randomness, call the _requestRandomness() function. You should protect the call since it will take from your 1Balance. The data argument will be passed back to you by the W3F.\n    function requestRandomness(bytes memory data) external {\n        require(msg.sender == ...);\n        uint64 requestId = _requestRandomness(data);\n    }\nStep 5:  Implement the Callback function\nFinally, implement the callback function.\n    function _fulfillRandomness(\n        bytes32 randomness,\n        uint64 requestId,\n        bytes memory data,\n    ) internal override {\n    }\n}\nStep 6: Pass dedicated msg.sender\nWhen you're ready to deploy your Gelato VRF-compatible contract, an important step is to include the dedicated msg.sender as a constructor parameter. This ensures that your contract is set up to work with the correct operator for fulfilling the randomness requests.. It's crucial for ensuring that only authorized requests are processed.\nBefore deploying, visit the Gelato VRF UI. There, you will find the specific dedicated msg.sender address assigned for your deployer address. This address is crucial for the security and proper functioning of your VRF requests. Learn more about it at \nDedicated msg.sender\n​\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n​\nimport {GelatoVRFConsumerBase} from \"./GelatoVRFConsumerBase.sol\";\n​\ncontract YourContract is GelatoVRFConsumerBase {\n    constructor(address operator)\n        GelatoVRFConsumerBase(operator) {\n        // Additional initializations\n    }\n​\n    // The rest of your contract code\n}\nand once you have your contract ready & deployed, grab the address and Deploy your VRF instance.\nPrevious\nTemplate\nNext\nDeploying your VRF Instance\nLast modified 1mo ago\nON THIS PAGE\nStep 1: Set Up Your Development Environment\nStep 2: Install the Gelato VRF Contracts\nStep 3: Inherit GelatoVRFConsumerBase Contract\nStep 4: Request Randomness\nStep 5: Implement the Callback function\nStep 6: Pass dedicated msg.sender"
  },
  {
    "title": "Template - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/vrf/template",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\n📙\nUnderstanding VRF\n❔\nHow does Gelato VRF Work?\n🔓\nSecurity Considerations\n📄\nTemplate\n🚀\nQuick Start\n💡\nMigrating from Chainlink VRF\n💰\nPricing & Rate Limits\n✅\nSupported Networks\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n📄\nTemplate\nHardhat Template\nGitHub - gelatodigital/vrf-nft-hardhat\nGitHub\nFoundry Template\nhttps://github.com/gelatodigital/vrf-nft\ngithub.com\n​\nPrevious\nSecurity Considerations\nNext\nQuick Start\nLast modified 1mo ago\nON THIS PAGE\nHardhat Template\nFoundry Template"
  },
  {
    "title": "Security Considerations - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/vrf/security-considerations",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\n📙\nUnderstanding VRF\n❔\nHow does Gelato VRF Work?\n🔓\nSecurity Considerations\n📄\nTemplate\n🚀\nQuick Start\n💡\nMigrating from Chainlink VRF\n💰\nPricing & Rate Limits\n✅\nSupported Networks\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🔓\nSecurity Considerations\nAfter reading this page you will:\nUnderstand the importance of security measures when implementing Gelato VRF in your dApp.\nRecognize the need for state locking to prevent front-running and maintain the integrity of the randomization process.\nLearn the benefits of using RNGLib to ensure the randomness you receive is unique and secure, particularly when handling multiple requests simultaneously.\nImportant Note\nContrary to some other VRF providers, Gelato VRF is verifiable off-chain but not on-chain. This is due to the nature of the BLS signatures used by Drand network, which are not yet supported at EVM level. With the upcoming EIP-2537 release, adding BLS precompile for BLS12-381 curve, we aim to add support for on-chain randomness verification in a near future on all networks that will include this precompile.\nSecurity Precautions\nWhen integrating with GelatoVRF, it's essential to take several precautions to ensure the safety and reliability of your application. Here are key considerations:\n1. State Locking and Front-Running Prevention\nAfter you initiate a request for randomness and before the random number gets delivered, it's essential to lock the relevant application state in your consumer contract. This step minimizes the risk of front-running attacks.\nIn essence, front-running involves gaining an unfair advantage by making transactions based on foreknowledge of pending transactions. By locking the state, you add an additional layer of security against such tactics.\n2. Usage of RNGLib\nInstead of using the received randomness directly, consider integrating it with our RNGLib. This approach:\nEnables dynamic fetching of random values as required.\nOffers protection against certain bet arbitrage attacks, especially when multiple applications operate simultaneously.\nBy inheriting from GelatoVRFConsumerBase.sol, your contract will automatically benefit from enhanced security. All fulfilled randomness requests will be dynamically derived from the drand randomness using a pseudo-random number generator (RNG). This is crucial to ensure the uniqueness of values, particularly for concurrent requests, and adds another layer of protection against potential vulnerabilities.\nPrevious\nHow does Gelato VRF Work?\nNext\nTemplate\nLast modified 1mo ago\nON THIS PAGE\nSecurity Precautions\n1. State Locking and Front-Running Prevention\n2. Usage of RNGLib"
  },
  {
    "title": "How does Gelato VRF Work? - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/vrf/how-does-gelato-vrf-work",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\n📙\nUnderstanding VRF\n❔\nHow does Gelato VRF Work?\n🔓\nSecurity Considerations\n📄\nTemplate\n🚀\nQuick Start\n💡\nMigrating from Chainlink VRF\n💰\nPricing & Rate Limits\n✅\nSupported Networks\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n❔\nHow does Gelato VRF Work?\nGelato VRF (Verifiable Random Function) provides a unique system offering trustable randomness on EVM-compatible blockchains. But what's the magic behind this reliable randomness? Let's see!\nAfter reading this page:\nYou'll be able to understand the core components of Gelato VRF.\nYou'll understand how you can initiate a randomness request.\nYou'll be able to navigate the randomness delivery.\nYou'll understand how to integrate and utilize Gelato VRF.\nCore Component\nDrand: This is the heart of the randomness. Drand is a decentralized randomness beacon, ensuring the unpredictability and unbiased nature of the random numbers provided. To learn more about Drand and how it works, please refer to their documentation.\nTop level Flow\n +------------------------+\n | 1. Contract Deployment |\n +------------------------+\n          |\n          v\n +-----------------------+\n | 2. Requesting         |\n |    Randomness         |\n +-----------------------+\n          |\n          v\n +-----------------------+\n | 3. Processing the     |\n |     randomness        |\n |       event           |\n +-----------------------+\n          |\n          v\n +-----------------------+\n | 4. Randomness Delivery|\n +-----------------------+\n​\n1. Contract Deployment\nThe smart contract that developers need to interact with is located at GelatoVRFConsumerBase.sol​\nThis contract serves as an interface to the Gelato VRF system, allowing other smart contracts to request and receive random numbers.\n2. Requesting Randomness\nInside the GelatoVRFConsumer contract, there's an event named RequestedRandomness. When a randomness request is made, this event is emitted.\nThe RequestedRandomness event serves as a beacon, signaling the Gelato VRF system about the need for a random number. It contains 2 parameters:\n round explicitly signifies which Drand round is targeted to fulfill the randomness,\ndata offers versatility for developers, it can be used to attach any supplementary information or context about the randomness request.\nevent RequestedRandomness(uint256 round, bytes data);\n3. Processing the Randomness Request\nInternally, the system leverages Web3 functions to listen for the emitted RequestedRandomness event and to fetch the required random number from Drand.\n4. Delivering Randomness\nComposable Callback with Arbitary Data\nInternally, the system invokes the fulfillRandomness function in the requesting contract.\nCallback Invocation and Data Decoding\nThe random number (sourced from Drand) is passed as the randomness parameter to the function. Additionally, the data parameter can carry any supplementary data provided during the original request or by the Gelato VRF.\nPrevious\nUnderstanding VRF\nNext\nSecurity Considerations\nLast modified 1mo ago\nON THIS PAGE\nCore Component\nTop level Flow\n1. Contract Deployment\n2. Requesting Randomness\n3. Processing the Randomness Request\n4. Delivering Randomness"
  },
  {
    "title": "Understanding VRF - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/vrf/understanding-vrf",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\n📙\nUnderstanding VRF\n❔\nHow does Gelato VRF Work?\n🔓\nSecurity Considerations\n📄\nTemplate\n🚀\nQuick Start\n💡\nMigrating from Chainlink VRF\n💰\nPricing & Rate Limits\n✅\nSupported Networks\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n📙\nUnderstanding VRF\nGrasping the essence of Gelato VRF and its pivotal role in blockchain randomness.\nAfter reading this page:\nYou'll grasp the importance and challenges of generating randomness on the blockchain.\nYou'll learn how Gelato VRF works and why it's trustworthy.\nWhat is Verifiable Random Function (VRF)\nA VRF or Verifiable Random Function is a unique blend of cryptographic techniques that generates pseudorandom numbers in a publicly verifiable manner. Think of VRF as a way to generate random numbers where:\nThe entity possessing a secret key can compute the random number and also provide a proof of its correctness.\nAnyone with the public key can verify that the random number was indeed computed correctly, ensuring the integrity of the result.\nIn simple terms, VRFs are like cryptographic hash functions but with an added layer of public verification. They're an essential tool in systems where the trustworthiness of random outputs is highly important.\nGelato VRF and Trustworthy Randomness\nGelato VRF offers real randomness for blockchain applications by leveraging Drand, a trusted decentralized source for random numbers. With Gelato VRF, developers get random values that are both genuine and can be checked for authenticity.\nApplications of Gelato VRF:\nThe potential applications of a reliable and transparent random number generator on the blockchain are vast. Here are just a few use cases:\nGaming and Gambling: Determine fair outcomes for online games or decentralized gambling applications.\nDecentralized Finance (DeFi): Use in protocols where random selections, like lottery systems, are required.\nNFT Generation: Randomly generate traits or characteristics for unique digital assets.\nProtocol Decision Making: In protocols where decisions need to be randomized, such as selecting validators or jurors.\nServices - Previous\nVRF\nNext\nHow does Gelato VRF Work?\nLast modified 1mo ago\nON THIS PAGE\nWhat is Verifiable Random Function (VRF)\nGelato VRF and Trustworthy Randomness\nApplications of Gelato VRF:"
  },
  {
    "title": "Using the Automate SDK - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/understanding-web3-functions/create-a-web3-function-task/using-the-automate-sdk",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n1⃣\nTrigger Types\n2⃣\nTypescript Function\n3⃣\nSolidity Function\n4⃣\nAutomated Transactions\n5⃣\nCreate a Web3 Function Task\n⏩\nUsing the UI\n⏩\nUsing a Smart Contract\n⏩\nUsing the Automate SDK\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n⏩\nUsing the Automate SDK\nUsing Automate SDK\nThe SDK is suitable when you need to integrate task creation into your development environment or automated scripts. It's also useful for complex setups that require conditional logic before task submission.\nUse the automate-sdk to easily create a new task:\nyarn install @gelatonetwork/automate-sdk\nTypescript Functions are still in private beta, make sure to use the beta version of the automate-sdk to have access to it\nTypescript Function\nImport the sdk and create task, passing your typescript function CID & arguments:\nimport { AutomateSDK, Web3Function } from \"@gelatonetwork/automate-sdk\";\n​\nconst automate = new AutomateSDK(chainId, deployer);\n​\nconst { taskId, tx } = await automate.createBatchExecTask({\n  name: \"Web3Function - Eth Oracle\",\n  web3FunctionHash: cid,\n  web3FunctionArgs: {\n    oracle: oracle.address,\n    currency: \"ethereum\",\n  },\n  trigger: {\n    // Run every minutes\n    type: TriggerType.TIME,\n    interval: 60 * 1000,\n  },\n});\nawait tx.wait();\nYou can specify cron trigger this way:\ntrigger: {\n  type: TriggerType.CRON,\n  cron: \"0 8 * * *\", // Run every day at 8:00\n}\nevent trigger like this:\ntrigger: {\n  type: TriggerType.EVENT,\n  filter: {\n    // Listen to PriceUpdated event on Oracle contract\n    address: oracle.address,\n    topics: [[oracle.getEventTopic(\"PriceUpdated\")]],\n  },\n  blockConfirmations: 0, // Trigger immediately\n},\nAnd block trigger this way:\ntrigger: {\n  type: TriggerType.BLOCK,\n}\nIf your task utilizes secrets, you can set them after the task has been created.\nconst web3Function = new Web3Function(chainId, deployer);\n​\nconst secrets = {\n  API_KEY: \"...\" // Set your secret environment variables\n}\nawait web3Function.secrets.set(secrts, taskId);\nSolidity Function\nRepeat the installation step as shown above, then import and instantiate the SDK:\nconst automate = new AutomateSDK(chainId, signer);\nUse createTask to automate your function calls:\ninterface CreateTaskOptions {\n  name: string;             // your task name\n​\n  // Function to execute\n  execAddress: string;      // address of your target smart contract\n  execSelector: string;     // function selector to execute on your target smart contract\n  execAbi?: string;         // ABI of your target smart contract\n​\n  // Proxy caller\n  dedicatedMsgSender: boolean;  // task will be called via a dedicated msg.sender which you can whitelist (recommended: true)\n​\n  // Optional: Pre-defined / static target smart contract inputs\n  execData?: string;        // exec call data \n  \n  // Optional: Dynamic target smart contract inputs (using a resolver)\n  resolverAddress?: string; // resolver contract address\n  resolverData?: string;    // resolver call data (encoded data with function selector)\n  resolverAbi?: string;     // your resolver contract ABI\n​\n  // Optional: Time based task params\n  interval?: number;        // execution interval in seconds\n  startTime?: number;       // start timestamp in seconds or 0 to start immediately (default: 0)\n  \n  // Optional: Single execution task\n  singleExec?: boolean;     // task cancels itself after 1 execution if true.\n  \n  // Optional: Payment params\n  useTreasury?: boolean;    // use false if your task is self-paying (default: true)\n}\n​\nconst params: CreateTaskOptions = {\n  name,\n  execAddress,\n  execSelector,\n  interval\n};\n​\nconst { taskId, tx }: TaskTransaction = await automate.createTask(params);\nExamples\nDeploy a contract & automate your function call:\n// Deploying Counter contract\nconst counterFactory = await hre.ethers.getContractFactory(\"Counter\");\nconst counter = await counterFactory.deploy(GELATO_ADDRESSES[chainId].automate);\nawait counter.deployed();\n​\n// Call Counter.increaseCount(42) every 10 minutes\nconst  { taskId, tx }: TaskTransaction = await automate.createTask({\n  execAddress: counter.address,\n  execSelector: counter.interface.getSighash(\"increaseCount(uint256)\"),\n  execData: counter.interface.encodeFunctionData(\"increaseCount\", [42]),\n  execAbi: counter.interface.format(\"json\") as string,\n  interval: 10 * 60, // execute every 10 minutes\n  name: \"Automated counter every 10min\",\n  dedicatedMsgSender: true\n});​\nUse a Checker to automate your function call:\nIf you need more configurable execution condition and/or dynamic input data, you can create a task using Checker \n// Prepare Task data to automate\nconst counter = new Contract(COUNTER_ADDRESSES, counterAbi, signer);\nconst resolver = new Contract(COUNTER_RESOLVER_ADDRESSES, counterResolverAbi, signer);\nconst selector = counter.interface.getSighash(\"increaseCount(uint256)\");\nconst resolverData = resolver.interface.getSighash(\"checker()\");\n​\n// Create task\nconst { taskId, tx }: TaskTransaction = await automate.createTask({\n  execAddress: counter.address,\n  execSelector: selector,\n  resolverAddress: resolver.address,\n  resolverData: resolverData,\n  name: \"Automated counter using resolver\",\n  dedicatedMsgSender: true\n});\nAutomated Transaction\nThe CreateTaskOptions interface is used for configuring Automated Transactions with the same structure and options as defined above.\nThe only difference is you need to configure your automated transaction without the need for a checker function.\nExample:\ninterface CreateTaskOptions {\n  name: string; // Name your task\n  execAddress: string; // Address of your target smart contract\n  execSelector: string; // Function selector to call on your target smart contract\n  execAbi?: string; // ABI of your target smart contract (optional)\n  execData?: string; // Call data for the function execution (optional)\n}\nSingle Execution Task\nIf you want to have Gelato call your function only once. If so, set singleExec flag to true  when calling createTask.  \nconst { taskId, tx }: TaskTransaction = await automate.createTask({\n  execAddress: counter.address,\n  execSelector: selector,\n  resolverAddress: counter.address,\n  resolverData: resolverData,\n  dedicatedMsgSender: true,\n  name: \"Automated counter using resolver\",\n  dedicatedMsgSender: true,\n  singleExec: true\n});\nPrevious\nUsing a Smart Contract\nNext\nSecurity Considerations\nLast modified 1mo ago\nON THIS PAGE\nUsing Automate SDK\nTypescript Function\nSolidity Function\nAutomated Transaction\nSingle Execution Task"
  },
  {
    "title": "Initiate an Automated Transaction - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/quick-start/initiate-an-automated-transaction",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n➡\nWriting Typescript Functions\n➡\nTest, Deploy & Run Typescript functions\n➡\nWriting Solidity Functions\n➡\nTest, Deploy & Run Solidity Functions\n➡\nInitiate an Automated Transaction\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n➡\nInitiate an Automated Transaction\nAn execution attempt in Gelato allows you to pre-define the inputs for a function. By doing so, every time Gelato calls the function, it uses the same arguments, ensuring consistent behavior in your automated tasks.\n1. Prepare Your Smart Contract for Automation\nIdentify Your Smart Contract: Ensure you have the correct smart contract address and know the specific function you want to automate.\nFunction Restrictions: Some functions may not be compatible with Gelato due to certain restrictions. Familiarize yourself with these to ensure seamless automation.\n2. Set Your Trigger Condition\nChoosing Your Trigger: Gelato allows you to set specific conditions to determine when your function is called. This could be at regular intervals (time interval) or based on specific events (cron expression).\nNo Custom Code Required: For initiating tranaction tasks, there's no need for you to write code. Simply set your desired trigger and move forward.\nFinally, Click on \"Create Task\" button! Its just that simple!\n​\nPrevious\nTest, Deploy & Run Solidity Functions\nNext\nAnalytics & Monitoring\nLast modified 2mo ago\nON THIS PAGE\n1. Prepare Your Smart Contract for Automation\n2. Set Your Trigger Condition"
  },
  {
    "title": "Test, Deploy & Run Solidity Functions - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/quick-start/test-deploy-and-run-solidity-functions",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n➡\nWriting Typescript Functions\n➡\nTest, Deploy & Run Typescript functions\n➡\nWriting Solidity Functions\n➡\nTest, Deploy & Run Solidity Functions\n➡\nInitiate an Automated Transaction\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n➡\nTest, Deploy & Run Solidity Functions\nTesting Solidity Functions\nThe purpose of this repo is to showcase unit tests examples of using Gelato Solidity Functions in a Hardhat environment.\nGitHub - gelatodigital/automate-unit-testing: The purpose of this repo is to showcase unit tests examples of using Gelato Automate in a Hardhat enviroment.\nGitHub\nIt's advised to conduct tests by impersonating Gelato's address within a Hardhat environment to ensure accurate simulation of Gelato Solidity Function executions.\nDeploying Solidity Functions\nTo deploy your Solidity functions, please proceed with deploying your contract to the network. Once deployed, ensure you verify your contract on Etherscan to enable automatic ABI fetching within our app.\nCheck out an example script here to see how you can deploy your Solidity Functions.\nCreating Solidity Function Tasks\nBefore creating solidity function tasks, familiarize yourself with the available \nTrigger Types\n!\n1.\nSelection of Function\nNavigate to the What to trigger section.\nChoose the Solidity Function option\n2.\nNetwork Configuration\nLocate the Network dropdown.\nSelect your desired blockchain network where the contract is deployed, e.g., \"Göerli.\"\n3.\nFunction Details Input\nUnder the Solidity Function section, find the input labeled Contract Address.\nEnter the Ethereum address of your deployed Solidity contract. Ensure accuracy as this determines where your functions will interact.\nOnce the contract address is entered, the ABI (Application Binary Interface) should automatically populate. If using a custom ABI, select the Custom ABI option and input it accordingly.\n4.\nTask Configuration\nA checker function evaluates conditions before triggering the main function. From the Checker Function dropdown, choose the specific function you want as a condition checker.\nEnter the Target Contract where the automated function call should be sent. From the subsequent dropdown, select the specific function you wish to automate.\nPrevious\nWriting Solidity Functions\nNext\nInitiate an Automated Transaction\nLast modified 2mo ago\nON THIS PAGE\nTesting Solidity Functions\nDeploying Solidity Functions\nCreating Solidity Function Tasks"
  },
  {
    "title": "Test, Deploy & Run Typescript functions - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/quick-start/test-deploy-and-run-typescript-functions",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n➡\nWriting Typescript Functions\n➡\nTest, Deploy & Run Typescript functions\n➡\nWriting Solidity Functions\n➡\nTest, Deploy & Run Solidity Functions\n➡\nInitiate an Automated Transaction\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n➡\nTest, Deploy & Run Typescript functions\nTesting Typescript Functions\nTo test your Typescript Function locally, run:\nnpx hardhat w3f-run W3FNAME\nExample:\nnpx hardhat w3f-run oracle\nOptional flags:\n--logs Show internal Web3 Function logs\n--debug Show Runtime debug messages\n--network [NETWORK] Set the default runtime network & provider.\nExample:\nnpx hardhat w3f-run oracle --logs --network hardhat\nOutput:\nWeb3Function Build result:\n ✓ Schema: /Users/chuahsonglin/Documents/GitHub/Gelato/contract/w3f-template/web3-functions/oracle/schema.json\n ✓ Built file: /Users/chuahsonglin/Documents/GitHub/Gelato/contract/w3f-template/.tmp/index.js\n ✓ File size: 2.47mb\n ✓ Build time: 947.91ms\n​\nWeb3Function user args validation:\n ✓ currency: ethereum\n ✓ oracle: 0x71B9B0F6C999CBbB0FeF9c92B80D54e4973214da\n​\nWeb3Function running logs:\n> Last oracle update: 0\n> Next oracle update: 3600\n> Updating price: 1898\n​\nWeb3Function Result:\n ✓ Return value: {\n  canExec: true,\n  callData: [\n    {\n      to: '0x71B9B0F6C999CBbB0FeF9c92B80D54e4973214da',\n      data: '0x8d6cc56d000000000000000000000000000000000000000000000000000000000000076a'\n    }\n  ]\n}\n​\nWeb3Function Runtime stats:\n ✓ Duration: 1.35s\n ✓ Memory: 113.55mb\n ✓ Storage: 0.03kb\n ✓ Rpc calls: 3\nDeploying Typescript Functions\nTo compile your Typescript Function and deploy it to IFPS, use\nnpx hardhat w3f-deploy W3FNAME\nExample:\nnpx hardhat w3f-deploy oracle \nOnce uploaded, Gelato Nodes will pin the file on your behalf on IPFS. If the upload was successful, you should get the IPFS CID of your Typescript Function returned. \n ✓ Web3Function deployed to ipfs.\n ✓ CID: QmbQJC5XGpQUsAkLq6BqpvLtD8EPNDEaPqyFf4xK3TM6xj\nNote: This CID will be different for every new Typescript Function version that you will deploy.\nCreating Typescript Function Task\nBefore creating solidity function tasks, familiarize yourself with the available \nTrigger Types\n!\n1.\nSelection of Function\nNavigate to the What to trigger section.\nWithin the Typescript Function subsection, find the IPFS CID input box.\n2.\nFunction Details Input\nInput the CID you secured after deploying your Typescript function. Upon entry, you should see a message like \"Typescript Function code imported,\" signifying a successful connection.\n3.\nNetwork Configuration\nScroll to the Network dropdown menu.\nChoose the blockchain network where the Typescript function should work, e.g., \"Göerli.\"\n4.\nTask Configuration\nIf your Typescript function needs secret variables or API keys, securely enter them in the Task Secrets section. For every secret:\nKey: Define the name of the variable or key, e.g., \"API_KEY\".\nValue: Enter the associated secret value.\nClick Save after each input to guarantee its safe storage.\n\n\n\n​\nPrevious\nPrivate Typescript Functions\nNext\nWriting Solidity Functions\nLast modified 2mo ago\nON THIS PAGE\nTesting Typescript Functions\nOptional flags:\nDeploying Typescript Functions\nCreating Typescript Function Task"
  },
  {
    "title": "Writing Solidity Functions - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/quick-start/writing-solidity-functions",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n➡\nWriting Typescript Functions\n➡\nTest, Deploy & Run Typescript functions\n➡\nWriting Solidity Functions\n➡\nTest, Deploy & Run Solidity Functions\n➡\nInitiate an Automated Transaction\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n➡\nWriting Solidity Functions\n1. Understand the Role of a Checker\nA Checker acts as a bridge between conditions and smart contract executions. Its purpose? To check conditions and determine whether a task should be executed by Gelato. Every Checker returns two main things:\ncanExec (Boolean): Indicates if Gelato should execute the task.\nexecData (Bytes): Contains the data that executors will use during execution.\nSolidity functions must adhere to the block gas limit for checker calls; exceeding it will cause the call to fail.\n2. Solidity Function Example\nBefore we delve into complexities, let's understand the structure of a simple Checker:\ncontract CounterChecker{\n    ICounter public immutable counter;\n​\n    constructor(ICounter _counter) {\n        counter = _counter;\n    }\n​\n    function checker()\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        uint256 lastExecuted = counter.lastExecuted();\n​\n        canExec = (block.timestamp - lastExecuted) > 180;\n​\n        execPayload = abi.encodeCall(ICounter.increaseCount, (1));\n    }\n}\nIn the above, the checker checks the state of a counter and prompts Gelato to execute if 3 minutes (180 seconds) have elapsed since its last execution.\n3. Making your Checker Reusable\nAvoid hardcoding addresses. Instead, allow the passing of arguments to your checker. This lets you reuse the checker for multiple tasks:\nfunction checker(address _counter)\n    external\n    view\n    returns (bool canExec, bytes memory execPayload)\n{\n    uint256 lastExecuted = ICounter(_counter).lastExecuted();\n​\n    canExec = (block.timestamp - lastExecuted) > 180;\n​\n    execPayload = abi.encodeCall(ICounter.increaseCount, (1));\n}\n4. Advanced: Checking Multiple Functions\nSuppose you're automating tasks across different pools. Instead of creating multiple tasks, iterate through your list of pools within a single checker:\nfunction checker()\n    external\n    view\n    returns (bool canExec, bytes memory execPayload)\n{\n    uint256 delay = harvester.delay();\n​\n    for (uint256 i = 0; i < vaults.length(); i++) {\n        IVault vault = IVault(getVault(i));\n​\n        canExec = block.timestamp >= vault.lastDistribution().add(delay);\n​\n        execPayload = abi.encodeWithSelector(\n            IHarvester.harvestVault.selector,\n            address(vault)\n        );\n​\n        if (canExec) return(true, execPayload);\n    }\n​\n    return(false, bytes(\"No vaults to harvest\"));\n}\n5. Incorporating Feedback with Logs\nWith the Gelato Web3 Functions UI, you can use custom return messages to pinpoint where your checker might be \"stuck\":\nfunction checker()\n    external\n    view\n    returns (bool canExec, bytes memory execPayload)\n{\n    uint256 lastExecuted = counter.lastExecuted();\n​\n    if(block.timestamp - lastExecuted < 180) return(false, bytes(\"Time not elapsed\"));\n​\n    execPayload = abi.encodeCall(ICounter.increaseCount, (1));\n    return(true, execPayload);\n}\n6. Limit the Gas Price of your execution\nOn networks such as Ethereum, gas will get expensive at certain times. If what you are automating is not time-sensitive and don't mind having your transaction mined at a later point, you can limit the gas price used in your execution in your checker.\nfunction checker()\n\texternal\n\tview\n\treturns (bool canExec, bytes memory execPayload)\n{\n\t// condition here\n\t\n\tif(tx.gasprice > 80 gwei) return (false, bytes(\"Gas price too high\"));\n}\n​\nThis way, Gelato will not execute your transaction if the gas price is higher than 80 GWEI. \nPrevious\nTest, Deploy & Run Typescript functions\nNext\nTest, Deploy & Run Solidity Functions\nLast modified 2mo ago\nON THIS PAGE\n1. Understand the Role of a Checker\n2. Solidity Function Example\n3. Making your Checker Reusable\n4. Advanced: Checking Multiple Functions\n5. Incorporating Feedback with Logs\n6. Limit the Gas Price of your execution"
  },
  {
    "title": "Writing Typescript Functions - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/quick-start/writing-typescript-functions",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n➡\nWriting Typescript Functions\n⏩\nEvent Trigger\n⏩\nPrivate Typescript Functions\n➡\nTest, Deploy & Run Typescript functions\n➡\nWriting Solidity Functions\n➡\nTest, Deploy & Run Solidity Functions\n➡\nInitiate an Automated Transaction\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n➡\nWriting Typescript Functions\n1) Clone the Web3 Function Hardhat Template\ngit clone https://github.com/gelatodigital/web3-functions-hardhat-template.git\ncd web3-functions-hardhat-template\nor use the template on Github's UI. \n2) Install dependencies \nyarn install\n3) Copy the example .env file\ncp .env.example .env\n4) Fill in your Alchemy & private key for local testing\nNote: PRIVATE_KEY is optional, and only needed if you wish to deploy contracts or create a task from the CLI instead of the UI \nALCHEMY_ID= // <= Your Alchemy key\nPRIVATE_KEY= // <= Your Private key\nTypescript Function Example\nThis typescript function updates an oracle smart contract with data returned by Coingecko's price API at an interval. Check out more examples here.\nimport { Web3Function, Web3FunctionContext } from \"@gelatonetwork/web3-functions-sdk\";\nimport { Contract, ethers } from \"ethers\";\nimport ky from \"ky\"; // we recommend using ky as axios doesn't support fetch by default\n​\nconst ORACLE_ABI = [\n  \"function lastUpdated() external view returns(uint256)\",\n  \"function updatePrice(uint256)\",\n];\n​\nWeb3Function.onRun(async (context: Web3FunctionContext) => {\n  const { userArgs, gelatoArgs, multiChainProvider } = context;\n  const provider = multiChainProvider.default();\n​\n  // Retrieve Last oracle update time\n  const oracleAddress = \"0x71b9b0f6c999cbbb0fef9c92b80d54e4973214da\";\n  const oracle = new Contract(oracleAddress, ORACLE_ABI, provider);\n  const lastUpdated = parseInt(await oracle.lastUpdated());\n  console.log(`Last oracle update: ${lastUpdated}`);\n​\n  // Check if it's ready for a new update\n  const nextUpdateTime = lastUpdated + 300; // 5 min\n  const timestamp = (await provider.getBlock(\"latest\")).timestamp;\n  console.log(`Next oracle update: ${nextUpdateTime}`);\n  if (timestamp < nextUpdateTime) {\n    return { canExec: false, message: `Time not elapsed` };\n  }\n​\n  // Get current price on coingecko\n  const currency = \"ethereum\";\n  const priceData: any = await ky\n    .get(\n      `https://api.coingecko.com/api/v3/simple/price?ids=${currency}&vs_currencies=usd`,\n      { timeout: 5_000, retry: 0 }\n    )\n    .json();\n  price = Math.floor(priceData[currency].usd);\n  console.log(`Updating price: ${price}`);\n​\n  // Return execution call data\n  return {\n    canExec: true,\n    callData: [{\n      to: oracleAddress,\n      data: oracle.interface.encodeFunctionData(\"updatePrice\", [price])\n  }],\n  };\n});\nCreate your function schema.json to specify your runtime configuration. \n{\n  \"web3FunctionVersion\": \"2.0.0\",\n  \"runtime\": \"js-1.0\",\n  \"memory\": 128, \n  \"timeout\": 30,\n  \"userArgs\": {}\n}\nNote: For now the configuration is fixed and cannot be changed. \nTypescript Function Context\nWhen writing the Web3 Function, it is very helpful to understand the context Gelato injects into the execution, providing additional features to widen the Web3 Functions applicability.\nWeb3Function.onRun(async (context: Web3FunctionContext) => {\n  const { userArgs, storage, secrets, multiChainProvider, gelatoArgs} = context;\n  const provider = multiChainProvider.default();\n  ...\n}\nUser Arguments\n1.\nDeclare your expected userArgs in your schema, accepted types are string, string[], number, number[], boolean, boolean[]:\n{\n  \"web3FunctionVersion\": \"2.0.0\",\n  \"runtime\": \"js-1.0\",\n  \"memory\": 128, \n  \"timeout\": 30,\n  \"userArgs\": {\n    \"currency\": \"string\",\n    \"oracle\": \"string\"\n  }\n}\n2.\nAccess your userArgs from the Web3Function context:\nWeb3Function.onRun(async (context: Web3FunctionContext) => {\n  const { userArgs, gelatoArgs, secrets } = context;\n​\n  // User args:\n  console.log('Currency:', userArgs.currency)\n  console.log('Oracle:', userArgs.oracle)\n  ...\n});\n3.\nIn the same directory as your web3 function, create a file userArgs.json  and fill in your userArgs to test your web3 function:\n{\n  \"currency\": \"ethereum\",\n  \"oracle\": \"0x71B9B0F6C999CBbB0FeF9c92B80D54e4973214da\"\n}\nTest out the Coingecko oracle web3 function:\nnpx hardhat w3f-run oracle --logs\nState / Storage\nWeb3Functions are stateless scripts, that will run in a new & empty memory context on every execution. If you need to manage some state variable, we provide a simple key/value store that you can access from your web3 function context.\nSee the above example to read & update values from your storage:\nimport {\n  Web3Function,\n  Web3FunctionContext,\n} from \"@gelatonetwork/web3-functions-sdk\";\n​\nWeb3Function.onRun(async (context: Web3FunctionContext) => {\n  const { storage, multiChainProvider } = context;\n  const provider = multiChainProvider.default();\n​\n  // Use storage to retrieve previous state (stored values are always string)\n  const lastBlockStr = (await storage.get(\"lastBlockNumber\")) ?? \"0\";\n  const lastBlock = parseInt(lastBlockStr);\n  console.log(`Last block: ${lastBlock}`);\n​\n  const newBlock = await provider.getBlockNumber();\n  console.log(`New block: ${newBlock}`);\n  if (newBlock > lastBlock) {\n    // Update storage to persist your current state (values must be cast to string)\n    await storage.set(\"lastBlockNumber\", newBlock.toString());\n  }\n​\n  return {\n    canExec: false,\n    message: `Updated block number: ${newBlock.toString()}`,\n  };\n});\nTo populate the storage values in your testing, in the same directory as your web3 function, create a file storage.json and fill in the storage values.\n{\n  \"lastBlockNumber\": \"1000\"\n}\nTest out the storage web3 function:\nnpx hardhat w3f-run storage --logs\nSecrets\n1.\nIn the same directory as your web3 function, create a .env file and fill up your secrets.\nCOINGECKO_API=https://api.coingecko.com/api/v3\n2.\nAccess your secrets from the Web3Function context:\n  // Get api from secrets\n  const coingeckoApi = await context.secrets.get(\"COINGECKO_API\");\n  if (!coingeckoApi) {\n    return { canExec: false, message: `COINGECKO_API not set in secrets` };\n  }\n3.\nTest your web3 function using secrets:\nnpx hardhat w3f-run secrets --logs\n4.\nWhen deploying a task, you will be able to set your web3 function secrets on our UI or using the SDK, see here​\nimport hre from \"hardhat\";\nimport { AutomateSDK, Web3Function } from \"@gelatonetwork/automate-sdk\";\n​\nconst { ethers, w3f } = hre;\n​\nconst adBoardW3f = w3f.get(\"advertising-board\");\n​\nconst [deployer] = await ethers.getSigners();\nconst chainId = (await ethers.provider.getNetwork()).chainId;\n​\nconst automate = new AutomateSDK(chainId, deployer);\nconst web3Function = new Web3Function(chainId, deployer);\n​\n// Deploy Web3Function on IPFS\nconsole.log(\"Deploying Web3Function on IPFS...\");\nconst cid = await adBoardW3f.deploy();\nconsole.log(`Web3Function IPFS CID: ${cid}`);\n​\n// Create task using automate sdk\nconsole.log(\"Creating automate task...\");\n​\nconst { taskId, tx } = await automate.createBatchExecTask({\n  name: \"Web3Function - Ad Board\",\n  web3FunctionHash: cid,\n  web3FunctionArgs: {},\n});\n​\nawait tx.wait();\nconsole.log(`Task created, taskId: ${taskId} (tx hash: ${tx.hash})`);\nconsole.log(\n  `> https://beta.app.gelato.network/task/${taskId}?chainId=${chainId}`\n);\n​\n// Set task specific secrets\nconst secrets = adBoardW3f.getSecrets();\nif (Object.keys(secrets).length > 0) {\n  await web3Function.secrets.set(secrets, taskId);\n  console.log(`Secrets set`);\n}\nMultichain Provider\nThe multichainProvider allows us to instantiate RPC providers for every network Gelato is deployed on.\nimport {\n  Web3Function,\n  Web3FunctionContext,\n} from \"@gelatonetwork/web3-functions-sdk\";\n​\nWeb3Function.onRun(async (context: Web3FunctionContext) => {\n  const { multiChainProvider } = context;\n​\n  // multichainProvider.default() will instantiate\n  // the provider of the chain the W3F is deployed\n  const provider = multiChainProvider.default();\n​\n  // passing the chainId as follows, we can instantiate\n  // a rpc provider for that network\n  const polygonProvider = multiChainProvider.chainId(137)\n  ...\n}\nWhen testing locally, we can provide the different providers by including them in .env at the root folder.\n// .env file\nPROVIDER_URLS=RPC1,RPC2\nGelato Arguments\nGelato injects the chainId, the gasPrice, and the taskId into the context.\n1.\nchainId: The unique number identifying the blockchain network where the function is running.\n2.\ngasPrice: The cost of executing transactions on the blockchain.\n3.\ntaskId: A string that uniquely identifies the task.\nimport {\n  Web3Function,\n  Web3FunctionContext,\n} from \"@gelatonetwork/web3-functions-sdk\";\n​\nWeb3Function.onRun(async (context: Web3FunctionContext) => {\n  const { gelatoArgs } = context;\n​\n  // chainId: number\n  const chainId = gelatoArgs.chainId;\n​\n  // gasPrice: BigNumber\n  const gasPrice = gelatoArgs.gasPrice;\n  \n  // taskId: string\n  const taskId = gelatoArgs.taskId;\n  ...\n}\nPrevious\nQuick Start\nNext\nEvent Trigger\nLast modified 1mo ago\nON THIS PAGE\n1) Clone the Web3 Function Hardhat Template\n2) Install dependencies\n3) Copy the example .env file\n4) Fill in your Alchemy & private key for local testing\nTypescript Function Example\nTypescript Function Context\nUser Arguments\nState / Storage\nSecrets\nMultichain Provider\nGelato Arguments"
  },
  {
    "title": "Create a Web3 Function Task - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/understanding-web3-functions/create-a-web3-function-task",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n1⃣\nTrigger Types\n2⃣\nTypescript Function\n3⃣\nSolidity Function\n4⃣\nAutomated Transactions\n5⃣\nCreate a Web3 Function Task\n⏩\nUsing the UI\n⏩\nUsing a Smart Contract\n⏩\nUsing the Automate SDK\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n5⃣\nCreate a Web3 Function Task\nBefore creating a Web3 Function Task, make sure to Deploy a Web3 Function! Check out \nTest, Deploy & Run Typescript functions\n,\nTest, Deploy & Run Solidity Functions\n & \nInitiate an Automated Transaction\n \nOverview\nA Web3 Function Task links your Web3 Function to your target smart contract and enables you to configure what should trigger your Web3 Function to execute, any arguments you want to pass to it and the target smart contract to execute.\nWays to submit Web3 Function Tasks\n⏩\nUsing the UI\n⏩\nUsing a Smart Contract\n⏩\nUsing the Automate SDK\n​\nPrevious\nAutomated Transactions\nNext\nUsing the UI\nLast modified 2mo ago\nON THIS PAGE\nOverview\nWays to submit Web3 Function Tasks"
  },
  {
    "title": "Solidity Function - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/understanding-web3-functions/solidity-function",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n1⃣\nTrigger Types\n2⃣\nTypescript Function\n3⃣\nSolidity Function\n4⃣\nAutomated Transactions\n5⃣\nCreate a Web3 Function Task\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n3⃣\nSolidity Function\nWhat are Solidity Functions?\nSolidity functions are essentially a piece of logic written in Solidity that determines whether certain conditions are met to execute a task.\nSolidity Functions enable automation in conjunction with the various trigger types outlined on our \nTrigger Types\n page. \nEssential Role of Solidity Functions\nEnsure Precision: They ensure that functions are triggered only when the right conditions are met.\nBoost Efficiency: By automating repetitive and conditional tasks, they save time and resources.\nEnhance Flexibility: Developers can encode a variety of conditions, allowing for a wide range of automated functionalities.\nScenarios for Solidity Function Automation\n1.\nOn-Chain Logic is Required: Use them when the logic for your automation needs to reside entirely on the blockchain.\n2.\nFine tune gas price: Limit the gas price of the execution ensuring your automation doesn't overpay network fees. \n3.\nSecurity and Immutability are Key: Automated tasks that require the highest level of security benefit from Solidity's immutable contract execution environment.\nNext steps\nHead over to the quick start on how to write Solidity Functions: \nWriting Solidity Functions\n​\nPrevious\nTypescript Function\nNext\nAutomated Transactions\nLast modified 2mo ago\nON THIS PAGE\nWhat are Solidity Functions?\nEssential Role of Solidity Functions\nScenarios for Solidity Function Automation\nNext steps"
  },
  {
    "title": "Automated Transactions - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/understanding-web3-functions/automated-transactions",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n1⃣\nTrigger Types\n2⃣\nTypescript Function\n3⃣\nSolidity Function\n4⃣\nAutomated Transactions\n5⃣\nCreate a Web3 Function Task\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n4⃣\nAutomated Transactions\nWhat is an Automated Transaction?\nAutomated Transaction ensures that a specific function on the target smart contract gets reliably triggered. When you pre-define the inputs, it means that every time Gelato initiates the function call, it uses consistent, predetermined arguments.\nAutomation Transaction enable automation in conjunction with the various trigger types outlined on our \nTrigger Types\n page. \nEssential Roles for Automated Transactions\nConsistency: With set arguments, each function activation remains uniform.\nReliability: Minimize errors from inconsistent arguments, ensuring predictable function behavior.\nSimplicity: Avoid the complexities of decision-making or added input stages during execution.\nScenarios for Automated Transactions\n1.\nPeriodic Payments: Automate regular payments, like subscriptions or salaries, where the amount and recipient remain constant.\n2.\nMaintenance Operations: Execute routine smart contract operations, such as refreshing oracles or updating interest rates, where the action does not change.\n3.\nTrigger-Based Actions: For actions that must occur in response to a specific event, a transaction can be scheduled to execute when the event is observed.\n4.\nAutomated Token Transfers: Transfer tokens at specified intervals or when your contract’s logic deems it necessary, without additional input or variation.\nNext Steps\nHead over to the quick start on how to initiate an Automated Transaction: \nInitiate an Automated Transaction\n​\nPrevious\nSolidity Function\nNext\nCreate a Web3 Function Task\nLast modified 2mo ago\nON THIS PAGE\nWhat is an Automated Transaction?\nEssential Roles for Automated Transactions\nScenarios for Automated Transactions\nNext Steps"
  },
  {
    "title": "Trigger Types - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/understanding-web3-functions/trigger-types",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n1⃣\nTrigger Types\n2⃣\nTypescript Function\n3⃣\nSolidity Function\n4⃣\nAutomated Transactions\n5⃣\nCreate a Web3 Function Task\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n1⃣\nTrigger Types\n1. Time Interval\nUse this trigger to execute tasks at regular intervals, e.g., every 10 minutes or once every 24 hours. It's like setting a straightforward, recurring alarm.\n2. Cron Expressions\nThis offers a more refined control compared to the Time Interval. With cron expressions, you can set tasks to run at specific moments, such as \"every Tuesday at 3 PM\" or \"on the 1st of every month\". It gives you precision in task scheduling.\n3. On-Chain Event\nIdeal for those wanting their tasks to respond dynamically to blockchain activities. Whenever a specified event occurs on the blockchain, e.g. \n   //event creation with argument types and names\n   event ownerChanged(address indexed _from, address indexed _to);\nthis trigger springs your task into action. \n4. Every Block\nThis function operates with the rhythm of the blockchain itself, executing your chosen function each time a new block is created.\nNote: Irrespective of the trigger type you opt for, you can tie it to running any of the following:\nTypescript Function\nSolidity Function\nTransaction\nPrevious\nUnderstanding Web3 Functions\nNext\nTypescript Function\nLast modified 2mo ago"
  },
  {
    "title": "callWithSyncFee - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/non-erc-2771/callwithsyncfee",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n3⃣\nsponsoredCall\n2⃣\ncallWithSyncFee\n🍧\nRelay Context Contracts\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n2⃣\ncallWithSyncFee\nPermissionless transactions with on-chain payments\nAfter reading this page: \nYou'll know how to use the callWithSyncFee SDK method, using the syncFee payment method.\nYou'll see some code which will help you send a relay request within minutes.\nYou'll learn how to pay for transactions using the provided values for fee, feeToken and feeCollector.\nPlease proceed to our Security Considerations page and read it thoroughly before advancing with your implementation. It is crucial to understand all potential security risks and measures to mitigate them.\nOverview\nThe callWithSyncFee method uses the syncFee payment method. \nPaying for Transactions\nWhen using callWithSyncFee relay method the target contract assumes responsibility for transferring the fee to Gelato's fee collector during transaction execution. For this, the target contract needs to know:\nfee: the transfer amount\nfeeToken: the token to be transferred\nfeeCollector: the destination address for the fee\nFortunately, Gelato provides some useful tools within the Relay Context Contracts:\n1.\nBy inheriting the GelatoRelayContext  contract in your target contract, you have the ability to transfer the fee through one of two straightforward methods: _transferRelayFee() or _transferRelayFeeCapped(uint256 maxFee). In either case, the inherited contract takes care of decoding the fee, feeToken, and feeCollector behind the scenes.\nThe Gelato Relay backend simplifies the process by automatically calculating the fee for you, using Gelato's Fee Oracle to perform the calculations in the background.\n2.\nAlternatively, you may choose to inherit the GelatoRelayFeeCollector contract. With this approach, Gelato only decodes the feeCollector. You must provide the fee and feeToken on-chain, either by hardcoding them (which is not recommended) or embedding them within the payload to be executed. The suggested way to handle this is to calculate the fee with Gelato's Fee Oracle.\nSetting maxFee for Your Transaction\nSetting a maximum fee, or maxFee, for your transactions is strongly advised. This practice enables you to ensure that transaction costs remain below a specific limit. The method _transferRelayFeeCapped(uint256 maxFee) in the GelatoRelayContext contract provides a convenient way to set the maxFee easily.\nIf you are utilizing the GelatoRelayFeeCollector contract, the recommended way to pass the maxFee is by calculating the fee with Gelato's Fee Oracle, which is accessible in the relay-sdk. The getEstimatedFee() method is provided to facilitate this calculation.\nSDK method: callWithSyncFee\nconst callWithSyncFee = async (\n  request: CallWithSyncFeeRequest,\n  options?: RelayRequestOptions,\n  apiKey?: string\n): Promise<RelayResponse>\nArguments:\nrequest: this is the request body used to send a request.\noptions: RelayRequestOptions is an optional object.\napiKey: this is an optional API key that links your request to your Gelato Relay account. As this pertains to the syncFee payment method, transaction costs won't be deducted from your 1Balance account. By using the API key, you can benefit from increased rate limits of your Gelato Relay account.\nReturn Object: RelayResponse\ntype RelayResponse = {\n  taskId: string;\n};\ntaskId: your unique relay task ID which can be used for tracking your request.\nOptional Parameters \nSee Optional Parameters. \nSending a Request\nRequest Body\nconst request = {\n  chainId: BigNumberish;\n  target: string;\n  data: BytesLike;\n  isRelayContext?: boolean;\n  feeToken: string;\n};\nchainId: the chain ID of the chain where the target smart contract is deployed.\ntarget: the address of the target smart contract.\ndata: encoded payload data (usually a function selector plus the required arguments) used to call the required target address.\nisRelayContext: an optional boolean (default: true) denoting what data you would prefer appended to the end of the calldata.\nIf set to true (default), Gelato Relay will append the feeCollector address, the feeToken address, and the uint256 fee to the calldata. This requires the target contract to inherit the GelatoRelayContext contract.\nIf set to false, Gelato Relay will only append the feeCollector address to the calldata. In this case the contract to be inherit by the target contract is the GelatoRelayFeeCollector.\nfeeToken: the address of the token that is to be used for payment. Please visit SyncFee Payment Tokens for the full list of supported payment tokens per network.\nExample Code GelatoRelayContext\n1. Deploy a GelatoRelayContext compatible contract\n1\n// SPDX-License-Identifier: MIT\n2\npragma solidity 0.8.17;\n3\n​\n4\nimport {\n5\n    GelatoRelayContext\n6\n} from \"@gelatonetwork/relay-context/contracts/GelatoRelayContext.sol\";\n7\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n8\n​\n9\n// Inheriting GelatoRelayContext gives access to:\n10\n// 1. _getFeeCollector(): returns the address of Gelato's feeCollector\n11\n// 2. _getFeeToken(): returns the address of the fee token\n12\n// 3. _getFee(): returns the fee to pay\n13\n// 4. _transferRelayFee(): transfers the required fee to Gelato's feeCollector.abi\n14\n// 5. _transferRelayFeeCapped(uint256 maxFee): transfers the fee to Gelato\n15\n//    only if fee < maxFee\n16\n// 6. _getMsgData(): returns the original msg.data without appended information\n17\n// 7. onlyGelatoRelay modifier: allows only Gelato Relay's smart contract\n18\n//    to call the function\n19\ncontract CounterRelayContext is GelatoRelayContext {\n20\n    using Address for address payable;\n21\n​\n22\n    uint256 public counter;\n23\n​\n24\n    event IncrementCounter(uint256 newCounterValue);\n25\n​\n26\n    // `increment` is the target function to call.\n27\n    // This function increments a counter variable by 1\n28\n    // IMPORTANT: with `callWithSyncFee` you need to implement \n29\n    // your own smart contract security measures, as this \n30\n    // function can be called by any third party and not only by \n31\n    // Gelato Relay. If not done properly, funds kept in this\n32\n    // smart contract can be stolen.\n33\n    function increment() external onlyGelatoRelay {\n34\n        // Remember to autheticate your call since you are not using ERC-2771\n35\n        // _yourAuthenticationLogic()\n36\n​\n37\n        // Payment to Gelato\n38\n        // NOTE: be very careful here!\n39\n        // if you do not use the onlyGelatoRelay modifier,\n40\n        // anyone could encode themselves as the fee collector\n41\n        // in the low-level data and drain tokens from this contract.\n42\n        _transferRelayFee();\n43\n​\n44\n        counter++;\n45\n​\n46\n        emit IncrementCounter(counter);\n47\n    }\n48\n​\n49\n    // `incrementFeeCapped` is the target function to call.\n50\n    // This function uses `_transferRelayFeeCapped` method to ensure \n51\n    // better control of gas fees. If gas fees are above the maxFee value \n52\n    // the transaction will not be executed.\n53\n    // This function increments a counter variable by 1\n54\n    // IMPORTANT: with `callWithSyncFee` you need to implement \n55\n    // your own smart contract security measures, as this \n56\n    // function can be called by any third party and not only by \n57\n    // Gelato Relay. If not done properly, funds kept in this\n58\n    // smart contract can be stolen.\n59\n    function incrementFeeCapped(uint256 maxFee) external onlyGelatoRelay {\n60\n        // Remember to autheticate your call since you are not using ERC-2771\n61\n        // _yourAuthenticationLogic()\n62\n​\n63\n        // Payment to Gelato\n64\n        // NOTE: be very careful here!\n65\n        // if you do not use the onlyGelatoRelay modifier,\n66\n        // anyone could encode themselves as the fee collector\n67\n        // in the low-level data and drain tokens from this contract.\n68\n       \n69\n          _transferRelayFeeCapped(maxFee);\n70\n​\n71\n        counter++;\n72\n​\n73\n        emit IncrementCounter(counter);\n74\n    }\n75\n}\n2. Import GelatoRelaySDK into your front-end .js project\n1\nimport { GelatoRelay, CallWithSyncFeeRequest } from \"@gelatonetwork/relay-sdk\";\n2\nconst relay = new GelatoRelay();\n3. Send the payload to Gelato\n1\n// set up target address and function signature abi\n2\nconst counter = \"<your counter contract address>\"; \n3\nconst abi = [\"function increment()\"];\n4\n​\n5\n// generate payload using front-end provider such as MetaMask\n6\nconst provider = new ethers.BrowserProvider(window.ethereum);\n7\nconst signer = provider.getSigner();\n8\n​\n9\n// address of the token to pay fees\n10\nconst feeToken = \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\";\n11\n​\n12\n// instantiate the target contract object\n13\nconst contract = new ethers.Contract(counterAddress, abi, signer);\n14\n​\n15\n// example callig the increment() method\n16\nconst { data } = await contract.populateTransaction.increment();\n17\n​\n18\n// populate the relay SDK request body\n19\nconst request: CallWithSyncFeeRequest = {\n20\n  chainId: (await provider.getNetwork()).chainId,\n21\n  target: counter,\n22\n  data: data,\n23\n  feeToken: feeToken,\n24\n  isRelayContext: true,\n25\n};\n26\n  \n27\n// send relayRequest to Gelato Relay API\n28\nconst relayResponse = await relay.callWithSyncFee(request);\n29\n​\n30\n// -----------------------------------------------------------------\n31\n// the following is an alternative example using Gelato Fee Oracle, \n32\n// setting maxFee, and calling the incrementFeeCapped(maxFee) method\n33\n​\n34\n// retrieve the estimate fee from the Gelato \n35\n​\n36\nconst fee = await relay.getEstimatedFee(\n37\n  (await provider.getNetwork()).chainId,\n38\n  feeToken,\n39\n  gasLimit,\n40\n  false,\n41\n)\n42\n​\n43\nconst maxFee = fee * 2 // you can use 2x or 3x to set your maxFee\n44\n​\n45\n// example calling the incrementFeeCapped(maxFee) method\n46\nconst { dataMaxFee } = await contract.incrementFeeCapped.populateTransaction(maxFee);\n47\n​\n48\n// populate the relay SDK request body\n49\nconst requestMaxFee: CallWithSyncFeeRequest = {\n50\n  chainId: (await provider.getNetwork()).chainId,\n51\n  target: counter,\n52\n  data: dataMaxFee,\n53\n  feeToken: feeToken,\n54\n  isRelayContext: true,\n55\n};\n56\n  \n57\n// send relayRequest to Gelato Relay API\n58\nconst relayResponse = await relay.callWithSyncFee(requestMaxFee);\nPrevious\nsponsoredCall\nNext\nRelay Context Contracts\nLast modified 3mo ago\nON THIS PAGE\nOverview\nPaying for Transactions\nSetting maxFee for Your Transaction\nSDK method: callWithSyncFee\nSending a Request\nRequest Body\nExample Code GelatoRelayContext\n1. Deploy a GelatoRelayContext compatible contract\n2. Import GelatoRelaySDK into your front-end .js project\n3. Send the payload to Gelato"
  },
  {
    "title": "Typescript Function - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/understanding-web3-functions/typescript-function",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n1⃣\nTrigger Types\n2⃣\nTypescript Function\n3⃣\nSolidity Function\n4⃣\nAutomated Transactions\n5⃣\nCreate a Web3 Function Task\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n2⃣\nTypescript Function\nWhat are Typescript Functions?\nTypescript Functions are decentralized cloud functions. They enable developers to execute on-chain transactions based on arbitrary off-chain data (APIs / subgraphs, etc) & computation. These functions are written in Typescript, stored on IPFS and run by Gelato. \nTypescript Functions enable automation in conjunction with the various trigger types outlined on our \nTrigger Types\n page. \nEssential Role of Typescript Functions\nSeamless Integration with Off-Chain Data: They provide an elegant solution for incorporating real-time data from the outside world, enabling smart contracts to respond to external events and changes.\nEnhanced Computation Capabilities: Typescript Functions allow for complex calculations that would be too gas-intensive to perform on-chain, facilitating more sophisticated decision-making processes in your DApps.\nCustomizable Logic Execution: Developers can bring the full power of Typescript to create flexible advanced logic to deliver their application use cases.\nNext steps\nHead over to our quick start guide and get hands on with writing typescript functions:\n​\nWriting Typescript Functions\n​\nWhen you use an on-chain event to trigger your Typescript function you can tap into the full context of this event - learn more here:\n​\nEvent Trigger\n​\nPrevious\nTrigger Types\nNext\nSolidity Function\nLast modified 2mo ago\nON THIS PAGE\nWhat are Typescript Functions?\nEssential Role of Typescript Functions\nNext steps"
  },
  {
    "title": "sponsoredCall - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/non-erc-2771/sponsoredcall",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n3⃣\nsponsoredCall\n2⃣\ncallWithSyncFee\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n3⃣\nsponsoredCall\nPermissionless sponsored transactions\nAfter reading this page: \nYou'll know how to use theSponsoredCallSDK method. This uses the 1Balance payment method, allowing you to sponsor some/all of your user's gas costs.\nYou'll see some code which will help you send a relay request within minutes.\nPlease proceed to our Security Considerations page and read it thoroughly before advancing with your implementation. It is crucial to understand all potential security risks and measures to mitigate them.\nOverview\nsponsoredCall method utilises authentication via a sponsor API key to sponsor gasless transactions  for your users securely. The payment method is Gelato 1Balance.\nSDK method: sponsoredCall\nconst sponsoredCall = async (\n  request: SponsoredCallRequest,\n  sponsorApiKey: string,\n  options?: RelayRequestOptions\n): Promise<RelayResponse>\nArguments:\nrequest: this is the request body used to send a request.\nsponsorApiKey : an API key used to authenticate your sponsorship. \noptions: RelayRequestOptions is an optional request object.\nReturn Object: RelayResponse\ntype RelayResponse = {\n  taskId: string;\n};\ntaskId: your unique relay task ID which can be used for tracking your request.\nOptional Parameters \nSee Optional Parameters.\nUsing Safe smart contract wallets for sponsoredCall\nIf you need to dispatch transactions from Safe smart contract wallets using Gelato Relay via sponsoredCall, you can opt to activate Safe-enabled transactions in your Relay Dapp configuration.\nAllow sponsored transactions from Safes\nUsually when submitting Gelato Relay transactions that originate from Safe smart contract wallets, the Safe wallet address is specified in the target field of the Relay API request, whereas both the actual target contract address and its calldata are encoded into the execTransaction payload. By activating Safe-enabled transactions - accomplished by checking the \"Allow sponsored transactions from Safes\" box - Gelato Relay will validate your Safe smart contract and decode the target contract address and function selector from the execTransaction calldata. It will then apply your pre-configured Relay Dapp rules to these values, rather than to the values given in the Relay request.\nIf your intention is to deploy Safe smart contract wallets prior to their usage, be sure to whitelist the multicall contract address in your Relay Dapp. This contract is typically invoked when you deploy a Safe smart contract wallet before it can be used for the first time.\nSending a Request\nRequest Body\nconst request = {\n  chainId: BigNumberish;\n  target: string;\n  data: BytesLike;\n};\nchainId: the chain ID of the chain where the target smart contract is deployed.\ntarget: the address of the target smart contract.\ndata: encoded payload data (usually a function selector plus the required arguments) used to call the required target address.\nExample Code\nSince sponsoredCall assumes you have your own security logic built in (i.e. replay and re-entrancy protection), you can go ahead and generate the payload for your function call and populate a request object.\n1. Import GelatoRelaySDK into your front-end .js project\n1\nimport { GelatoRelay, SponsoredCallRequest } from \"@gelatonetwork/relay-sdk\";\n2\nconst relay = new GelatoRelay();\n2. Deploy a smart contract\nThis is an example using Gelato's SimpleCounter.sol which is deployed on Goerli and Polygon.\npragma solidity 0.8.17;\n​\ncontract SimpleCounter {\n    uint256 public counter;\n​\n    event IncrementCounter(uint256 newCounterValue, address msgSender);\n​\n    // `increment` is the target function to call.\n    // This function increments a counter variable by 1\n    // IMPORTANT: with `sponsoredCall` you need to implement \n    // your own smart contract security measures, as this \n    // function can be called by any third party and not only by \n    // Gelato Relay. If not done properly, funds kept in this\n    // smart contract can be stolen.\n    function increment() external {\n        counter++;\n        emit IncrementCounter(counter, msg.sender);\n    }\n}\n3. Generate a payload for your target contract\n// set up target address and function signature abi\nconst counter = \"0x763D37aB388C5cdd2Fb0849d6275802F959fbF30\"; \nconst abi = [\"function increment()\"];\n​\n// generate payload using front-end provider such as MetaMask\nconst provider = new ethers.BrowserProvider(window.ethereum);\nconst signer = provider.getSigner();\n​\nconst contract = new ethers.Contract(counterAddress, abi, signer);\nconst { data } = await contract.increment.populateTransaction();\n4. Send the payload to Gelato\n1\n// Populate a relay request\n2\nconst request: SponsoredCallRequest = {\n3\n  chainId: (await provider.getNetwork()).chainId,\n4\n  target: counter,\n5\n  data: data,\n6\n};\n7\n​\n8\n// Without a specific API key, the relay request will fail! \n9\n// Go to https://relay.gelato.network to get a testnet API key with 1Balance.\n10\n// Send the relay request using Gelato Relay!\n11\nconst relayResponse = await relay.sponsoredCall(request, apiKey);\nPrevious\nNon-ERC-2771\nNext\ncallWithSyncFee\nLast modified 3mo ago\nON THIS PAGE\nOverview\nUsing Safe smart contract wallets for sponsoredCall\nSending a Request\nRequest Body\nExample Code\n1. Import GelatoRelaySDK into your front-end .js project\n2. Deploy a smart contract\n3. Generate a payload for your target contract\n4. Send the payload to Gelato"
  },
  {
    "title": "eth_chainId - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/account-abstraction/bundler-api-endpoints/eth_chainid",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\neth_sendUserOperation\neth_estimateUserOperationGas\neth_getUserOperationByHash\neth_getUserOperationReceipt\neth_supportedEntryPoints\neth_maxPriorityFeePerGas\neth_chainId\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\neth_chainId\nPlease refer to 1Balance & Relay to create a sponsorApiKey.\nPOST\nhttps://api.gelato.digital/\n/bundlers/{chainId}/rpc\neth_chainId\n\nReturns the chainId of the network the bundler is serving.\n\nParameters\nPath\nchainId*\nnumber\nTarget network chain identifier.\nQuery\nsponsorApiKey*\nstring\n1Balance API key which covers transaction costs.\nBody\nExample\nSchema\n{​\n  \"id\": 0,​\n  \"jsonrpc\": \"2.0\",​\n  \"method\": \"eth_chainId\"​\n​}\nResponses\n200: OK\nSuccessful response\n400: Bad Request\nValidation error\nPrevious\neth_maxPriorityFeePerGas\nNext - Services\nRelay\nLast modified 1mo ago"
  },
  {
    "title": "sponsoredCallERC2771 - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/erc-2771-recommended/sponsoredcallerc2771",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n1⃣\nsponsoredCallERC2771\n2⃣\ncallWithSyncFeeERC2771\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n1⃣\nsponsoredCallERC2771\nSponsored transactions with ERC2771 authentication support\nIf you are using @gelatonetwork/relay-sdk v3 or contracts from the package @gelatonetwork/relay-context v2 please follow this migration guide to migrate to the new versions.\nAfter reading this page: \nYou'll know how to use the sponsoredCallERC2771 SDK method. This will give your user's a gasless UX requiring a user signature. This uses the 1Balance payment method, allowing you to sponsor some/all of your user's gas costs.\nYou'll learn about how to incorporate ERC2771Context into your contract for _msgSender() support.\nYou'll see some code which will help you send a relay request within minutes.\nPlease proceed to our Security Considerations page and read it thoroughly before advancing with your implementation. It is crucial to understand all potential security risks and measures to mitigate them.\nOverview\n\nThe sponsoredCallERC2771 method uses both a sponsor API key and a user's signature, like that from MetaMask, to securely sponsor gasless transactions. Payments are made via the Gelato 1Balance method.\nGelato Relay SDK has various methods for handling sponsored ERC2771 transactions. The most straightforward is sponsoredCallERC2771, which handles both signing and sending in one step. If you need to separate these processes, other SDK methods are available.\nSDK Methods\nsponsoredCallERC2771\nThis method initiates the signing of ERC2771 requests with the provided BrowserProvider or Wallet. Once the signature is obtained, the request is forwarded to Gelato.\nconst sponsoredCallERC2771 = async (\n  request: CallWithERC2771Request | CallWithConcurrentERC2771Request,\n  signerOrProvider: ethers.BrowserProvider | ethers.Signer,\n  sponsorApiKey: string,\n  options?: RelayRequestOptions\n): Promise<RelayResponse>\nArguments\nrequest: The body of the request intended for sending.\nsignerOrProvider: a valid provider connected to RPC or a signer.\nsponsorApiKey: an API key used to authenticate your sponsorship. \noptions: an object for specifying optional parameters.\nResponse\ntype RelayResponse = {\n  taskId: string;\n};\ntaskId: a unique task ID which can be used for tracking your request.\ngetSignatureDataERC2771\nThis method starts the signing process for ERC2771 requests using the given BrowserProvider or Signer. After capturing the signature, it returns both the signature and the message. This collected data can then be used with the sponsoredCallERC2771WithSignature method to send the request to Gelato.\ngetSignatureDataERC2771 = (\n  request: CallWithERC2771Request | CallWithConcurrentERC2771Request,\n  signerOrProvider: ethers.BrowserProvider | ethers.Signer,\n  type: ERC2771Type\n): Promise<SignatureData>\nArguments\nrequest: this is the request body used to send a request.\nsignerOrProvider: a valid provider connected to RPC or a signer.\ntype: SponsoredCall for a sequential flow or ConcurrentSponsoredCall for a concurrent flow.\nResponse\ntype SignatureData = ConcurrentSignatureData \n| SequentialSignatureData;\n​\ntype ConcurrentSignatureData = {\n  struct: CallWithConcurrentERC2771Struct;\n  signature: string;\n};\n​\ntype SequentialSignatureData = {\n  struct: CallWithERC2771Struct;\n  signature: string;\n};\nstruct: EIP-712 message data.\nsignature: EIP-712 signature.\ngetDataToSignERC2771\nThis method provides the message data intended for external signing along with the EIP-712 typed data. After obtaining the signature, the request can be dispatched using the sponsoredCallERC2771WithSignature method.\ngetDataToSignERC2771 = (\n  request: CallWithERC2771Request | CallWithConcurrentERC2771Request,\n  type: ERC2771Type,\n  signerOrProvider?: ethers.BrowserProvider | ethers.Signer,\n): Promise<PayloadToSign>\nArguments\nrequest: The body of the request intended for sending.\ntype: SponsoredCall for a sequential flow or ConcurrentSponsoredCall for a concurrent flow.\nsignerOrProvider (optional): A provider needed in a sequential flow to obtain the nonce from the smart contract. If you're providing the nonce within your request or if you're using the concurrent flow, this parameter isn't necessary.\nResponse\ntype PayloadToSign = ConcurrentPayloadToSign | SequentialPayloadToSign;\n​\ntype ConcurrentPayloadToSign = {\n  struct: CallWithConcurrentERC2771Struct;\n  typedData: SponsoredCallConcurrentERC2771PayloadToSign \n};\n​\ntype SequentialPayloadToSign = {\n  struct: CallWithERC2771Struct;\n  typedData: SponsoredCallERC2771PayloadToSign\n};\nstruct: EIP-712 message data.\ntypedData: EIP-712 typed data.\nsponsoredCallERC2771WithSignature\nThis method sends pre-signed requests to Gelato.\nsponsoredCallERC2771WithSignature = async (\n  struct: SignatureData[\"struct\"],\n  signature: SignatureData[\"signature\"],\n  sponsorApiKey: string,\n  options?: RelayRequestOptions\n): Promise<RelayResponse>\nArguments\nstruct: EIP-712 message data returned from the signing methods.\nsignature: EIP-712 signature returned after signing the request.\nsponsorApiKey: an API key used to authenticate your sponsorship. \noptions: an object for specifying optional parameters.\nResponse\ntype RelayResponse = {\n  taskId: string;\n};\ntaskId: a unique task ID which can be used for tracking your request.\nOptional Parameters \nSee Optional Parameters.\nSending a Request\nAs of today, we support two distinct ways of sending sponsoredCallERC2771 requests:\n1.\nSequentially: This approach ensures that each request is ordered and validated against the nonce stored on-chain. You have two options in this method:\nFetch the current nonce value from the smart contract yourself and include it with your request.\nAllow the relay-sdk to fetch the nonce value for you when handling your relay request.\n2.\nConcurrently: This method enables you to send multiple transactions simultaneously. Replay protection is achieved using a hash-based salt mechanism. Again, you have two options:\nProvide your own salt value.\nAllow the relay-sdk to generate a unique salt value for you when processing your relay request.\nBy default sponsoredCallERC2771 requests are using the sequential method.\nConcurrent ERC2771 support has been introduced in the relay-sdk version 5.1.0. Please make sure that your package is up-to-date to start using it.\nRequest Body\ntype SequentialERC2771Request = {\n  chainId: BigNumberish;\n  target: string;\n  data: BytesLike;\n  user: string;\n  userDeadline?: BigNumberish;\n  isConcurrent?: false;\n  userNonce?: BigNumberish;\n};\ntype ConcurrentERC2771Request = {\n  chainId: BigNumberish;\n  target: string;\n  data: BytesLike;\n  user: string;\n  userDeadline?: BigNumberish;\n  isConcurrent: true;\n  userSalt?: string\n};\nCommon Parameters:\nchainId: the chain ID of the chain where the target smart contract is deployed.\ntarget: the address of the target smart contract.\ndata: encoded payload data (usually a function selector plus the required arguments) used to call the required target address.\nuser: the address of the user's EOA.\nuserDeadline: optional, the amount of time in seconds that a user is willing for the relay call to be active in the relay backend before it is dismissed.\nThis way the user knows that if the transaction is not sent within a certain timeframe, it will expire. Without this, an adversary could pick up the transaction in the mempool and send it later. This could transfer money, or change state at a point in time which would be highly undesirable to the user.\nParameters For Sequential Requests:\nisConcurrent: false (default), optional, represents that the users' requests are validated based on a nonce, which enforces them to be processed sequentially.\nuserNonce: optional, this nonce, akin to Ethereum nonces, is stored in a local mapping on the relay contracts. It serves to enforce the nonce ordering of relay calls if the user requires sequential processing. If this parameter is omitted, the relay-sdk will automatically query the current value on-chain.\nParameters For Concurrent Requests:\nisConcurrent: true, indicates that the users' requests are validated based on a unique salt, allowing them to be processed concurrently. Replay protection is still ensured by permitting each salt value to be used only once.\nuserSalt: optional, this is a bytes32 hash that is used for replay protection. If the salt is not provided then relay-sdk would generate a unique value based on a random seed and a timestamp.\nExample Code\nFor your testing, Gelato has deployed a simple contract which implements logic to increment a counter with ERC2771 support.\nCounterERC2771.sol: deployed at the address 0x00172f67db60E5fA346e599cdE675f0ca213b47b on these networks.\nCounterERC2771.sol's counter is special because it implements ERC-2771 _msgSender authentication to allow for secure whitelisting based on the identity of the original off-chain relay request originator, which has been verified using a user signature. \nFurthermore, to set your trusted forwarder, you need the address for GelatoRelay1BalanceERC2771.sol that you can find here.\n1. Deploy an ERC2771Context compatible contract \n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n​\nimport {\n    ERC2771Context\n} from \"@gelatonetwork/relay-context/contracts/vendor/ERC2771Context.sol\";\n​\n// Importing ERC2771Context gives access to:\n// 1. An immutable trusted forwarder address\n// 2. function isTrustedForwarder \n//    to verify an input address matches the trustedForwarder address\n// 3. function _msgSender()\n//    which decodes the user's address from the calldata\n//    _msgSender() can now be used to refer to user safely\n//    instead of msg.sender (which is Gelato Relay in this case).\n// 4. function _msgData()\n//    which decodes the function signature from the calldata\ncontract CounterERC2771 is ERC2771Context {\n    // Here we have a mapping that maps a counter to an address\n    mapping(address => uint256) public contextCounter;\n​\n    event IncrementContextCounter(address _msgSender);\n​\n    // ERC2771Context: setting the immutable trustedForwarder variable\n    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {}\n    \n    // `incrementContext` is the target function to call\n    // This function increments a counter variable which is \n    // mapped to every _msgSender(), the address of the user.\n    // This way each user off-chain has their own counter \n    // variable on-chain.\n    function incrementContext() external {\n        // Remember that with the context shift of relaying,\n        // where we would use `msg.sender` before, \n        // this now refers to Gelato Relay's address, \n        // and to find the address of the user, \n        // which has been verified using a signature,\n        // please use _msgSender()!\n​\n        // If this contract was not not called by the \n        // trusted forwarder, _msgSender() will simply return \n        // the value of msg.sender instead.\n        \n        // Incrementing the counter mapped to the _msgSender!\n        contextCounter[_msgSender()]++;\n        \n        // Emitting an event for testing purposes\n        emit IncrementContextCounter(_msgSender());\n    }\n}\n​\n2. Import GelatoRelaySDK into your front-end .js project\n1\nimport { GelatoRelay, SponsoredCallERC2771Request } from \"@gelatonetwork/relay-sdk\";\n2\nconst relay = new GelatoRelay();\n3. Send the payload to Gelato\nThis is an example using Gelato's CounterERC2771.sol which is deployed on these networks.\n// Set up on-chain variables, such as target address\nconst counter = \"0x00172f67db60E5fA346e599cdE675f0ca213b47b\"; \nconst abi = [\"function incrementContext()\"];\nconst provider = new ethers.BrowserProvider(window.ethereum);\nconst signer = provider.getSigner();\nconst user = signer.getAddress();\n​\n// Generate the target payload\nconst contract = new ethers.Contract(counter, abi, signer);\nconst { data } = await contract.incrementContext.populateTransaction();\n​\n// Populate a relay request\nconst request: CallWithERC2771Request = {\n  chainId: (await provider.getNetwork()).chainId,\n  target: counter;\n  data: data;\n  user: user;\n};\n​\n// Without a specific API key, the relay request will fail! \n// Go to https://relay.gelato.network to get a testnet API key with 1Balance.\n// Send a relay request using Gelato Relay!\nconst relayResponse = await relay.sponsoredCallERC2771(request, provider, apiKey);\nPrevious\nERC-2771 (recommended)\nNext\ncallWithSyncFeeERC2771\nLast modified 3mo ago\nON THIS PAGE\nOverview\nSDK Methods\nsponsoredCallERC2771\ngetSignatureDataERC2771\ngetDataToSignERC2771\nsponsoredCallERC2771WithSignature\nOptional Parameters\nSending a Request\nExample Code\n1. Deploy an ERC2771Context compatible contract"
  },
  {
    "title": "callWithSyncFeeERC2771 - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/erc-2771-recommended/callwithsyncfeeerc2771",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n1⃣\nsponsoredCallERC2771\n2⃣\ncallWithSyncFeeERC2771\n🍧\nRelay Context Contracts ERC2771\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n2⃣\ncallWithSyncFeeERC2771\nTransactions with on-chain payments and ERC2771 authentication support\nIf you are using @gelatonetwork/relay-sdk v3 or contracts from the package @gelatonetwork/relay-context v2 please follow this migration guide to migrate to the new versions.\nAfter reading this page: \nYou'll know how to use the callWithSyncFeeERC2771 SDK method, using the syncFee payment method.\nYou'll see some code which will help you send a relay request within minutes.\nYou'll learn how to pay for transactions using the provided values for fee, feeToken and feeCollector.\nPlease proceed to our Security Considerations page and read it thoroughly before advancing with your implementation. It is crucial to understand all potential security risks and measures to mitigate them.\nOverview\nThe callWithSyncFeeERC2771 method uses the syncFee payment method with ERC-2771 support. \nPaying for Transactions\nWhen using callWithSyncFeeERC2771 relay method the target contract assumes responsibility for transferring the fee to Gelato's fee collector during transaction execution. For this, the target contract needs to know:\nfee: the transfer amount\nfeeToken: the token to be transferred\nfeeCollector: the destination address for the fee\nFortunately, Gelato provides some useful tools within the Relay Context Contracts:\n1.\nBy inheriting the GelatoRelayContextERC2771 contract in your target contract, you have the ability to transfer the fee through one of two straightforward methods: _transferRelayFee() or _transferRelayFeeCapped(uint256 maxFee). In either case, the inherited contract takes care of decoding the fee, feeToken, and feeCollector behind the scenes.\nThe Gelato Relay backend simplifies the process by automatically calculating the fee for you, using Gelato's Fee Oracle to perform the calculations in the background.\n2.\nAlternatively, you may choose to inherit the GelatoRelayFeeCollectorERC2771 contract. With this approach, Gelato decodes only the feeCollector. You must provide the fee and feeToken on-chain, either by hardcoding them (which is not recommended) or embedding them within the payload to be executed. The suggested way to handle this is to calculate the fee with Gelato's Fee Oracle.\nThis modular design ensures a smooth integration with Gelato's fee handling mechanisms, providing a flexible and user-friendly approach to managing transaction fees within your dApps.\nSetting maxFee for Your Transaction\nSetting a maximum fee, or maxFee, for your transactions is strongly advised. This practice enables you to ensure that transaction costs remain below a specific limit. The method _transferRelayFeeCapped(uint256 maxFee) in the GelatoRelayContextERC2771 contract provides a convenient way to set the maxFee easily.\nIf you are utilizing the GelatoRelayFeeCollectorERC2771 contract, the recommended way to pass the maxFee is by calculating the fee with Gelato's Fee Oracle, which is accessible in the Relay SDK. The getEstimatedFee() method is provided to facilitate this calculation.\nSDK Methods\n callWithSyncFeeERC2771\nThis method initiates the signing of ERC2771 requests with the provided BrowserProvider or Wallet. Once the signature is obtained, the request is forwarded to Gelato.\nconst callWithSyncFeeERC2771 = async (\n  request: CallWithSyncFeeERC2771Request | CallWithSyncFeeConcurrentERC2771Request,\n  signerOrProvider: ethers.BrowserProvider | ethers.Signer,\n  options?: RelayRequestOptions,\n  apiKey?: string\n): Promise<RelayResponse>\nArguments\nrequest: The body of the request intended for sending.\nsignerOrProvider: a valid provider connected to RPC or a signer.\noptions: an object for specifying optional parameters.\napiKey: an optional API key that links your request to your Gelato Relay account. As this call pertains to the syncFee payment method, transaction costs won't be deducted from your 1Balance account. By using the API key, you can benefit from increased rate limits of your Gelato Relay account.\nResponse\ntype RelayResponse = {\n  taskId: string;\n};\ntaskId: a unique task ID which can be used for tracking your request.\ngetSignatureDataERC2771\nThis method starts the signing process for ERC2771 requests using the given BrowserProvider or Signer. After capturing the signature, it returns both the signature and the message. This collected data can then be used with the callWithSyncFeeERC2771WithSignature method to send the request to Gelato.\ngetSignatureDataERC2771 = (\n  request: CallWithERC2771Request | CallWithConcurrentERC2771Request,\n  signerOrProvider: ethers.BrowserProvider | ethers.Signer,\n  type: ERC2771Type\n): Promise<SignatureData>\nArguments\nrequest: The body of the request intended for sending.\nsignerOrProvider: a valid provider connected to RPC or a signer.\ntype: CallWithSyncFee for a sequential flow or ConcurrentCallWithSyncFee for a concurrent flow. \nResponse\ntype SignatureData = ConcurrentSignatureData \n| SequentialSignatureData;\n​\ntype ConcurrentSignatureData = {\n  struct: CallWithConcurrentERC2771Struct;\n  signature: string;\n};\n​\ntype SequentialSignatureData = {\n  struct: CallWithERC2771Struct;\n  signature: string;\n};\nstruct: EIP-712 message data.\nsignature: EIP-712 signature.\ngetDataToSignERC2771\nThis method provides the message data intended for external signing along with the EIP-712 typed data. After obtaining the signature, the request can be dispatched using the callWithSyncFeeERC2771WithSignature method.\ngetDataToSignERC2771 = (\n  request: CallWithERC2771Request | CallWithConcurrentERC2771Request,\n  type: ERC2771Type,\n  signerOrProvider?: ethers.BrowserProvider | ethers.Signer,\n): Promise<PayloadToSign>\nArguments\nrequest: The body of the request intended for sending.\ntype: CallWithSyncFee for a sequential flow or ConcurrentCallWithSyncFee for a concurrent flow. \nsignerOrProvider (optional): A provider needed in a sequential flow to obtain the nonce from the smart contract. If you're providing the nonce within your request or if you're using the concurrent flow, this parameter isn't necessary.\nResponse\ntype PayloadToSign = ConcurrentPayloadToSign | SequentialPayloadToSign;\n​\ntype ConcurrentPayloadToSign = {\n  struct: CallWithConcurrentERC2771Struct;\n  typedData: CallWithSyncFeeConcurrentERC2771PayloadToSign;\n};\n​\ntype SequentialPayloadToSign = {\n  struct: CallWithERC2771Struct;\n  typedData: CallWithSyncFeeERC2771PayloadToSign;\n};\nstruct: EIP-712 message data.\ntypedData: EIP-712 typed data.\ncallWithSyncFeeERC2771WithSignature\nThis method sends pre-signed requests to Gelato.\nconst callWithSyncFeeERC2771WithSignature = async (\n    struct: CallWithERC2771Struct | CallWithConcurrentERC2771Struct;\n    syncFeeParams: BaseCallWithSyncFeeParams;\n    signature: string;\n    options?: RelayRequestOptions;\n    apiKey?: string\n): Promise<RelayResponse>\nArguments\nstruct: EIP-712 message data returned from the signing methods.\nsyncFeeParams: the feetoken and isRelayContext params.\nsignature: EIP-712 signature returned after signing the request.\noptions: an object for specifying optional parameters.\napiKey: an optional API key that links your request to your Gelato Relay account. As this call pertains to the syncFee payment method, transaction costs won't be deducted from your 1Balance account. By using the API key, you can benefit from increased rate limits of your Gelato Relay account.\nResponse\ntype RelayResponse = {\n  taskId: string;\n};\ntaskId: a unique task ID which can be used for tracking your request.\nOptional Parameters \nSee Optional Parameters. \nSending a Request\nAs of today, we support two distinct ways of sending callWithSyncFeeERC2771 requests:\n1.\nSequentially: This approach ensures that each request is ordered and validated against the nonce stored on-chain. You have two options in this method:\nFetch the current nonce value from the smart contract yourself and include it with your request.\nAllow the relay-sdk to fetch the nonce value for you when handling your relay request.\n2.\nConcurrently: This method enables you to send multiple transactions simultaneously. Replay protection is achieved using a hash-based salt mechanism. Again, you have two options:\nProvide your own salt value.\nAllow the relay-sdk to generate a unique salt value for you when processing your relay request.\nBy default callWithSyncFeeERC2771 requests are using the sequential method.\nConcurrent ERC2771 support has been introduced in the relay-sdk version 5.1.0. Please make sure that your package is up-to-date to start using it.\nRequest Body\ntype SequentialERC2771Request = {\n  chainId: BigNumberish;\n  target: string;\n  data: BytesLike;\n  user: string;\n  userDeadline?: BigNumberish;\n  feeToken: string;\n  isRelayContext?: boolean;\n  isConcurrent?: false;\n  userNonce?: BigNumberish;\n};\ntype ConcurrentERC2771Request = {\n  chainId: BigNumberish;\n  target: string;\n  data: BytesLike;\n  user: string;\n  userDeadline?: BigNumberish;\n  feeToken: string;\n  isRelayContext?: boolean;\n  isConcurrent: true;\n  userSalt?: string;\n};\nCommon Parameters\nchainId: the chain ID of the chain where the target smart contract is deployed.\ntarget: the address of the target smart contract.\ndata: encoded payload data (usually a function selector plus the required arguments) used to call the required target address.\nuser: the address of the user's EOA.\nuserDeadline: optional, the amount of time in seconds that a user is willing for the relay call to be active in the relay backend before it is dismissed.\nThis way the user knows that if the transaction is not sent within a certain timeframe, it will expire. Without this, an adversary could pick up the transaction in the mempool and send it later. This could transfer money, or change state at a point in time which would be highly undesirable to the user.\nfeeToken: the address of the token that is to be used for payment. Please visit SyncFee Payment Tokens for the full list of supported payment tokens per network.\nisRelayContext: an optional boolean (default: true) denoting what data you would prefer appended to the end of the calldata.\nIf set to true (default), Gelato Relay will append the feeCollector address, the feeToken address, and the uint256 fee to the calldata. In this case your target contract should inherit from the GelatoRelayContextERC2771 contract.\nIf set to false, Gelato Relay will only append the feeCollector address to the calldata. In this case your target contract should inherit from the GelatoRelayFeeCollectorERC2771 contract.\nParameters For Sequential Requests:\nisConcurrent: false (default), optional, represents that the users' requests are validated based on a nonce, which enforces them to be processed sequentially.\nuserNonce: optional, this nonce, akin to Ethereum nonces, is stored in a local mapping on the relay contracts. It serves to enforce the nonce ordering of relay calls if the user requires sequential processing. If this parameter is omitted, the relay-sdk will automatically query the current value on-chain.\nParameters For Concurrent Requests:\nisConcurrent: true, indicates that the users' requests are validated based on a unique salt, allowing them to be processed concurrently. Replay protection is still ensured by permitting each salt value to be used only once.\nuserSalt: optional, this is a bytes32 hash that is used for replay protection. If the salt is not provided then relay-sdk would generate a unique value based on a random seed and a timestamp.\nExample Code (using GelatoRelayContextERC2771)\n1. Deploy a GelatoRelayContextERC2771 compatible contract\n1\n// SPDX-License-Identifier: MIT\n2\npragma solidity 0.8.17;\n3\n​\n4\nimport {\n5\n    GelatoRelayContextERC2771\n6\n} from \"@gelatonetwork/relay-context/contracts/GelatoRelayContextERC2771.sol\";\n7\n​\n8\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n9\n​\n10\n// Inheriting GelatoRelayContext gives access to:\n11\n// 1. _getFeeCollector(): returns the address of Gelato's feeCollector\n12\n// 2. _getFeeToken(): returns the address of the fee token\n13\n// 3. _getFee(): returns the fee to pay\n14\n// 4. _transferRelayFee(): transfers the required fee to Gelato's feeCollector.abi\n15\n// 5. _transferRelayFeeCapped(uint256 maxFee): transfers the fee to Gelato\n16\n//    only if fee < maxFee\n17\n// 6. function _getMsgSender(): decodes and returns the user's address from the\n18\n//    calldata, which can be used to refer to user safely instead of msg.sender\n19\n//    (which is Gelato Relay in this case).\n20\n// 7. _getMsgData(): returns the original msg.data without appended information\n21\n// 8. onlyGelatoRelay modifier: allows only Gelato Relay's smart contract\n22\n//    to call the function\n23\ncontract CounterRelayContextERC2771 is GelatoRelayContextERC2771 {\n24\n    using Address for address payable;\n25\n​\n26\n    mapping(address => uint256) public contextCounter;\n27\n​\n28\n    // emitting an event for testing purposes\n29\n    event IncrementCounter(address msgSender);\n30\n​\n31\n    // `increment` is the target function to call.\n32\n    // This function increments a counter variable which is \n33\n    // mapped to every _getMsgSender(), the address of the user.\n34\n    // This way each user off-chain has their own counter \n35\n    // variable on-chain.\n36\n    function increment() external onlyGelatoRelayERC2771 {\n37\n        // Payment to Gelato\n38\n        // NOTE: be very careful here!\n39\n        // if you do not use the onlyGelatoRelay modifier,\n40\n        // anyone could encode themselves as the fee collector\n41\n        // in the low-level data and drain tokens from this contract.\n42\n        _transferRelayFee();\n43\n​\n44\n        // Incrementing the counter mapped to the _getMsgSender()\n45\n        contextCounter[_getMsgSender()]++;\n46\n        \n47\n        emit IncrementCounter(_getMsgSender());\n48\n    }\n49\n    \n50\n    // `incrementFeeCapped` is the target function to call.\n51\n    // This function uses `_transferRelayFeeCapped` method to ensure \n52\n    // better control of gas fees. If gas fees are above the maxFee value \n53\n    // the transaction will not be executed.\n54\n    // The maxFee will be passed as an argument to the contract call.\n55\n    // This function increments a counter variable by 1\n56\n    // IMPORTANT: with `callWithSyncFee` you need to implement \n57\n    // your own smart contract security measures, as this \n58\n    // function can be called by any third party and not only by \n59\n    // Gelato Relay. If not done properly, funds kept in this\n60\n    // smart contract can be stolen.\n61\n    function incrementFeeCapped(uint256 maxFee) external  onlyGelatoRelayERC2771 {\n62\n​\n63\n        // Payment to Gelato\n64\n        // NOTE: be very careful here!\n65\n        // if you do not use the onlyGelatoRelay modifier,\n66\n        // anyone could encode themselves as the fee collector\n67\n        // in the low-level data and drain tokens from this contract.\n68\n  \n69\n        _transferRelayFeeCapped(maxFee);\n70\n​\n71\n        // Incrementing the counter mapped to the _getMsgSender()\n72\n        contextCounter[_getMsgSender()]++;\n73\n​\n74\n        emit IncrementCounter(counter);\n75\n    }\n76\n}\n77\n​\n2. Import GelatoRelaySDK into your front-end .js project\n1\nimport { GelatoRelay, CallWithSyncFeeERC2771Request } from \"@gelatonetwork/relay-sdk\";\n2\nconst relay = new GelatoRelay();\n3. Send the payload to Gelato\n1\n// target contract address\n2\nconst counter = \"<your counter contract address>\";\n3\n​\n4\n// using a human-readable ABI for generating the payload\n5\nconst abi = [\"function increment()\"];\n6\n​\n7\n// address of the token used to pay fees\n8\nconst feeToken = \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\";\n9\n​\n10\n// connect to the blockchain via a front-end provider\n11\nconst provider = new ethers.BrowserProvider(window.ethereum);\n12\nconst signer = provider.getSigner();\n13\nconst user = signer.getAddress();\n14\n​\n15\n// instantiate the target contract object\n16\nconst contract = new ethers.Contract(counter, abi, signer);\n17\n​\n18\n// example calling the increment() method\n19\nconst { data } = await contract.increment.populateTransaction();\n20\n​\n21\n// populate the relay SDK request body\n22\nconst request: CallWithSyncFeeERC2771Request = {\n23\n  chainId: (await provider.getNetwork()).chainId,\n24\n  target: counter,\n25\n  data: data,\n26\n  user: user,\n27\n  feeToken: feeToken,\n28\n  isRelayContext: true,\n29\n};\n30\n  \n31\n// send relayRequest to Gelato Relay API\n32\nconst relayResponse = await relay.callWithSyncFeeERC2771(request, provider);\n33\n​\n34\n// -----------------------------------------------------------------\n35\n// the following is an alternative example using Gelato Fee Oracle, \n36\n// setting maxFee, and calling the incrementFeeCapped(maxFee) method\n37\n​\n38\n// retrieve the estimate fee from Gelato Fee Oracle\n39\nconst fee = await relay.getEstimatedFee(\n40\n  (await provider.getNetwork()).chainId,\n41\n  feeToken,\n42\n  gasLimit,\n43\n  false,\n44\n)\n45\n​\n46\n// you can use 2x or 3x to set your maxFee\n47\nconst maxFee = fee * 2\n48\n​\n49\n// example calling the incrementFeeCapped(maxFee) method\n50\nconst { dataMaxFee } = await contract.incrementFeeCapped.populateTransaction(maxFee);\n51\n​\n52\n// populate the relay SDK request body\n53\nconst requestMaxFee: CallWithSyncFeeERC2771Request = {\n54\n  chainId:  (await provider.getNetwork()).chainId,\n55\n  target: counter,\n56\n  data: dataMaxFee,\n57\n  user: user,\n58\n  feeToken: feeToken,\n59\n  isRelayContext: true,\n60\n};\n61\n  \n62\n// send relayRequest to Gelato Relay API\n63\nconst relayResponseMAxFee = await relay.callWithSyncFeeERC2771(requestMaxFee, provider);\nPrevious\nsponsoredCallERC2771\nNext\nRelay Context Contracts ERC2771\nLast modified 3mo ago\nON THIS PAGE\nOverview\nPaying for Transactions\nSetting maxFee for Your Transaction\nSDK Methods\ncallWithSyncFeeERC2771\ngetSignatureDataERC2771\ngetDataToSignERC2771\ncallWithSyncFeeERC2771WithSignature\nOptional Parameters\nSending a Request\nExample Code (using GelatoRelayContextERC2771)\n1. Deploy a GelatoRelayContextERC2771 compatible contract\n2. Import GelatoRelaySDK into your front-end .js project\n3. Send the payload to Gelato"
  },
  {
    "title": "Migration Guide ethers.js v5 to v6 - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/migration-guide-ethers.js-v5-to-v6",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n⏩\nMigration Guide ethers.js v5 to v6\nHow to migrate your code to ethers.js v6\nWith the @gelatonetwork/relay-sdk version 5, the package uses ethers.js v6. In this guide, we will review the main changes related to the usage of the relay-sdk.\nFor a comprehensive list of changes when migrating from ethers.js v5 to ethers.js v6, please consult the official documentation.\nCreating the calldata: populateTransaction method\nIn all Relay requests, we send the calldata to be forwarded to the target contract. One way of creating this calldata was by invoking the populateTransaction method. The way this is done has changed from ethers v5 to v6:\n\nethers@v5\n// encoding increment method call\nconst contract = new ethers.Contract(counter, abi, signer);\nconst { data } = await contract.populateTransaction.increment();\nethers@v6\n// encoding increment method call\nconst contract = new ethers.Contract(counter, abi, signer);\nconst { data } = await contract.increment.populateTransaction();\nProviders\nWhen instantiating a provider, either on the backend or frontend, you will have to update your code. This is because the package ethers.providers has been moved to ethers. So the change would look like this:\n\nethers@v5\n// Instantiating a JsonRpcProvider\nconst provider =  ethers.providers.JsonRpcProvider()\nethers@v6\n// Instantiating a JsonRpcProvider\nconst provider = new ethers.JsonRpcProvider()\nIn addition to the change mentioned above, the Web3Provider, which was used to instantiate the frontend provider using (window.ethereum), is now called BrowserProvider. So, you'll need to make the following update:\n\nethers@v5\n// Instantiating a Web3Provider\nconst provider =  new ethers.providers.Web3Provider(window.ethereum)\nethers@v6\n// Instantiating a BrowserProvider\nconst provider = new ethers.BrowserProvider(window.ethereum)\nChainId\nWhen querying the chainId from the provider in ethers.js v5, the result was returned as a number. However, in v6, the chainId is returned as a BigInt. If you have code that relies on the chainId being a number, you'll need to update it to handle a BigInt instead.\nHere's a simple example that may help you understand how to adapt your code:\n\nethers@v5\n// ChainId\nconst chainId = (await provider.getNetwork()).chainId;\nconst chainId = 5 // Goerli\nethers@v6\n// ChainId\nconst chainId = (await provider.getNetwork()).chainId;\nconst chainId = 5n // Goerli\nconst chainId = BigInt(5) // Goerli\nExamples\nPlease visit our examples GitHub repository, which showcases the usage of the new @gelatonetwork/relay-sdk v5 implementation for both frontend and backend.\nGitHub - gelatodigital/relay-examples-frontend-backend-v5: Repo showcasing how to call the relay from a React UI as well as from node\nGitHub\nPrevious\nAPI\nNext\nERC2771 Migration Guide\nLast modified 3mo ago\nON THIS PAGE\nCreating the calldata: populateTransaction method\nProviders\nChainId\nExamples"
  },
  {
    "title": "Networks & Rate Limits - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/networks-and-rate-limits",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n✅\nNetworks & Rate Limits\nFind out where you can get started with Relay today!\nPro Tier: For access to pro tier and custom rate limits please request an upgrade here​\nPlease note that our support for the Goerli, Optimism Goerli, and Arbitrum Goerli test networks will be discontinued after December 31, 2023. We recommend users to transition their operations to Sepolia, Optimism Sepolia, or Arbitrum Sepolia to ensure uninterrupted service and support.\nNetwork\nStandard Rate Limits\nPro Rate Limits\n​Gelato OP Testnet​\n5 req/min\n30 req/min\n​Astar zKatana Testnet​\n5 req/min\n30 req/min\n​Tangible Unreal Testnet​\n5 req/min\n30 req/min\nArbitrum / Arbitrum Goerli / Arbitrum Sepolia\n5 req/min\n30 req/min\nAvalanche\n5 req/min\n30 req/min\nBase / Base Goerli\n5 req/min\n30 req/min\nBNB\n5 req/min\n30 req/min\nEthereum / Goerli / Sepolia\n5 req/min\n30 req/min\nGnosis / Chiado\n5 req/min\n30 req/min\nLinea / Linea Testnet\n5 req/min\n30 req/min\nOptimism / Optimism Goerli / Optimism Sepolia\n5 req/min\n30 req/min\nPolygon / Mumbai\n5 req/min\n30 req/min\nPolygon zkEVM Mainnet / Testnet\n5 req/min\n30 req/min\nzkSync Era Mainnet / Testnet\n5 req/min\n30 req/min\nZora Mainnet\n5 req/min\n30 req/min\nShibarium Mainnet\n5 req/min\n30 req/min\n* Support for these networks is currently in Beta phase. During this phase, you may encounter unexpected errors, experience reduced availability, and have limited access to support services. We appreciate your understanding and patience as we work towards full functionality.\nContract Addresses\nAll supported networks except zkSync Era and Shibarium\nGelatoRelay.sol\nRelay method: callWithSyncFee\nAddress: 0xaBcC9b596420A9E9172FD5938620E265a0f9Df92\nGelatoRelayERC2771.sol\nRelay method: callWithSyncFeeERC2771\nAddress: 0xb539068872230f20456CF38EC52EF2f91AF4AE49\nGelatoRelayConcurrentERC2771.sol\nRelay method: callWithSyncFeeERC2771 with isConcurrent: true\nAddress: 0x8598806401A63Ddf52473F1B3C55bC9E33e2d73b\nGelatoRelay1Balance.sol\nRelay method: sponsoredCall\nAddress: 0x75bA5Af8EFFDCFca32E1e288806d54277D1fde99\nGelatoRelay1BalanceERC2771.sol\nRelay method: sponsoredCallERC2771\nAddress: 0xd8253782c45a12053594b9deB72d8e8aB2Fca54c\nGelatoRelay1BalanceConcurrentERC2771.sol\nRelay method: sponsoredCallERC2771 with isConcurrent: true\nAddress: 0xc65d82ECE367EF06bf2AB791B3f3CF037Dc0e816\nFeeCollector.sol\nAddress: 0x3AC05161b76a35c1c28dC99Aa01BEd7B24cEA3bf\nzkSync Era Mainnet / Testnet\nGelatoRelay.sol\nRelay method: callWithSyncFee\nAddress: 0xB16a1DbE755f992636705fDbb3A8678a657EB3ea\nGelatoRelayERC2771.sol\nRelay method: callWithSyncFeeERC2771\nAddress: 0x22DCC39b2AC376862183dd35A1664798dafC7Da6\nGelatoRelayConcurrentERC2771.sol\nRelay method: callWithSyncFeeERC2771 with isConcurrent: true\nAddress: 0xBa4082F4961c8Fb76231995C967CD9aa40f321b5\nGelatoRelay1Balance.sol\nRelay method: sponsoredCall\nAddress: 0x99a039d4F0e734aA8CcBE74C0FF9780BccD79f1d\nGelatoRelay1BalanceERC2771.sol\nRelay method: sponsoredCallERC2771\nAddress: 0x97015cD4C3d456997DD1C40e2a18c79108FCc412\nGelatoRelay1BalanceConcurrentERC2771.sol\nRelay method: sponsoredCallERC2771 with isConcurrent: true\nAddress: 0xB8828e4c662D1a7e4f3d1f622EfAE6B63D852ED8\nFeeCollector.sol\nAddress: 0x4626c5Bc8640396076D05D9f6D71d07E21BD6aDC\nShibarium Mainnet\nGelatoRelay.sol\nRelay method: callWithSyncFee\nAddress: 0xaBcC9b596420A9E9172FD5938620E265a0f9Df92\nGelatoRelayERC2771.sol\nRelay method: callWithSyncFeeERC2771\nAddress: 0xb539068872230f20456CF38EC52EF2f91AF4AE49\nGelatoRelayConcurrentERC2771.sol\nRelay method: callWithSyncFeeERC2771 with isConcurrent: true\nAddress: 0x8598806401A63Ddf52473F1B3C55bC9E33e2d73b\nGelatoRelay1Balance.sol\nRelay method: sponsoredCall\nAddress: 0x75bA5Af8EFFDCFca32E1e288806d54277D1fde99\nGelatoRelay1BalanceERC2771.sol\nRelay method: sponsoredCallERC2771\nAddress: 0xd8253782c45a12053594b9deB72d8e8aB2Fca54c\nGelatoRelay1BalanceConcurrentERC2771.sol\nRelay method: sponsoredCallERC2771 with isConcurrent: true\nAddress: 0xc65d82ECE367EF06bf2AB791B3f3CF037Dc0e816\nFeeCollector.sol\nAddress: 0x32E1CC9810D6051907004DC310BE2E42df33b199\nPrevious\nTracking your Relay Request\nNext\nPayment & Fees\nLast modified 1mo ago\nON THIS PAGE\nContract Addresses\nAll supported networks except zkSync Era and Shibarium\nzkSync Era Mainnet / Testnet\nShibarium Mainnet"
  },
  {
    "title": "API - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/api",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n📨\nAPI\nHow to communicate directly with the Gelato Relay API\nThe Gelato Relay API endpoint URL is https://api.gelato.digital/\nThe Swagger UI is located at https://api.gelato.digital/api-docs​\n​\nOracle queries\nGET\n/oracles\nGet list of chains where the oracle is available\nGET\n/oracles/{chainId}/estimate\nGet the estimated fee in payment token with respect to the gas limit and priority\nGET\n/oracles/{chainId}/paymentTokens\nGet all the payment tokens on a chain\nGET\n/oracles/{chainId}/conversionRate\nGet the conversion rate from the native token to the requested token\nRelay Endpoints\nInformational \nGET\n/relays/v2\nGet list of chains where relay v2 is available\nSending Relay Requests:\nEach relay request method possesses optional parameters such as the gasLimit , and retries. You can find more information on these on the Optional Parameters page.\n/call-with-sync-fee/: for more information, please click here.\nPOST\n/relays/v2/call-with-sync-fee\nPlace a relay v2 callWithSyncFee request\n/call-with-sync-fee-erc2771/: for more information, please click here.\nPOST\n/relays/v2/call-with-sync-fee-erc2771\nPlace a relay v2 callWithSyncFeeERC2771 request\n/sponsored-call/: for more information, please click here.\nPOST\n/relays/v2/sponsored-call\nPlace a relay v2 sponsoredCall request\n/sponsored-call-erc2771/: for more information, please click here.\nPOST\n/relays/v2/sponsored-call-erc2771\nPlace a relay v2 sponsoredCallERC2771 request\nTask Tracking\nGET\n/tasks/status/{taskId}\nGet task status of the relay v2 task id\nPrevious\nSyncFee Payment Tokens\nNext\nMigration Guide ethers.js v5 to v6\nLast modified 1mo ago\nON THIS PAGE\nOracle queries\nGET\n/oracles\nGET\n/oracles/{chainId}/estimate\nGET\n/oracles/{chainId}/paymentTokens\nGET\n/oracles/{chainId}/conversionRate\nRelay Endpoints\nGET\n/relays/v2\nPOST\n/relays/v2/call-with-sync-fee\nPOST\n/relays/v2/call-with-sync-fee-erc2771\nPOST\n/relays/v2/sponsored-call\nPOST\n/relays/v2/sponsored-call-erc2771\nTask Tracking\nGET\n/tasks/status/{taskId}"
  },
  {
    "title": "ERC2771 Migration Guide - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/erc2771-migration-guide",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n⏩\nERC2771 Migration Guide\nHow to migrate to the new Gelato Relay ERC2771 contracts\nThis only applies if you are using @gelatonetwork/relay-sdk v3 or contracts from the package @gelatonetwork/relay-context v2\nGelato Relay ERC2771 proxy contracts are immutable for security reasons. We have deployed new versions of our ERC2771 proxy contracts with enhanced security: GelatoRelayERC2771.sol and GelatoRelay1BalanceERC2771.sol, new addresses of which you can find here.\nTo support these new contracts, Relay Context Contracts found in the package @gelatonetwork/relay-context have been updated to version v3, along with the Gelato Relay SDK package @gelatonetwork/relay-sdk, which has been updated to version v4.\nGelato Relay continues to support ERC2771 contracts that inherit from the legacy @gelatonetwork/relay-context v2, so you can upgrade at your own convenience. Nevertheless we recommend you to upgrade as soon as possible to ensure optimal security, features and support.\nTo illustrate package and contract compatibility please refer to the following matrix:\nGelato Relay ERC2771 Contract\nrelay-sdk\nrelay-context\nLegacy GelatoRelayERC2771.sol: 0xBf175FCC7086b4f9bd59d5EAE8eA67b8f940DE0d\nv3\nv2\nGelatoRelayERC2771.sol: 0xb539068872230f20456CF38EC52EF2f91AF4AE49\nv4\nv3\nGelatoRelay1BalanceERC2771.sol: 0xd8253782c45a12053594b9deB72d8e8aB2Fca54c\nv4\nv3\nPlease note that contract addresses differ on zkSync Era. \nUsing @gelatonetwork/relay-sdk v3 with contracts inheriting from @gelatonetwork/relay-context v3, or using @gelatonetwork/relay-sdk v4 with contracts inheriting from @gelatonetwork/relay-context v2 won't work, as they refer to different Gelato Relay ERC2771 contracts.\nMigration steps\n1.\nIf you deployed contracts that inherit from @gelatonetwork/relay-context - update the package version and either upgrade or redeploy your contracts.\nIf you are using sponsoredCallERC2771 in combination with ERC2771Context.sol - make sure to use the new GelatoRelay1BalanceERC2771.sol contract address as the trustedForwarder which you can find here.\n2.\nIf you are using @gelatonetwork/relay-sdk - update the package version in your project.\n3.\nMake sure you use your newly upgraded/deployed contract addresses with the updated Gelato Relay SDK package.\nIf you cannot upgrade or redeploy your ERC2771-compatible contracts, please contact us to find a future-proof solution together.\nPrevious\nMigration Guide ethers.js v5 to v6\nNext\nJoin our Discord\nLast modified 4mo ago"
  },
  {
    "title": "Tracking your Relay Request - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/tracking-your-relay-request",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🕵\nTracking your Relay Request\nLearn how to check the status of your relay request\nWhen submitting your Gelato Relay requests, you'll receive a taskId in response. This taskId allows you to track the status of your request in two primary ways:\n1.\nWebsocket Subscriptions: This is the recommended and most efficient method. By subscribing via websocket, the Gelato backend will automatically push updates for all your tasks to your Relay SDK client. To start receiving these updates, you must register a callback function which will be triggered every time one of your tasks gets updated.\n2.\nPolling for Updates: Alternatively, you can periodically query the Gelato task status API for updates. If you're using the Gelato Relay SDK, the getTaskStatus method makes this easy.\nFor both methods, if you aren't using the Gelato Relay SDK package, you can still interact directly with the websocket or REST APIs, as detailed in the documentation linked here.\nWebsocket Subscriptions\nUsing Gelato Relay SDK\nSupport for Websocket Subscriptions was introduced in Gelato Relay SDK version 5.5.0, make sure to update your package.\nYou can subscribe to websocket updates by registering a callback handler function like this:\nimport { GelatoRelay, TransactionStatusResponse } from \"@gelatonetwork/relay-sdk\";\n​\nconst gelatoRelay = new GelatoRelay();\n​\ngelatoRelay.onTaskStatusUpdate((taskStatus: TransactionStatusResponse) => {\n  console.log(\"Task status update\", taskStatus);\n});\n​\nconst request: SponsoredCallRequest = {\n  chainId,\n  target, \n  data,\n};\n​\nconst response = await gelatoRelay.sponsoredCall(\n  request,\n  sponsorApiKey\n);\nUsing websocket API\nYou can interact with the websocket API directly by connecting to this endpoint:\nwss://api.gelato.digital/tasks/ws/status\nOnce connected, you can subscribe to updates using taskIds of your submitted tasks by sending messages like this:\n{\n    action: \"subscribe\",\n    taskId: \"0x...\"\n}\nTo unsubscribe from updates:\n{\n    action: \"unsubscribe\",\n    taskId: \"0x...\"\n}\nPolling for Updates\nUsing Gelato Relay SDK\nTo query the latest task status you can use the following method:\nimport { GelatoRelay } from \"@gelatonetwork/relay-sdk\";\n​\nconst gelatoRelay = new GelatoRelay();\n​\nconst request: SponsoredCallRequest = {\n  chainId,\n  target, \n  data,\n};\n​\nconst response = await gelatoRelay.sponsoredCall(\n  request,\n  sponsorApiKey\n);\n​\nconst taskStatus = await gelatoRelay.getTaskStatus(\n  response.taskId\n);\nQuerying from Gelato API\nhttps://api.gelato.digital/tasks/status/:taskId\nFor example, if your taskId returned from your Relay response is:\n{\n    taskId: 0x93a3defc618ff97c32a37bdd567b15c50748a5c3e8e858bca67f0c967b74a7fe\n}\nthen the URL to go to is:\nhttps://api.gelato.digital/tasks/status/0x93a3defc618ff97c32a37bdd567b15c50748a5c3e8e858bca67f0c967b74a7fe\nFor this taskId, here is the returned task information:\n{\n    \"task\": {\n        \"chainId\": 5,\n        \"taskId\": \"0x93a3defc618ff97c32a37bdd567b15c50748a5c3e8e858bca67f0c967b74a7fe\",\n        \"taskState\": \"ExecSuccess\",\n        \"creationDate\": \"2022-10-10T10:15:03.932Z\",\n        \"executionDate\": \"2022-10-10T10:15:28.718Z\",\n        \"transactionHash\": \"0x9d260d1bbe075be0cda52a3271df062748f3182ede91b3aae5cd115f7b26552b\",\n        \"blockNumber\": 7744557\n    }\n}\nTask Status Response\nThe task status response object has the following format:\ntype TransactionStatusResponse = {\n  chainId: number;\n  taskId: string;\n  taskState: TaskState;\n  creationDate: string;\n  lastCheckDate?: string;\n  lastCheckMessage?: string;\n  transactionHash?: string;\n  blockNumber?: number;\n  executionDate?: string;\n  gasUsed?: string;\n  effectiveGasPrice?: string;\n};\n​\nenum TaskState {\n  CheckPending = \"CheckPending\",\n  ExecPending = \"ExecPending\",\n  WaitingForConfirmation = \"WaitingForConfirmation\",\n  ExecSuccess = \"ExecSuccess\",\n  ExecReverted = \"ExecReverted\",\n  Cancelled = \"Cancelled\",\n}\nTask states\nFor the taskState key, these are the possible values:\nCheckPending: the relay request has been received by Gelato Relay (pending simulation).\nExecPending: the relay task is executable and is awaiting inclusion into the blockchain.\nWaitingForConfirmation: the task was included into the blockchain but is still awaiting the required amount of blocks confirmations.\nExecSuccess: the task has been successfully executed.\nCancelled: the task has been cancelled due to failed simulations or other errors. The error message will be shown in the lastCheckMessage key.\nExecReverted: the task transaction has been reverted.\nWhat if my task is cancelled?\nIf your task is cancelled, you can find your error message under the lastCheckMessage key, for example:\n{\n    \"task\": {\n        \"chainId\": 56,\n        \"taskId\": \"0x5f0200652404f9f113a757b4208984f7f4ca25754ddd5c49ca28330e72160c12\",\n        \"taskState\": \"Cancelled\",\n        \"creationDate\": \"2023-03-03T14:01:14.327Z\",\n        \"lastCheckDate\": \"2023-03-03T14:01:44.128Z\",\n        \"lastCheckMessage\": \"Execution error: GelatoRelay.sponsoredCall:root already sent\"\n    }\n}\nThe error message in this case refers to the target contract reverting with the message \"root already sent\" when being called by Gelato Relay's sponsoredCall function. If you get something similar and you are stuck on troubleshooting, please get in touch with us via Discord and ask in the relay channel! We will be sure to figure out what's going on.\nPrevious\nOptional Parameters\nNext\nNetworks & Rate Limits\nLast modified 2mo ago\nON THIS PAGE\nWebsocket Subscriptions\nUsing Gelato Relay SDK\nUsing websocket API\nPolling for Updates\nUsing Gelato Relay SDK\nQuerying from Gelato API\nTask Status Response\nTask states\nWhat if my task is cancelled?"
  },
  {
    "title": "Optional Parameters - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/optional-parameters",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n❔\nOptional Parameters\nWhat other options do you have?\nAll four main Relay SDK methods use the same optional parameters.\nOptional Parameters\nrelayRequestOptions is a type with the following properties:\ntype RelayRequestOptions = {\n  gasLimit?: BigNumberish;\n  retries?: number;\n};\ngasLimit: the gas limit of the relay call. This effectively sets an upper price limit for the relay call.\nIf you are using your own custom gas limit, please add a 150k gas buffer on top of the expected gas usage for the transaction. This is for the Gelato Relay execution overhead, and adding this buffer reduces your chance of the task cancelling before it is executed on-chain.\nIf your contract has any hardcoded requirements about gas usage, please always explicitly pass the gasLimit to the SDK/API, as Gelato will not know what hardcoded gas expectations your contract has. Otherwise, your relay requests might not be executable.\nretries: the number of retries that Gelato should attempt before discarding this relay call. This can be useful if the state of the target contract is not fully known and such reverts can not be definitively avoided. \nPrevious\nGelato's Fee Oracle\nNext\nTracking your Relay Request\nLast modified 1mo ago"
  },
  {
    "title": "Gelato's Fee Oracle - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/gelatos-fee-oracle",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n💰\nGelato's Fee Oracle\nHow to get a quote for your relay fee before sending the request\nAfter reading this page: \nYou'll understand how to query the fee oracle using either the SDK or the API directly and which methods/endpoints are available.\nYou'll learn the difference between different fee modalities and trade offs: for example, allowing your user to sign off on a maximum fee they are willing to pay helping account for gas volatility, or allowing them to sign off on the exact fee but with a higher risk of non-execution.\nYou can query our fee oracle before the relay request to get an overall estimated fee (gas costs + Gelato fee) for your relay request.\nQuerying via the SDK\nSDK method: isOracleActive\nconst isOracleActive = async (chainId: number): Promise<boolean>\nArguments:\nchainId: the chain ID of the network on which to check if the fee oracle is active.\nReturn Object: boolean\ntrue/false: depending on the status of the fee oracle on the requested network.\nSDK method: getPaymentTokens\nconst getPaymentTokens = async (chainId: number): Promise<string[]>\nArguments:\nchainId: the chain ID of the network where you want to check if the fee oracle is active there.\nReturn Object: string[]\nAn array of strings listing all accepted payment tokens on the requested network.\nSDK method: getEstimatedFee\nconst getEstimatedFee = async (\n  chainId: number,\n  paymentToken: string,\n  gasLimit: BigNumber,\n  isHighPriority: boolean,\n): Promise<BigNumber>\nArguments:\nchainId: the chain ID of the network where you want to check if the fee oracle is active there.\npaymentToken: the address of the token you would like to pay in.\ngasLimit: a custom gas limit for your transaction, please remember to add an overhead for Gelato Relay's contract calls and security checks, see here for more info.\nisHighPriority: EIP-1559 flag for increasing your priority gas fee. If true, you will incur higher costs but have a higher certainty of block inclusion.\nReturn Object: BigNumber​\nThe value of your estimated fee, including gas costs + gelato fee on top. \nNOTE:  please be aware that if your relayed transaction incurs gas refunds, for example, for clearing out storage slots, this is not known beforehand. These refunds can only be known after the fact, from the transaction receipts. This means that the fee oracle will give you a price which does not include the gas refunds, so it may be higher than you think. This is due to how the EVM works, and the initial gas allocated for execution should still be the total amount before refunds, otherwise you will get an 'Out of gas' error. See here for more info.\nQuerying via the API\nPlease see the available endpoints on the API page.\n​\nPrevious\nRelay Context Contracts\nNext\nOptional Parameters\nLast modified 4mo ago\nON THIS PAGE\nQuerying via the SDK\nSDK method: isOracleActive\nSDK method: getPaymentTokens\nSDK method: getEstimatedFee\nQuerying via the API"
  },
  {
    "title": "Non-ERC-2771 - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/non-erc-2771",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n3⃣\nsponsoredCall\n2⃣\ncallWithSyncFee\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🔧\nNon-ERC-2771\nPermissionless meta-transactions\nPlease proceed to our Security Considerations page and read it thoroughly before advancing with your implementation. It is crucial to understand all potential security risks and measures to mitigate them.\nIf you're not using ERC-2771, your users might have smart contract wallets, in which case you should have a look at Account Abstraction.\nGelato Relay offers two methods that don't implement ERC2771 signature verification:\n​sponsoredCall where gas fees are sponsored by a 1Balance account.\n​callWithSyncFee, where the target contract transfers gas fees using Relay Context Contracts.\nPlease exercise utmost caution when using the Gelato Relay without implementing ERC-2771 for authentication/authorization.\nWe highly recommend cross-checking with us on Discord if you believe your setup doesn't require the ERC-2771 user verification. We can help confirm whether your implementation is sufficiently secure.\nThere are specific use cases where the Gelato ERC-2771 implementation may not be necessary:\n1.\nIf your application or protocol already implements user signature/verification and has authentication/authorization mechanisms in place.\n2.\nApplications like Gnosis Safe multisigs, where a non-ERC2771 compliant signature mechanism is already established.\n3.\nIf your application does not require any access control and does not involve any fund transfers.\nPrevious\nRelay Context Contracts ERC2771\nNext\nsponsoredCall\nLast modified 4mo ago"
  },
  {
    "title": "ERC-2771 (recommended) - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/erc-2771-recommended",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n1⃣\nsponsoredCallERC2771\n2⃣\ncallWithSyncFeeERC2771\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🔏\nERC-2771 (recommended)\nNative meta transactions with top notch security\nIf you are using @gelatonetwork/relay-sdk v3 or contracts from the package @gelatonetwork/relay-context v2 please follow this migration guide to migrate to the new versions.\nAfter reading this page: \nYou'll understand the difference between sponsoredCallERC2771and callWithSyncFeeERC2771​\nYou'll understand how to use sponsoredCallERC2771 and callWithSyncFeeERC2771 in combination with ERC2771Context to achieve a gasless UX for your app, with secure user signature verification.\nYou'll understand ERC-2771's core functionality and how it allows for the off-chain sender address to be verified on-chain.\nRecommendation for using ERC-2771  \nAs detailed in the Security Considerations section, it's crucial to ensure that your relay implementation is impervious to vulnerabilities when using a relayer. The most secure approach is to utilize our ERC-2771 implementations: \n​sponsoredCallERC2771​\n​callWithSyncFeeERC2771​\nWhen using sponsoredCallERC2771, you sponsor your user's gas fees, leveraging 1Balance for payment. In contrast, with callWithSyncFeeERC2771, the fees are paid from the target contract.\nIn both instances, users are prompted to sign their transaction's relay request using their private keys (for instance, through MetaMask). This step is crucial for security purposes. Gelato verifies on-chain that the user's signature corresponds with the required address before forwarding the call.\nWhen relaying a message to a target smart contract function, it's essential for the function to authenticate the message's origin and confirm it was forwarded through the correct relayer. Without these verifications, your target function becomes susceptible to exploitation. ERC-2771 employs sophisticated data encoding to relay the original _msgSender from off-chain, and it guarantees that only the trustedForwarder is capable of encoding this value. These two parameters, in tandem, safeguard against any potential misconduct, ensuring a secure transmission of information from off-chain to on-chain!\nWhy is this important?\nIn the context of relaying, msg.sender loses its usual informational significance. Under normal circumstances, msg.sender would denote the user initiating the transaction; however, with off-chain relaying, we lose this valuable piece of information.\nConsider this scenario: how does a target smart contract determine who can call a particular function? In this case, msg.sender will be the relayer, but merely whitelisting this address is insufficient and still permits others using the same relayer to call your function. This situation can raise significant concerns, particularly when low-level calls are involved.\nThe optimal solution would be to allow the initiator of the relay call to specify an address and relay this address on-chain. The target smart contract can then authenticate a function call using this address.\nThe challenge then becomes: how can we successfully transmit information (a specific address) via low-level calldata from off-chain to on-chain without disrupting the calldata's integrity?\nCore Functionality of ERC-2771\nHere's where the real magic unfolds. The trustedForwarder encodes the from address (i.e., the off-chain address) into the calldata by appending it at the end:\n1\n(bool success, ) = to.call.value(value)(abi.encodePacked(data, from));\nNow, the target contract can validate the from address by decoding the data in the same manner, ensuring that this message has been passed through the trustedForwarder.\nThe necessary target contract function can then confidently confirm that the correct entity signed and requested this payload to be relayed, and only via a trusted forwarder - in our case, the Gelato Relay.\nHow does Gelato encode this data?\nLet's take as an example relay method sponsoredCallERC2771. Method callWithSyncFeeERC2771 works similarly.\nGelato Relay's sponsoredCallERC2771 function encodes the user's address, which can then be utilized by the ERC-2771 compatible target smart contract.  The most relevant part, where the user address is appended to the calldata, is shown below:\nGelatoRelay1BalanceERC2771.sol\n1\n_call.target.revertingContractCall(\n2\n    _encodeERC2771Context(_call.data, _call.user),\n3\n    \"GelatoRelay1BalanceERC2771.sponsoredCallERC2771:\"\n4\n);\nwhere _encodeERC2771Context refers to:\nGelatoRelayUtils.sol\n1\nfunction _encodeERC2771Context(bytes calldata _data, address _msgSender)\n2\n    pure\n3\n    returns (bytes memory)\n4\n{\n5\n    return abi.encodePacked(_data, _msgSender);\n6\n}\nWe are encoding the calldata and the user address together by simply appending the user's address to the end as required by ERC-2771.\nHow can I modify my smart contract to be ERC-2771 compatible?\nLet's take a look at an example using relay method sponsoredCallERC2771. For callWithSyncFeeERC2771 please refer to the steps described here.\n1. Install Gelato's relay-context package in your contract repo\nSee also relay-context-contracts: Installation​\nnpm install --save-dev @gelatonetwork/relay-context\nor\nyarn add -D @gelatonetwork/relay-context\n2. Import the ERC2771Context contract:\n1\nimport {\n2\n    ERC2771Context\n3\n} from \"@gelatonetwork/relay-context/contracts/vendor/ERC2771Context.sol\";\nThis contract's main functionality (originally implemented by OpenZeppelin) is to decode the off-chain msg.sender from the encoded calldata using _msgSender() . \nERC2771Context.sol\n1\n// SPDX-License-Identifier: MIT\n2\n// OpenZeppelin Contracts (last updated v4.7.0) (metatx/ERC2771Context.sol)\n3\n​\n4\npragma solidity ^0.8.9;\n5\n​\n6\nimport \"../utils/Context.sol\";\n7\n​\n8\n/**\n9\n * @dev Context variant with ERC2771 support.\n10\n */\n11\nabstract contract ERC2771Context is Context {\n12\n    address private immutable _trustedForwarder;\n13\n    \n14\n    constructor(address trustedForwarder) {\n15\n        _trustedForwarder = trustedForwarder;\n16\n    }\n17\n​\n18\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n19\n        return forwarder == _trustedForwarder;\n20\n    }\n21\n​\n22\n    function _msgSender() internal view virtual override returns (address sender) {\n23\n        if (isTrustedForwarder(msg.sender)) {\n24\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n25\n            /// @solidity memory-safe-assembly\n26\n            assembly {\n27\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n28\n            }\n29\n        } else {\n30\n            return super._msgSender();\n31\n        }\n32\n    }\n33\n​\n34\n    function _msgData() internal view virtual override returns (bytes calldata) {\n35\n        if (isTrustedForwarder(msg.sender)) {\n36\n            return msg.data[:msg.data.length - 20];\n37\n        } else {\n38\n            return super._msgData();\n39\n        }\n40\n    }\n41\n}\nThe trustedForwarder variable is set in the constructor which allows for setting a trusted party that will relay your message to your target smart contract. In our case, this is Gelato Relay1BalanceERC2771.sol which you can find in the contract addresses section.\nThe _msgSender() function encapsulates the main functionality of ERC-2771, by decoding the user address from the last 20 bytes of the calldata. \nIn Solidity, the logic is equivalent to:\n1\nabi.decode(\n2\n    msg.data[msg.data.length - 20:],\n3\n    (address)\n4\n);\nGelato's smart contracts handle the encoding of important information to the calldata (see How does Gelato encode this data?). It is the job of your target smart contract function to decode this information using this _msgSender() function. \nThe function  _msgData() removes the msg.sender from the entire calldata if the contract was called by the trustedForwarder, or otherwise falls back to return the original calldata.\n3. Replace msg.sender with _msgSender()\nWithin the function that you would like to be called with Gelato Relay, replace all instances of msg.sender with a call to the _msgSender() function inherited from ERC2771Context. _msgSender() is the off-chain signer of the relay request, allowing for secure whitelisting on your target function. \n4. (Re)deploy your contract and whitelist GelatoRelay1BalanceERC2771\nIf your contract is not upgradeable, then you will have to redeploy your contract to set GelatoRelay1BalanceERC2771.sol as your trustedForwarder:\nGelatoRelay1BalanceERC2771.solis immutable for security reasons. This means that once you set GelatoRelay1BalanceERC2771.sol as your trusted forwarder, there is no way for Gelato to change the ERC2771 signature verification scheme and so you can be sure that the intended _msgSender is correct and accessible from within your target contract.\nPlease refer to the contract addresses section to find out which Gelato relay address to use as a trustedForwarder. Use GelatoRelay1BalanceERC2771.sol address for sponsoredCallERC2771.\nPrevious\nQuick Start\nNext\nsponsoredCallERC2771\nLast modified 4mo ago\nON THIS PAGE\nRecommendation for using ERC-2771\nWhy is this important?\nCore Functionality of ERC-2771\nHow does Gelato encode this data?\nHow can I modify my smart contract to be ERC-2771 compatible?\n1. Install Gelato's relay-context package in your contract repo\n2. Import the ERC2771Context contract:\n3. Replace msg.sender with _msgSender()\n4. (Re)deploy your contract and whitelist GelatoRelay1BalanceERC2771"
  },
  {
    "title": "Quick Start - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/quick-start",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🌠\nQuick Start\nGelato Relay, as easy as 0xabc...\nPlease see here for supported networks and contract addresses.\nAfter reading this page:\nYou'll go through a decision process to understand the best way to integrate with Gelato Relay.\nYou'll know exactly which SDK/API method is for you.\nDepending on your final destination, please click the corresponding link to find about your chosen SDK method:\n​sponsoredCallERC2771​\n​callWithSyncFeeERC2771​\n​sponsoredCall​\n​callWithSyncFee​\nOption 1: Your users pay for for their own gas\nIf you do not want to sponsor your user's gas, you will use the callWithSyncFeeERC2771 or callWithSyncFee SDK method with the SyncFee payment method. This will require you to deploy a new contract (or upgrade if you can) to be compatible with Gelato's relay context contracts.\nOption 2: Sponsoring some/all of your users' gas\nSponsoring some of your user's gas:\nGelato Relay allows for partial sponsoring of gas based on certain conditions with developer-defined rules! For example, an app could sponsor user's gas based on a certain NFT being present in their wallet, or perhaps the NFT allows the user to have 10 gasless transactions a day. As a sponsor, you will able to customize with Gelato Relay's sponsor dashboard, coming soon™.\nSponsoring all of your user's gas: \nGelato handles user signature verification: go ahead and use sponsoredCallERC2771 where Gelato handles user signature verification for you. In this method, you can use ERC-2771's _msgSender() to validate your relay calls on-chain. This will require an upgrade to your target contract for ERC2771Context support, if it does not support it already.\nYou handle user signature verification: If your app workflow already handles its security in-house (i.e. use of user signatures, replay/reentrancy protection etc.) and you do want to sponsor all of your user's gas, you are ready to use Gelato Relay without any change to your existing smart contract logic. This will be using the sponsoredCall method.\nPrevious\nTemplates\nNext\nERC-2771 (recommended)\nLast modified 4mo ago\nON THIS PAGE\nOption 1: Your users pay for for their own gas\nOption 2: Sponsoring some/all of your users' gas"
  },
  {
    "title": "Templates - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/templates",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n📜\nTemplates\nGet started with Gelato Relay in seconds\nFoundry Template\nGitHub - gelatodigital/gelato-relay-foundry-template\nGitHub\nHardhat Template\nGitHub - gelatodigital/relay-example-unit-tests: Relay Examples with Unit tests\nGitHub\nPrevious\nInstallation\nNext\nQuick Start\nLast modified 2mo ago\nON THIS PAGE\nFoundry Template\nHardhat Template"
  },
  {
    "title": "Security Considerations - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/security-considerations",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🔒\nSecurity Considerations\nEssential reading to safeguard your contracts\nAfter reading this page:\nYou will understand the security risks associated with using a Relayer.\nYou will learn strategies for safeguarding your contracts effectively.\nYou will be exposed to an example of a contract that is susceptible to exploitation.\nPotential Security Risk in Relayer Authentication\nA relayer is responsible for dispatching a transaction to an external or public contract method. Given the public nature of this method, it is accessible for invocation by any third party. So, how can we ascertain the legitimacy of the party executing this method?\nIn certain implementations, we have observed an approach that utilizes a mechanism to ensure that solely the Gelato Relay is authorized to call the contract. This mechanism employs a modifier, known as onlyGelatoRelay. This modifier verifies that the transaction's msg.sender is the GelatoRelay contract. However, it's crucial to note that this form of validation does not offer protection from potential malevolent third parties leveraging the relayer to compromise your contract.\n🚨 Additional authentication is required to safeguard your contracts!\nTo ensure robust security for your contracts, additional layers of authentication are indispensable. We urge you to adhere to our tried and tested security best practices. These guidelines have been designed to efficiently manage and mitigate security risks. Let's dive in!\n✅  Battle Tested Best Practice\nThe most prevalent method to authenticate users within the web3 ecosystem relies on the ERC-2771 standard and EIP-712 signature. Gelato offers convenient helper contracts that facilitate the verification and decoding of the user's signature, thereby ensuring that the user initiating the transaction is indeed legitimate.\nGelato's SDK provides two methods that implement the ERC-2771 standard behind the scenes:\n1.\nsponsoredCallERC2771\n2.\ncallWithSyncFeeERC2771\nIn both instances, Gelato offers built-in methods to decode the msg.sender and msg.data, substituting these with _msgSender() and _msgData(), respectively.\nWe strongly advocate for the use of Gelato's built-in ERC-2771 user signature verification contracts, coupled with the onlyGelatoRelay modifier. This combination offers a robust level of security and helps safeguard your contracts against potential threats.\nAddressing the Risk of Relayer Fee Payment\nGelato Relayer can be used in various ways. Among these, two specific methods exist: callWithSyncFeeERC2771 and callWithSyncFee. In these, the target contract is responsible for transferring the fees to the feeCollector.\nGelato provides Relay Context Contracts, which include helper methods that simplify the extraction process for feeCollector, fee, and feeToken. The fees are transferred by invoking the _transferRelayFee() method.\n// DANGER! Only use with onlyGelatoRelay or `_isGelatoRelay` before transferring\nfunction _transferRelayFee() internal {\n    _getFeeToken().transfer(_getFeeCollector(), _getFee());\n}\nThe following code sample illustrates how feeCollector is extracted from the callData:\nuint256 constant _FEE_COLLECTOR_START = 72; // offset: address + address + uint256\n​\n// WARNING: Do not use this free fn by itself, always inherit GelatoRelayContext\n// solhint-disable-next-line func-visibility, private-vars-leading-underscore\nfunction _getFeeCollectorRelayContext() pure returns (address feeCollector) {\n    assembly {\n        feeCollector := shr(\n            96,\n            calldataload(sub(calldatasize(), _FEE_COLLECTOR_START))\n        )\n    }\n}\nThis snippet lacks a built-in security check or protective measure; it simply extracts the feeCollector from the callData. \n🚨 Without additional safeguards, this implementation is susceptible to Miner Extractable Value (MEV) front running. \nTherefore, any external actor could potentially call the target contract and encode their addresses as feeCollector.\nGiven these risks, it is absolutely essential to implement the following security best practices. 👇🏻\n✅  Battle Tested Best Practice\nAlongside implementing the Relay Context Contracts, it's crucial to verify that the msg.sender of the transaction is the GelatoRelay address before executing fee transfers.\n// Using onlyGelatoRelay modifier\nfunction targetMethod() external onlyGelatoRelay {\n    ...\n    // If you are not using ERC-2771 remember to authenticate all \n    // on-chain relay calls to your contract's methods even if you \n    // identify GelatoRelay as the msg.sender\n    // The following pseudocode signifies an authentication procedure\n    _yourAuthenticationLogic();\n​\n    // Payment to Gelato\n    _transferRelayFee();\n    ...\n}\n​\n// Or alternatively using _isGelatoRelay(address _forwarder) method\nfunction targetMethod() external {\n    ...\n    // If you are not using ERC-2771 remember to authenticate all \n    // on-chain relay calls to your contract's methods even if you \n    // identify GelatoRelay as the msg.sender\n    // The following pseudocode signifies an authentication procedure\n    _yourAuthenticationLogic();\n        \n    if (_isGelatoRelay(msg.sender)) {\n        // Payment to Gelato\n        _transferRelayFee();\n    }\n    ...\n}\n✅ Additional Security Layer\nThe aforementioned best practice ensures protection from front-running and unauthorized third-party fund drains. However, if your use case demands heightened control over the fees, you can further minimize risk by introducing a maxFee into your function using the method _transferRelayFeeCapped(uint256 maxFee).\n// Using onlyGelatoRelay modifier\nfunction targetMethod() external onlyGelatoRelay {\n    ...\n    // If you are not using ERC-2771 remember to authenticate all \n    // on-chain relay calls to your contract's methods even if you \n    // identify GelatoRelay as the msg.sender\n    // The following pseudocode signifies an authentication procedure\n    _yourAuthenticationLogic();\n​\n    // Payment to Gelato\n    _transferRelayFeeCapped(maxFee);\n    ...\n}\n​\n// Or alternatively using _isGelatoRelay(address _forwarder) method\nfunction targetMethod() external {\n    ...\n    // If you are not using ERC-2771 remember to authenticate all \n    // on-chain relay calls to your contract's methods even if you \n    // identify GelatoRelay as the msg.sender\n    // The following pseudocode signifies an authentication procedure\n    _yourAuthenticationLogic();\n        \n    if (_isGelatoRelay(msg.sender)) {\n        // Payment to Gelato\n        _transferRelayFeeCapped(maxFee);\n    }\n    ...\n}\nFor more detailed information on utilizing _transferRelayFeeCapped(uint256 maxFee), please consult our comprehensive guide here.\nExample of a Poor and Insecure Implementation\nThe VeryDummyWallet in the following example gives the impression of being a well-constructed implementation of the Gelato Relay, since it:\nInherits the GelatoRelayContext\nImplements the onlyGelatoRelay modifier\nTransfers the fees using the built-in method _transferRelayFee()\nHowever, this contract has a critical flaw: any user can create a request by calling the Gelato Relay and passing any \"to\" address to the sendToFriend() method. This contract does not implement any form of user authentication or authorization, making it susceptible to exploitation.\n \n🚨🚨🚨 WARNING: THIS IS A BAD EXAMPLE. DO NOT REPLICATE 🚨🚨🚨\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n​\nimport {\n    GelatoRelayContext\n} from \"@gelatonetwork/relay-context/contracts/GelatoRelayContext.sol\";\n​\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n​\ncontract VeryDummyWallet is GelatoRelayContext {\n    // `sendToFriend` is the target function to call\n    // this function uses this contract's mock ERC-20 balance to send\n    // an _amount of tokens to the _to address.\n    function sendToFriend(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) external onlyGelatoRelay {\n        // payment to Gelato\n        _transferRelayFee();\n​\n        // transfer of ERC-20 tokens\n        SafeERC20.safeTransfer(IERC20(_token), _to, _amount);\n    }\n}\n​\n​\nPrevious\nWhat is Relaying?\nNext\nInstallation\nLast modified 2mo ago\nON THIS PAGE\nPotential Security Risk in Relayer Authentication\nAddressing the Risk of Relayer Fee Payment\nExample of a Poor and Insecure Implementation"
  },
  {
    "title": "Installation - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/installation",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🚀\nInstallation\nNow we're cooking with gas...\n@gelatonetwork/relay-sdk package v5 and above is using ethers v6. If you are using @gelatonetwork/relay-sdk v4 or below, please follow this migration guide to migrate from ethers v5 to v6.\n\nIf you are using @gelatonetwork/relay-sdk v3 or contracts from the package @gelatonetwork/relay-context v2 please follow the ERC2771 Migration guide to migrate to the new versions.\nRelay-SDK\nnpm: @gelatonetwork/relay-sdk\nnpm\nNote: please make sure to use version v4.0.0 and above.\nnpm install @gelatonetwork/relay-sdk\nor\nyarn add @gelatonetwork/relay-sdk\nPrevious\nSecurity Considerations\nNext\nTemplates\nLast modified 4mo ago"
  },
  {
    "title": "What is Relaying? - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/what-is-relaying",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n📨\nWhat is Relaying?\nUnderstanding the benefits of relaying and how it can help your dApp thrive\nAfter reading this page: \nYou'll understand the context shift between standard transactions and relayed transactions.\nYou'll know the ways relaying can help improve UX.\nYou'll know exactly why Gelato Relay is the relayer you should integrate with.\nYou'll know what meta transactions are and how EIP-712 signatures work.\nPlease visit our page Security Considerations and read carefully before moving forward.\nStandard transactions\nIn a standard Ethereum transaction, an ethereum user signs and sends the transaction themselves. This user controls the private key to an externally owned account (EOA) which they can use to sign   a transaction and prove they have the right to spend the balance associated with that account address. \nFor each transaction a user sends, there is an associated transaction fee, known as gas. Since Ethereum executes computation, each unit of computation has an associated gas cost, which deters malicious actors from overloading the network by requiring them to pay heavily for a potential attack. This is excellent news for Ethereum's security and helps keep the network consistent under load, but it comes at a hidden cost for onboarding new users.\nOnboarding issues\nHow does a new user start interacting with exciting on-chain applications like DeFi, NFTs, or gaming? They will always need the native token to pay for gas on every network, even if the network has very cheap gas fees like Polygon. This requires the user to open an account at a centralised exchange, go through KYC, and buy crypto using fiat. This can be quite a process, even for the most skilled of degens out there, and it can deter new users from being onboarded to a dApp by increasing the latency between their initial excitement and the time it takes to actually get started.\nThis is where relaying comes in! A relayer can help solve these issues by sending a transaction on behalf of the user. \nWhat is a relayer?\nWe allow the user to send a transaction without a native token balance (it turns out relayers can be super nifty in loads of ways, for example, allowing a user who wants to swap a token to pay for the gas using the token being swapped!). Ideally, we would also like to still utilise the excellent security of a user signature, but for the transaction to be sent by a different EOA, one controlled by a relayer, who abstracts gas payment away from the user.\nThis is a very import context shift to understand. We have shifted from a user signing and sending a transaction themselves, to a user signing a standardised message and passing that on to a relayer. This relayer will, first, verify the user's signature for security, and then pass their message along on-chain. Gelato Relay does exactly this by taking a user's message off-chain and subsequently building a meta-transaction which is executed on chain.\nWhat is Gelato Relay?\nUsing Gelato Relay, we relay your user's transactions on-chain, enabling secure gasless transactions for an ultra smooth UX for your app. This allows for a variety of new web3 experiences, as the user can now pay by only signing a message, or their transaction costs can be sponsored by the developer. As long as the gas costs are covered in one of the multiple payment methods that Gelato supports, we handle the rest reliably, quickly and securely. \nWhat is a meta transaction?\nA meta transaction is a regular ethereum transaction which contains the actual message to be delivered on-chain to a target contract within itself, hence the term meta.  The outer transaction helps facilitate the first on-chain call which is sent by a relayer. The call is forwarded to the target contract using an intermediate smart contract (Gelato Relay), which in turn forwards the call using the inner transaction to deliver the relayed message. \nEIP-712 signatures\nTo achieve gasless transactions securely, Gelato Relay makes use of the EIP-712 standard. EIP-712 allows for a standardised way to sign and hash typed structured data. This means the user can sign a message using their wallet without incurring a gas cost or interacting with the chain at all, and this signature can be verified on-chain, by the relayer, facilitating a gasless transaction with security built in. This message will include important information such as the transaction signer address, the target contract address, and the calldata payload used to target a specific function.\n​\nServices - Previous\nRelay\nNext\nSecurity Considerations\nLast modified 4mo ago\nON THIS PAGE\nStandard transactions\nOnboarding issues\nWhat is a relayer?\nWhat is Gelato Relay?\nWhat is a meta transaction?\nEIP-712 signatures"
  },
  {
    "title": "Templates & Examples - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/account-abstraction/templates-and-examples",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nTemplates & Examples\nGet started with the Bundler & Paymaster in seconds\nZeroDev Template\nGitHub Repo implementing Gelato + ZeroDev to gaslessly deploy a Smart Wallet and increment a counter. The repo contains a quick start guide in the README. To generate a 1Balance API Key, please refer to 1Balance & Relay.\nThe example uses a maxFeePerGas=0 override which allows transaction fees to be accurately settled post-execution rather than by the EntryPoint.\nThis reduces our on-chain footprint leading to gas savings and avoids overcharging users (e.g., preVerificationGas).\nGitHub - gelatodigital/erc4337-counter-example\nGitHub\nPrevious\nAdvantages & Highlights\nNext\nBundler API Endpoints\nLast modified 2mo ago"
  },
  {
    "title": "Bundler API Endpoints - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/account-abstraction/bundler-api-endpoints",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\neth_sendUserOperation\neth_estimateUserOperationGas\neth_getUserOperationByHash\neth_getUserOperationReceipt\neth_supportedEntryPoints\neth_maxPriorityFeePerGas\neth_chainId\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nBundler API Endpoints\nList of all supported ERC-4337 Bundler JSON-RPC methods.\nGelato bundlers are ERC-4337 compliant and implement the following JSON-RPC methods as outlined in the specification.\n​eth_sendUserOperation​\n​eth_estimateUserOperationGas​\n​eth_getUserOperationByHash​\n​eth_getUserOperationReceipt​\n​eth_supportedEntryPoints​\n​eth_maxPriorityFeePerGas​\n​eth_chainId​\nPrevious\nTemplates & Examples\nNext\neth_sendUserOperation\nLast modified 2mo ago"
  },
  {
    "title": "Join our Discord - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/join-our-discord",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n✍\nJoin our Discord\nJoin the Gelato fam.\nIf you have any feedback or questions,  please join our Discord! 🚀\nPrevious\nERC2771 Migration Guide\nNext - Services\nWeb3 Functions\nLast modified 8mo ago"
  },
  {
    "title": "1Balance & Relay - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/payment-and-fees/1balance-and-relay",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n1⃣\n1Balance & Relay\n2⃣\nSyncFee Payment Tokens\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n1⃣\n1Balance & Relay\nHow to use Gelato's 1Balance for all your relaying needs\nPlease go to https://app.gelato.network/1balance and log in with your wallet. Deposit gETH for testnets via Goerli, or USDC on Polygon for production networks and generate an API key based on your needs. Once you have your API key, you are ready to send sponsoredCall and sponsoredCallERC2771 requests.\nYou will have to generate two separate API keys if using both testnets and production i.e. one API key for testnets, one API key for production networks.\nGelato 1Balance is a new flexible and bespoke payment system built from the ground up exclusively for Gelato customers. Gelato 1Balance allows for customers to deposit on any chain they prefer, whilst using that balance to cover their relay costs regardless of target chain.\nHow does 1Balance work?\nFor example, a user can top up their Gelato 1Balance using USDC on Polygon. This USDC balance will now be used to cover all gas costs and fees for any relay call, regardless of the underlying chain.  \nTherefore, a user could request relay calls on Ethereum mainnet, and Gelato will query their 1Balance to see if they possess enough equivalent USDC to cover the costs for this call.  If the balance is sufficient, Gelato will go ahead and relay the message on-chain. \nAfter the transaction is successful, Gelato can use the transaction receipts to charge you exactly the amount that the transaction costs plus a nominal fee. This makes Gelato 1Balance much more friendly on your wallet than payment based on a priori gas simulation which can be uncertain at best, and lead to consistent overcharging in the worst case.\nHow can I use 1Balance?\nGelato 1Balance is live for both testing and production networks. \nTesting\nYou can deposit gETH on Goerli to cover any transactions across all supported Testnets.\nProduction\nYou can deposit USDC on Polygon to cover any transactions across all supported Mainnets.\n1.\nGo to https://app.gelato.network/1balance and log in with your wallet. Make sure to be connected to the Goerli network for testing or Polygon for production networks.  You will have to generate two separate API keys if using both testnets and production i.e. one API key for testnets, one API key for production networks.\n2.\nDeposit gETH/USDC using the 1Balance tab.\n3.\nCreate a Relay App, under the Relay tab:\nGive your target contract address, or use the any contract address. \nIf your contract is not verified via Etherscan, paste in a manual ABI to specify which function you want to call using relay.\n4.\nOnce you have successfully created a relay app, you can go ahead and copy your API key, which will be valid across all testnets for sponsoredCall, and sponsoredCallERC2771.\nPrevious\nPayment & Fees\nNext\nSyncFee Payment Tokens\nLast modified 1mo ago\nON THIS PAGE\nHow does 1Balance work?\nHow can I use 1Balance?\nTesting\nProduction"
  },
  {
    "title": "Advantages & Highlights - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/account-abstraction/advantages-and-highlights",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nAdvantages & Highlights\nThe Gelato bundler & paymaster take a new approach to ERC-4337 and offer various advantages whilst remaining fully compatible with other implementations.\nAll major EVM-compatible networks are supported, including all Gelato Rollups.\n​1Balance paymaster sponsors operations across all networks with just a single deposit. This allows for easier accounting & management of funds as well as increased transparency.\nTransaction fees are settled post-execution so users are charged exact amounts and not overcharged like is common with other bundlers (e.g., preVerificationGas).\nCheaper transactions due to not incurring on-chain paymaster and fee transfer overhead.\nInstant inclusion as there is no need to wait for other UserOperations to form a bundle.\nMeV Protection as all transactions on Ethereum Mainnet are executed through Flashbots.\nSmart Accounts have unlimited freedom during validation & execution - no blacklisted opcodes or restrictive gas limits. This enables more elaborate signature verification and authentication logic.\nBuilt on top of the existing Relay infrastructure which is battle-tested and scalable.\nThe key difference between Gelato and other bundlers is that no EntryPoint deposit or on-chain paymaster is required. Instead, 1Balance settles transaction fees post-execution across all supported networks.\nThis avoids per-chain user deposits and ensures that the exact amount of gas consumed is charged with 100% accuracy. This is possible by setting maxFeePerGas=0 so that the EntryPoint doesn't require any fee payment (requiredPrefund=0).\nPrevious\nSupported Networks\nNext\nTemplates & Examples\nLast modified 1mo ago"
  },
  {
    "title": "Supported Networks - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/account-abstraction/supported-networks",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nSupported Networks\nThe following networks are supported in addition to all Gelato Rollups.\nName\nDeployment\nEthereum\nMainnet\nGoerli\nSepolia\nOptimism\nMainnet\nGoerli\nSepolia\nPolygon\nMainnet\nMumbai\nAvalanche\nMainnet\nBinance Smart Chain\nMainnet\nArbitrum\nMainnet\nGoerli\nSepolia\nBase\nMainnet\nGoerli\nPolygon zkEVM\nMainnet\nTestnet\nLinea\nMainnet\nGoerli\nGnosis\nMainnet\nChiado\nZora\nMainnet\nIf you don't see a network that you'd like supported, feel free to reach out to us.\nServices - Previous\nAccount Abstraction\nNext\nAdvantages & Highlights\nLast modified 1mo ago"
  },
  {
    "title": "Payment & Fees - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay/payment-and-fees",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n1⃣\n1Balance & Relay\n2⃣\nSyncFee Payment Tokens\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n💸\nPayment & Fees\nHow can you pay for your relayed transactions?\nPayment Methods\n1Balance\nSupported SDK methods: see sponsoredCall, sponsoredCallERC2771​\nGelato 1Balance is a new flexible and bespoke payment system built from the ground up exclusively for Gelato customers. Gelato 1Balance allows for customers to deposit on any supported, whilst using that balance to cover their relay costs regardless of target chain.\nNetworks & Tokens supported\nTestnets: Deposit gETH on Goerli to cover transactions across all supported Testnets.\nMainnets: Deposit USDC on Polygon to cover transactions across all supported Mainnets.\nFor more information, please see 1Balance.\nSyncFee\nSupported SDK methods: see callWithSyncFee​\nSyncFee is the simplest way to pay, but it delegates all security (reentrancy/replay protection etc.) and payment logic to the target smart contract. You can use ERC-2771 to achieve out-of-the-box security and authentication. Relay costs are covered in either native or ERC-20 tokens and they are paid synchronously during the relay call. \n\nPlease visit SyncFee Payment Tokens for the full list of supported tokens per network.\nGelato's Fees \nGelato charges a fixed percentage fee of the relayed transactions' total gas cost.\nTable 1 - Fee premiums as a percentage of total gas cost per network. The same premium applies to respective network testnets.\nNetwork\nPercentage Premium (%)\nEthereum\n10\nPolygon\n10\nBNB\n10\nAvalanche\n10\nArbitrum\n10\nOptimism\n10\nGnosis\n10\nBase\n10\nLinea\n10\nPolygon zkEVM\n10\nzkSync Era\n10\nZora\n10\nShibarium\n10\n​\nPrevious\nNetworks & Rate Limits\nNext\n1Balance & Relay\nLast modified 3mo ago\nON THIS PAGE\nPayment Methods\n1Balance\nSyncFee\nGelato's Fees"
  },
  {
    "title": "Subscription Notifications - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/1balance/subscription-notifications",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\n1Balance Alerts\nSubscription Plans\nSubscription Notifications\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nSubscription Notifications\nGet upcoming payment and renewal notifications via email\nAdding your Email Address\n1.\nSign In: Access your account by logging in with your wallet.\n2.\nNavigate to Settings: Look for the 'Settings' option within the platform interface. It is typically symbolized by a gear icon.\n\n\n3.\nEmail Configuration: Within 'Settings', switch to the 'Notifications' tab where you can add or edit your email address.\n\n\nVerify your email\nAfter entering your email you should receive a verification email from noreply@gelato.digital asking you to verify your address. \nOn confirmation you will receive a welcome email informing you that you will start to receive notifications.\n\n\nAvailable notifications\nYou will be notified when:\nAn upcoming subscription payment is due\nA subscription has been successfully renewed\nIf there has been an issue renewing your subscription\nRenewal has not been possible and your subscription has been downgraded\nWe will be expanding the range of notifications available.\nStopping notifications\nThe best way to stop notifications is to go to your notifications settings and delete your email. \nYou can also use the unsubscribe links in your emails but note that if you do this and then try to reactivate it you will need to notify us to remove you from the suppression list. \nPrevious\nSubscription Plans\nNext - Services\nAccount Abstraction\nLast modified 1mo ago\nON THIS PAGE\nAdding your Email Address\nVerify your email\nAvailable notifications\nStopping notifications"
  },
  {
    "title": "1Balance Alerts - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/1balance/1balance-alerts",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\n1Balance Alerts\nSubscription Plans\nSubscription Notifications\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n1Balance Alerts\nGet alerted when your balance is running low\nGet alerted when your balance is running low. If you are utilizing Gelato 1Balance, you can subscribe to a real-time alerting system that uses Email, Telegram or Discord to inform you when your 1Balance funds drop below a specified threshold.\nEmail \nYou can opt-in for email notifications. This feature ensures you are promptly informed when your balance falls below a specified minimum threshold, allowing you to take immediate action to replenish your funds.\nTo receive low balance alerts via email, ensure your email address is verified in the settings. You can set up alerts to be sent when your balance is low by toggling the feature in the 'Low Balance Alerts' section and defining the minimum balance.\nAlert received that balance has dropped below 4.9 USDC\nAdditional Alert Triggers\nThe system will send out alerts not only for low balances but also when:\nYour balance reaches zero.\nShould your account enter overdraft.\nWhen the allotted overdraft amount is fully utilized.\nTelegram\nDM GelatoWatcherBot on Telegram. \nChoose from the list of commands below.\nCommand\nUsage\n /balance\nThis command initiates the balance alert system on Telegram. After entering this command, the bot will start sending alerts for your balance.\n/1balance_threshold\nThis command allows you to configure the balance threshold. The bot will ask for a token and a threshold value. Respond with a comma-separated input in the form (TOKEN, THRESHOLD). For example, USDC,100 sets a threshold of 100 for USDC.\n/list_threshold\nThis command lists all your set thresholds.\n/stop_balance\nThis command stops the balance alert system. If you wish to stop receiving balance alerts, enter this command.\nDiscord server\nAdd Gelato Bot to your server using this invite link (you need to be the admin of the server)\nIf you want to receive notifications in a private channel, make sure to add Gelato Bot as a member in the channel where you want to receive the notification.\nEnter the following commands in the channel you want to receive alerts.\nCommand\nUsage\n/balance-channel address\nThis command initiates the balance alert system on your Discord server. Replace address with the address you want to set up alerts for.\n/1balance-threshold-channel token threshold\nThis command allows you to configure the balance threshold. Replace token and threshold with the respective token and threshold value.\n/list-threshold-channel\nThis command lists all your set thresholds.\n/stop-balance-channel\nThis command stops the balance alert system. If you wish to stop receiving balance alerts, enter this command.\nDiscord Direct Message (DM)\nJoin our Gelato Discord server​\nChoose from the list of commands below\nCommand\nUsage\n/balance-dm address\nThis command initiates the balance alert system in a Direct Message on Discord. Replace address with the address you want to set up alerts for.\n/1balance-threshold-dm token threshold\nThis command allows you to configure the balance threshold. Replace token and threshold with the respective token and threshold value.\n/list-threshold-dm\nThis command lists all your set thresholds.\n/stop-balance-dm\nThis command stops the balance alert system. If you wish to stop receiving balance alerts, enter this command.\nSubscription Notifications\nIf you would like to receive subscrption notifications emails, follow this guide.\nServices - Previous\n1Balance\nNext\nSubscription Plans\nLast modified 1mo ago\nON THIS PAGE\nEmail\nTelegram\nDiscord server\nDiscord Direct Message (DM)\nSubscription Notifications"
  },
  {
    "title": "Supported Networks - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy/supported-networks",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nSupported Networks\nDeprecation Notice: Gelato Functions is set to replace Automate, providing enhanced automation capabilities, access to off-chain data, unified payments across networks, and a performance boost. Migrate your tasks to Gelato Functions before Legacy Automate's end of life on June 30th, 2024 for uninterrupted service.\n​Gelato Automate currently supports the following networks:\nArbitrum\nAvalanche\nBNB Chain (formerly Binance Smart Chain)\nEthereum Mainnet\nFantom\nGnosis Chain (formerly xDAI)\nOptimism\nPolygon\nMore networks are on the way! Please feel free to reach out to us if there's a network where you would like Gelato Automate deployed.\nThe following staging networks are supported:\nGoerli\nMumbai\nArbitrum Goerli\nOptimism Goerli\nBase Goerli\nServices - Previous\nAutomate (Legacy)\nNext\nPaying for your transactions\nLast modified 1mo ago"
  },
  {
    "title": "Web3 Functions - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/guides/custom-logic-triggers/web3-functions",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nTutorials\nWhat tasks can be automated?\nDefining function inputs\nCustom logic triggers\nSmart Contract Resolvers\nWeb3 Functions\nDedicated msg.sender\nSingle Execution Task\nMulti contract execution\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nWeb3 Functions\nIn order to automate smart contracts based on off-chain data & computation, check out our Web3 Functions section. \nPrevious\nSmart Contract Resolvers\nNext\nDedicated msg.sender\nLast modified 2mo ago"
  },
  {
    "title": "Smart Contract Resolvers - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/guides/custom-logic-triggers/smart-contract-resolvers",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nTutorials\nWhat tasks can be automated?\nDefining function inputs\nCustom logic triggers\nSmart Contract Resolvers\nWeb3 Functions\nDedicated msg.sender\nSingle Execution Task\nMulti contract execution\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nSmart Contract Resolvers\nHere is how a simple smart contract resolver looks like. This resolver is responsible for checking the lastExecuted state of a simple counter in another smart contract. And if 3 minutes have passed since the last execution, this resolver will prompt Gelato to execute.\nCheck out the code for Counter and CounterResolver .\nCounterResolver.sol \ncontract CounterResolver {\n    ICounter public immutable counter;\n​\n    constructor(ICounter _counter) {\n        counter = _counter;\n    }\n​\n    function checker()\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        uint256 lastExecuted = counter.lastExecuted();\n​\n        canExec = (block.timestamp - lastExecuted) > 180;\n        \n        execPayload = abi.encodeCall(ICounter.increaseCount, (1));\n    }\n}\nA resolver should always return 2 things:\n1.\nbool canExec : whether Gelato should execute the task.\n2.\nbytes execData :  data that executors should use for the execution.\nResolvers can also accept arguments. This is useful as you can potentially \"re-use\" your resolver when creating multiple tasks. \nUsing the same example as above:\n    function checker(address _counter)\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        uint256 lastExecuted = ICounter(_counter).lastExecuted();\n​\n        canExec = (block.timestamp - lastExecuted) > 180;\n​\n        execPayload = abi.encodeCall(ICounter.increaseCount, (1));\n    }\nInstead of a hardcoded COUNTER address, you can pass counterAddress as an argument. \nCommon patterns and best practices\nChecking multiple functions in one Resolver\nLet's say you want to automate your yield compounding for multiple pools. To avoid creating multiple tasks and having different resolvers, you could keep a list of the pools and iterate through each of the pools to see if they should be compounded. Take a look at this example.\nfunction checker()\n\texternal\n\tview\n\treturns (bool canExec, bytes memory execPayload)\n{\n\tuint256 delay = harvester.delay();\n\t\n\tfor (uint256 i = 0; i < vaults.length(); i++) {\n\t\tIVault vault = IVault(getVault(i));\n​\n\t\tcanExec = block.timestamp >= vault.lastDistribution().add(delay);\n​\n\t\texecPayload = abi.encodeWithSelector(\n\t\t\tIHarvester.harvestVault.selector,\n\t\t\taddress(vault)\n\t\t);\n​\n\t\tif (canExec) return(true, execPayload);\n\t\t\n\t}\t\n\t\n\treturn(false, bytes(\"No vaults to harvest\");\n​\n}\nThis resolver will return true when a certain time has elapsed since the last distribution of a pool, together with the payload to compound that specific pool. \nLogs using custom return messages\nThe Gelato Automate UI has a feature which provides logs which show what the Gelato Executors are seeing in real time. \nUsing custom return messages, you can always check where in your smart contract Resolver the logic is currently \"stuck\", i.e. why isn't the Resolver returning true.\n    function checker()\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        uint256 lastExecuted = counter.lastExecuted();\n​\n        if(block.timestamp - lastExecuted < 180) return(false, bytes(\"Time not elapsed\");\n​\n        execPayload = abi.encodeCall(ICounter.increaseCount, (1));\n        return(true, execPayload);\n    }\nLimit the Gas Price of your execution\nOn networks such as Ethereum, gas will get expensive at certain times. If what you are automating is not time-sensitive and don't mind having your transaction mined at a later point, you can limit the gas price used in your execution in your resolver.\nfunction checker()\n\texternal\n\tview\n\treturns (bool canExec, bytes memory execPayload)\n{\n\t// condition here\n\t\n\tif(tx.gasprice > 80 gwei) return (false, bytes(\"Gas price too high\"));\n}\n​\nThis way, Gelato will not execute your transaction if the gas price is higher than 80 GWEI. \nPrevious\nCustom logic triggers\nNext\nWeb3 Functions\nLast modified 2mo ago\nON THIS PAGE\nCommon patterns and best practices\nChecking multiple functions in one Resolver\nLogs using custom return messages\nLimit the Gas Price of your execution"
  },
  {
    "title": "Petting Aavegotchis - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/template-real-world-examples/petting-aavegotchis",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nYield vault harvesting\nRewards Payout\nPetting Aavegotchis\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nPetting Aavegotchis\nGotchiCare\n​GotchiCare uses Gelato Autoamte to provide an automated Aavegotchi petting service.\nGelato calls exec here which pets the Aavegotchis and settles the fee. \n  function exec(CareInfo calldata _careInfo) external {\n    require(msg.sender == executor, \"Carer: Only executor\");\n​\n    bytes32 _receipt = getReceipt(_careInfo.owner, _careInfo);\n​\n    require(\n      caringOwners.contains(_careInfo.owner),\n      \"Carer: exec: Owner has not started\"\n    );\n    require(\n      _careInfo.owner == ownerOfReceipt[_receipt],\n      \"Carer: exec: Receipt does not match\"\n    );\n​\n    operator.pet(_careInfo.gotchis, _careInfo.owner);\n​\n    payWages(_careInfo.owner, _careInfo.rate);\n​\n \n    CareInfo memory newCareInfo = CareInfo(\n      _careInfo.owner,\n      _careInfo.pets.add(1),\n      _careInfo.rate,\n      _careInfo.gotchis\n    );\n​\n      updateOwnerInfo(newCareInfo);\n​\n  }\nThis resolver loops through an array of subscribed users. For each user, it checks if their aavegotchi's petting time has reached. \n  function checker()\n    external\n    view\n    returns (bool canExec, bytes memory execPayload)\n  {\n    address[] memory _caringOwners = careCentre.getCaringOwners();\n    uint256 _length = _caringOwners.length;\n​\n    for (uint256 i = 0; i < _length; i++) {\n      ICareCentre.CareInfo memory _careInfo = careCentre.getCareInfoByOwner(\n        _caringOwners[i]\n      );\n​\n      if (!ownerHasBalance(_caringOwners[i], _careInfo.rate)) continue;\n      if (!isApproved(_caringOwners[i])) continue;\n​\n      uint256[] memory _gotchis = _careInfo.gotchis;\n​\n      uint256 _lastInteracted = gotchiFacet\n        .getAavegotchi(_gotchis[0])\n        .lastInteracted;\n​\n      uint256 _nextInteract = _lastInteracted + 12 hours;\n​\n      if (block.timestamp >= _nextInteract) {\n        canExec = true;\n​\n        execPayload = abi.encodeWithSelector(\n          ICareCentre.exec.selector,\n          _careInfo\n        );\n​\n        return (canExec, execPayload);\n      }\n    }\n​\n    canExec = false;\n  }\n​\nPrevious\nRewards Payout\nNext\nCode Repositories\nLast modified 1yr ago"
  },
  {
    "title": "Rewards Payout - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/template-real-world-examples/rewards-payout",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nYield vault harvesting\nRewards Payout\nPetting Aavegotchis\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nRewards Payout\nUnicly\n​Unicly uses Gelato Automate for daily rewards generation for stakers.\nGelato calls this addRewards in their staking contract recurrently once everyday. \nfunction addRewards(address rewardToken, uint256 amount) override external poolExists(rewardToken) {\n        require(amount > 0, \"UnicStaking: Amount must be greater than zero\");\n        IERC20Upgradeable(rewardToken).safeTransferFrom(msg.sender, address(this), amount);\n        RewardPool storage pool = pools[rewardToken];\n        pool.totalRewardAmount = pool.totalRewardAmount.add(amount);\n        emit AddRewards(rewardToken, amount);\n}\nSince the condition to call this function is time-dependent, writing a resolver is not required.  \nYou can create a task through the Gelato Automate UI directly.\nOn the task creation page, select the Time option for \"When\" and input your desired interval between executions. \nPrevious\nYield vault harvesting\nNext\nPetting Aavegotchis\nLast modified 1yr ago"
  },
  {
    "title": "Yield vault harvesting - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/template-real-world-examples/yield-vault-harvesting",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nYield vault harvesting\nRewards Payout\nPetting Aavegotchis\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nYield vault harvesting\nETHA Lend\n​ETHA is using Gelato Automate for automated yield harvesting. \nThis is the function which Gelato will be calling. harvestVault claims yield generated from a pool and re-deposits them back into the pool.\nfunction harvestVault(IVault vault) public onlyAfterDelay(vault) {\n\t// Amount to Harvest\n\tuint256 afterFee = vault.harvest();\n\trequire(afterFee > 0, \"!Yield\");\n​\n\tIERC20 from = vault.rewards();\n\tIERC20 to = vault.target();\n​\n\taddress connector = getBestConnector(\n\t\taddress(from),\n\t\taddress(to),\n\t\tafterFee\n\t);\n​\n\t// Quickswap path\n\taddress[] memory path;\n​\n\tif (connector == address(0)) {\n\t\tpath = new address[](2);\n\t\tpath[0] = address(from);\n\t\tpath[1] = address(to);\n\t} else {\n\t\tpath = new address[](3);\n\t\tpath[0] = address(from);\n\t\tpath[1] = connector;\n\t\tpath[2] = address(to);\n\t}\n​\n\t// Swap underlying to target\n\tfrom.approve(address(ROUTER), afterFee);\n\tuint256 received = ROUTER.swapExactTokensForTokens(\n\t\tafterFee,\n\t\t1,\n\t\tpath,\n\t\taddress(this),\n\t\tblock.timestamp + 1\n\t)[path.length - 1];\n​\n\t// Send profits to vault\n\tto.approve(address(vault), received);\n\tvault.distribute(received);\n​\n\temit Harvested(address(vault), msg.sender);\n}\nETHA uses this resolver below to check for ready to be harvested pools. \nfunction checker()\n\texternal\n\tview\n\treturns (bool canExec, bytes memory execPayload)\n{\n\tuint256 delay = harvester.delay();\n​\n\tfor (uint256 i = 0; i < vaults.length(); i++) {\n\t\tIVault vault = IVault(getVault(i));\n​\n\t\tcanExec = block.timestamp >= vault.lastDistribution().add(delay);\n​\n\t\texecPayload = abi.encodeWithSelector(\n\t\t\tIHarvester.harvestVault.selector,\n\t\t\taddress(vault)\n\t\t);\n​\n\t\tif (canExec) break;\n\t}\n}\n​\nThe resolver loops through an array of pools. And for each vault, if a defined delay has elapsed since the previous harvest time, canExec will return true , prompting Gelato to execute the task. execPayload will be the data to the function call harvestVault(address vault) and its argument is the address of the vault to be harvested.\nPrevious\nTemplate real-world examples\nNext\nRewards Payout\nLast modified 1yr ago"
  },
  {
    "title": "Gelato Automate SDK - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/methods-for-submitting-your-task/gelato-automate-sdk",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGelato Automate UI\nGelato Automate SDK\nSmart Contract\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nGelato Automate SDK\nCreate automated task executions using our typescript SDK:\nNPM Package\nnpm: @gelatonetwork/automate-sdk\nnpm\nHow to use\nInstall automate-sdk:\nyarn add @gelatonetwork/automate-sdk\nImport AutomateSDK:\nimport { AutomateSDK } from \"@gelatonetwork/automate-sdk\";\nInstantiate the SDK with your signer:\nconst automate = new AutomateSDK(chainId, signer);\nUse createTask to automate your function calls:\ninterface CreateTaskOptions {\n  name: string;             // your task name\n​\n  // Function to execute\n  execAddress: string;      // address of your target smart contract\n  execSelector: string;     // function selector to execute on your target smart contract\n  execAbi?: string;         // ABI of your target smart contract\n​\n  // Proxy caller\n  dedicatedMsgSender: boolean;  // task will be called via a dedicated msg.sender which you can whitelist (recommended: true)\n​\n  // Optional: Pre-defined / static target smart contract inputs\n  execData?: string;        // exec call data \n  \n  // Optional: Dynamic target smart contract inputs (using a resolver)\n  resolverAddress?: string; // resolver contract address\n  resolverData?: string;    // resolver call data (encoded data with function selector)\n  resolverAbi?: string;     // your resolver contract ABI\n​\n  // Optional: Time based task params\n  interval?: number;        // execution interval in seconds\n  startTime?: number;       // start timestamp in seconds or 0 to start immediately (default: 0)\n  \n  // Optional: Single execution task\n  singleExec?: boolean;     // task cancels itself after 1 execution if true.\n  \n  // Optional: Payment params\n  useTreasury?: boolean;    // use false if your task is self-paying (default: true)\n}\n​\nconst params: CreateTaskOptions = { name, execAddress, execSelector, interval };\nconst { taskId, tx }: TaskTransaction = await automate.createTask(params);\nExamples\nDeploy a contract & automate your function call:\n// Deploying Counter contract\nconst counterFactory = await hre.ethers.getContractFactory(\"Counter\");\nconst counter = await counterFactory.deploy(GELATO_ADDRESSES[chainId].automate);\nawait counter.deployed();\n​\n// Call Counter.increaseCount(42) every 10 minutes\nconst  { taskId, tx }: TaskTransaction = await automate.createTask({\n  execAddress: counter.address,\n  execSelector: counter.interface.getSighash(\"increaseCount(uint256)\"),\n  execData: counter.interface.encodeFunctionData(\"increaseCount\", [42]),\n  execAbi: counter.interface.format(\"json\") as string,\n  interval: 10 * 60, // execute every 10 minutes\n  name: \"Automated counter every 10min\",\n  dedicatedMsgSender: true\n});​\nUse a resolver contract to automate your function call:\nIf you need more configurable execution condition and/or dynamic input data, you can create a task using a resolver function (learn how to write a resolver).\n// Prepare Task data to automate\nconst counter = new Contract(COUNTER_ADDRESSES, counterAbi, signer);\nconst resolver = new Contract(COUNTER_RESOLVER_ADDRESSES, counterResolverAbi, signer);\nconst selector = counter.interface.getSighash(\"increaseCount(uint256)\");\nconst resolverData = resolver.interface.getSighash(\"checker()\");\n​\n// Create task\nconst { taskId, tx }: TaskTransaction = await automate.createTask({\n  execAddress: counter.address,\n  execSelector: selector,\n  resolverAddress: resolver.address,\n  resolverData: resolverData,\n  name: \"Automated counter using resolver\",\n  dedicatedMsgSender: true\n});\nEnable dedicated msg.sender:\nTo have a custom msg.sender that you can whitelist on your contract, you can enable the dedicatedMsgSender flag.\n// Prepare Task data to automate\nconst counter = new Contract(COUNTER_ADDRESSES, counterAbi, signer);\nconst resolver = new Contract(COUNTER_RESOLVER_ADDRESSES, counterResolverAbi, signer);\nconst selector = counter.interface.getSighash(\"increaseCount(uint256)\");\nconst resolverData = resolver.interface.getSighash(\"checker()\");\n​\n// Create task\nconst { taskId, tx }: TaskTransaction = await automate.createTask({\n  execAddress: counter.address,\n  execSelector: selector,\n  resolverAddress: resolver.address,\n  resolverData: resolverData,\n  dedicatedMsgSender: true,\n  name: \"Automated counter using resolver\",\n});\n​\n// Get dedicated proxy address to whitelist\nconst { address, isDeployed } = await automate.getDedicatedMsgSender()\nMore examples in our Hello World repository:\nGitHub - gelatodigital/automate-sdk-hello-world: Create Hello World tasks using Gelato Ops SDK\nGitHub\nPrevious\nGelato Automate UI\nNext\nSmart Contract\nLast modified 1mo ago\nON THIS PAGE\nNPM Package\nHow to use\nExamples"
  },
  {
    "title": "Gelato Automate UI - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/methods-for-submitting-your-task/gelato-automate-ui",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGelato Automate UI\nGelato Automate SDK\nSmart Contract\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nGelato Automate UI\nEasy-to-use interface for you to create and manage your tasks\nTo submit a task, head to the Gelato Automate UI.\nClick on New Task.\nChoose a name for your task. (e.g. \"Harvest vault every 10 minutes\")\nExecution contract details\nFill in the contract address which has the function you want to automate.\nSelect the function you want to automate. \nIf your function accepts arguments\nChoose how you want your arguments to be passed. \nIf you are not sure about this, see \nDefining function inputs\n​\nDedicated msg.sender\nThe system will inform you of the address of msg.sender when your task is being executed. \nIf you are not sure about this, see \nDedicated msg.sender\n​\nWhen to execute\nPre-defined inputs\nWith pre-defined inputs chosen, you will see two options:\nTime - Task will be repeatedly executed at the interval frequency you specify after the start time you enter. \nWhenever possible - Task will be executed continuously whenever the transaction will not fail.\nMake sure the function can only be executed from time to time if \"Whenever possible\" is selected\nDynamic inputs via resolver\nIf you are using a resolver, fill in the resolver address that is deployed.\nPaying for fees\nChoose how you would like to pay for the execution fees for your task. \nDeposit some tokens if \"Gelato Balance\" is chosen.\nIf you are not sure about this, see \nPaying for your transactions\n​\nTask name (optional)\nYou will be prompted to enter a task name with some suggestions based on your contract. This is optional but if you have multiple tasks it will be much easier to track which task does what if you give it a name. Names are not stored on-chain.\nWhen you click Create Task you will be asked to sign a message to confirm the name and then sign a transaction to create your task on-chain. \n​\nDone!\nOnce your task creation transaction has been confirmed you will be redirected to the Task Page:\nHere you can see your task's details and monitor its task logs and executions.\nPrevious\nMethods for submitting your task\nNext\nGelato Automate SDK\nLast modified 1mo ago\nON THIS PAGE\nExecution contract details\nDedicated msg.sender\nWhen to execute\nPre-defined inputs\nDynamic inputs via resolver\nPaying for fees\nTask name (optional)\nDone!"
  },
  {
    "title": "Multi contract execution - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/guides/multi-contract-execution",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nTutorials\nWhat tasks can be automated?\nDefining function inputs\nCustom logic triggers\nDedicated msg.sender\nSingle Execution Task\nMulti contract execution\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nMulti contract execution\nWith dedicated msg.sender enabled, you can make use of its multi-call function batchExecuteCall to execute multiple functions on different contracts. \n    function batchExecuteCall(\n        address[] calldata _targets,\n        bytes[] calldata _datas,\n        uint256[] calldata _values\n    ) external payable override onlyAuth {\n        uint256 length = _targets.length;\n        require(\n            length == _datas.length && length == _values.length,\n            \"OpsProxy: Length mismatch\"\n        );\n​\n        for (uint256 i; i < length; i++)\n            _executeCall(_targets[i], _datas[i], _values[i]);\n    }\nTo do so, you will need to create a task with your dedicated msg.sender as the target contract address.\nGet your dedicated msg.sender\nCopy the address of your dedicated msg.sender which can be found in the user drop-down.\nCreate a task calling your dedicated msg.sender\nPaste the ABI below into the ABI field and select batchExecuteCall as the function to be automated. \n[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_datas\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"batchExecuteCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]\nYou can either predefine the arguments or have a resolver return the data.\nIf you are using a resolver, you must return an ABI encoded payload of the batchExecuteCall function.\nHere is an example resolver that returns a payload that calls increaseCount on 2 different contracts.\ninterface IOpsProxy {\n    function batchExecuteCall(\n        address[] calldata targets,\n        bytes[] calldata datas,\n        uint256[] calldata values\n    ) external payable;\n}\n​\ninterface ICounter {\n    function increaseCount(uint256 _amount) external;\n}\n​\ncontract BatchExecCallResolver {\n​\n    address public immutable counter1;\n    address public immutable counter2;\n    \n    constructor(address _counter1, address _counter2){\n        counter1 = _counter1;\n        counter2 = _counter2;\n    }\n    \n    function checker()\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        address[] memory targets = new address[](2);\n        targets[0] = counter1;\n        targets[1] = counter2;\n​\n        bytes[] memory datas = new bytes[](2);\n        datas[0] = abi.encodeWithSelector(ICounter.increaseCount.selector, [1]);\n        datas[1] = abi.encodeWithSelector(ICounter.increaseCount.selector, [2]);\n​\n        uint256[] memory values = new address[](2);\n        values[0] = 0;\n        values[1] = 0;\n​\n        execPayload = abi.encodeWithSelector(\n            IOpsProxy.batchExecuteCall.selector,\n            [targets, datas, values]\n        );\n        \n        return (true, execPayload);\n    }    \n}\n​\n​\nPrevious\nSingle Execution Task\nNext\nMonitoring Automate Tasks\nLast modified 1mo ago\nON THIS PAGE\nGet your dedicated msg.sender\nCreate a task calling your dedicated msg.sender"
  },
  {
    "title": "Single Execution Task - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/guides/single-execution-task",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nTutorials\nWhat tasks can be automated?\nDefining function inputs\nCustom logic triggers\nDedicated msg.sender\nSingle Execution Task\nMulti contract execution\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nSingle Execution Task\nSometimes, you might want to have Gelato call your function only once. If so, you can make use of the SingleExec module which automatically cancels the task for you after one execution.\nThe task will still be canceled if the execution reverts on-chain\nHere is how you can enable SingleExec when creating your task across the various task creation methods.\nGelato Automate UI\nOpen up the Advanced Settings panel when creating a new task and select Single execution task:\nAccessing the single execution task option in Advanced Settings\nGelato Automate SDK\nSet singleExec flag to true  when calling createTask.  \nconst { taskId, tx }: TaskTransaction = await automate.createTask({\n  execAddress: counter.address,\n  execSelector: selector,\n  resolverAddress: counter.address,\n  resolverData: resolverData,\n  dedicatedMsgSender: true,\n  name: \"Automated counter using resolver\",\n  dedicatedMsgSender: true,\n  singleExec: true\n});\nSmart Contract\nInclude SingleExec module in ModuleData.modules . Check out the full code here.\nModuleData memory moduleData = ModuleData({\n    modules: new Module[](2),\n    args: new bytes[](2)\n});\n​\nmoduleData.modules[0] = Module.PROXY;\nmoduleData.modules[1] = Module.SINGLE_EXEC;\n​\nmoduleData.args[0] = _proxyModuleArg();\nmoduleData.args[1] = _singleExecModuleArg();\n​\nbytes32 id = _createTask(\n    address(this),\n    execData,\n    moduleData,\n    address(0)\n);\nPrevious\nDedicated msg.sender\nNext\nMulti contract execution\nLast modified 1mo ago\nON THIS PAGE\nGelato Automate UI\nGelato Automate SDK\nSmart Contract"
  },
  {
    "title": "Dedicated msg.sender - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/guides/dedicated-msg.sender",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nTutorials\nWhat tasks can be automated?\nDefining function inputs\nCustom logic triggers\nDedicated msg.sender\nSingle Execution Task\nMulti contract execution\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nDedicated msg.sender\nAdding security by restricting who can execute a particular function\nDuring task creation, you will see an address which will be the msg.sender during your task executions.\nIf you are the owner of the target contract, we recommend that you have a msg.sender restriction on your smart contract with your dedicated msg.sender whitelisted. This adds additional security as only you, the contract owner can create a task to call your function.\nmsg.sender restrictions should be added to the function that Gelato will call during execution, not the checker function.\nYou can have this restriction by inheriting AutomateReady​\nAutomateReady exposes a modifier onlyDedicatedMsgSender which restricts msg.sender to only task executions created by taskCreator defined in the constructor.\n    modifier onlyDedicatedMsgSender() {\n        require(msg.sender == dedicatedMsgSender, \"Only dedicated msg.sender\");\n        _;\n    }\nIf you would like to have additional callers for your function. You can implement a whitelist like so.\n    mapping(address => bool) public whitelisted;\n​\n    modifier onlyWhitelisted() {\n        require(\n            whitelisted[msg.sender] || msg.sender == dedicatedMsgSender,\n            \"Only whitelisted\"\n        );\n        _;\n    }\n​\nPrevious\nWeb3 Functions\nNext\nSingle Execution Task\nLast modified 1mo ago"
  },
  {
    "title": "Defining function inputs - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/guides/defining-function-inputs",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nTutorials\nWhat tasks can be automated?\nDefining function inputs\nCustom logic triggers\nDedicated msg.sender\nSingle Execution Task\nMulti contract execution\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nDefining function inputs\nIf the function you are automating accepts arguments you have two alternative ways that you can define the arguments. \nPre-define inputs (No resolver)\nPre-defining the function arguments would mean that every time Gelato calls the function, it would be using the same argument. \nDynamic inputs via Resolver\nBy using a resolver, you can dynamically encode the arguments of the function you are automating. \nHere is an example:\nThis is the function we are automating. increaseCount increases a counter on the smart contract by amount which is the argument.\n    function increaseCount(uint256 amount) external {\n        require(\n            ((block.timestamp - lastExecuted) > 300),\n            \"Counter: increaseCount: Time not elapsed\"\n        );\n​\n        count += amount;\n        lastExecuted = block.timestamp;\n    }\nThis resolver returns the data to the function call increaseCount.\n    function checker()\n        external\n        view\n        override\n        returns (bool canExec, bytes memory execData)\n    {\n        uint256 lastExecuted = ICounter(COUNTER).lastExecuted();\n​\n        canExec = (block.timestamp - lastExecuted) > 300;\n        \n        uint256 countToIncrease = ICounter(COUNTER).count * 2\n​\n        execPayload = abi.encodeCall(\n            ICounter.increaseCount,\n            (countToIncrease)\n        );\n    }\n​\nThe increment on each execution is different every time as countToIncrease is different after every execution. \nPrevious\nWhat tasks can be automated?\nNext\nCustom logic triggers\nLast modified 1mo ago\nON THIS PAGE\nPre-define inputs (No resolver)\nDynamic inputs via Resolver"
  },
  {
    "title": "Smart Contract - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/methods-for-submitting-your-task/smart-contract#automatetaskcreator-functions",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGelato Automate UI\nGelato Automate SDK\nSmart Contract\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nSmart Contract\nUsing Automate programatically\nTasks created via this route cannot be named\nSmart Contracts can also create and cancel tasks on Gelato Automate.\nYou can find a list of example smart contracts here. \nAutomateTaskCreator functions\nHere are the functions exposed by AutomateTaskCreator which you can use when setting up your smart contract.\n_createTask()\nInteracts and creates a task on the Gelato Automate smart contract.\n    function _createTask(\n        address execAddress, \n        bytes memory execDataOrSelector, \n        ModuleData memory moduleData,\n        address feeToken \n    ) internal returns (bytes32 taskId);\nexecAddress - Address of the contract which Gelato will call.\nexecDataOrSelector - Signature of function which Gelato will call / execution data (If Resolver Module is not used. More about modules below)  \nmoduleData - Modules that are enabled for the task. (More about ModuleData below)\nfeeToken - Use address(0) if using Gelato balance. Use 0xeeeeee... for ETH or native tokens.\nModuleData\nstruct ModuleData {\n        Module[] modules;\n        bytes[] args;\n}\n Modules are conditions /  specifications about your task. These are the current available Modules.\nenum Module {\n    RESOLVER,  \n    TIME, \n    PROXY, \n    SINGLE_EXEC \n}\nRESOLVER - Define dynamic conditions and execution data. \nSmart Contract Resolvers\n​\nTIME - Repeated execution at a specific time and interval.\nPROXY - Your function will be called by a dedicated msg.sender.\nDedicated msg.sender\n​\nSINGLE_EXEC - Task is cancelled after one execution.\nEach Module would require additional arguments which is an encoded data. \nYou can use these helper functions to get the arguments for each Module. \n    function _resolverModuleArg(address _resolverAddress, bytes memory _resolverData)\n​\n    function _timeModuleArg(uint256 _startTime, uint256 _interval)\n    \n    function _proxyModuleArg()\n    \n    function _singleExecModuleArg()\nCrafting ModuleData will look like this if we want to create a task which utilise RESOLVER ,PROXY & SINGLE_EXEC Module.\n        ModuleData memory moduleData = ModuleData({\n            modules: new Module[](3),\n            args: new bytes[](3)\n        });\n​\n        moduleData.modules[0] = Module.RESOLVER;\n        moduleData.modules[1] = Module.PROXY;\n        moduleData.modules[2] = Module.SINGLE_EXEC\n​\n        moduleData.args[0] = _resolverModuleArg(\n            address(this),\n            abi.encodeCall(this.checker, ())\n        );\n        moduleData.args[1] = _proxyModuleArg();\n        moduleData.args[2] = _singleExecModuleArg();\nModule[] must follow the order RESOLVER, TIME, PROXY, SINGLE_EXEC\n_cancelTask()\nCancels a task owned by the smart contract.\n    function _cancelTask(bytes32 _taskId) internal\nonlyDedicatedMsgSender\nFunction modifier to restrict msg.sender to only task executions created by taskCreator (defined in constructor). \nDedicated msg.sender\n​\n    modifier onlyDedicatedMsgSender() {\n        require(msg.sender == dedicatedMsgSender, \"Only dedicated msg.sender\");\n        _;\n    }\nPROXY module must be enabled. Or else the msg.sender will be the Automate smart contract in \nContract Addresses\n​\n_depositFunds()\n    function _depositFunds(uint256 _amount, address _token) internal\nDeposit funds into the contract's Gelato balance. \nwithdrawFunds()\n    function withdrawFunds(uint256 _amount, address _token) external \nWithdraw funds from the contract's Gelato balance. Only fundsOwner defined in the constructor can call this function.\n​\nPrevious\nGelato Automate SDK\nNext\nGuides\nLast modified 1mo ago\nON THIS PAGE\nAutomateTaskCreator functions\n_createTask()\nModuleData\n_cancelTask()\nonlyDedicatedMsgSender\n_depositFunds()\nwithdrawFunds()"
  },
  {
    "title": "Deploying your VRF Instance - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/vrf/quick-start/deploying-your-vrf-instance",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\n📙\nUnderstanding VRF\n❔\nHow does Gelato VRF Work?\n🔓\nSecurity Considerations\n📄\nTemplate\n🚀\nQuick Start\n🚢\nDeploying your VRF Instance\n💡\nMigrating from Chainlink VRF\n💰\nPricing & Rate Limits\n✅\nSupported Networks\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🚢\nDeploying your VRF Instance\nDeploying your Gelato VRF instance is a straightforward process. Here's a step-by-step guide to get you started:\n1. Gather Necessary Addresses\nBefore you begin, make sure you have the address of your requester contract at hand. This will be essential for the deployment process.\n2.  Access the VRF Deployment Portal\nNavigate to the Gelato VRF app.\n3. Choose your VRF Type\nWhen prompted to select the VRF type, opt for \"Gelato VRF\". If you previously deployed a Chainlink consumer contract and wish to transition, refer to the Migrating from Chainlink VRF section.4. Select Deployment Network\nEnsure you choose the same network where both your VRF requester and receiver contracts are deployed.\n5. Specify the Request Contract\nYou'll be asked to provide the address of the Request Contract to which the Gelato nodes should respond. Enter the address you gathered in step 1.\n6. Launch your VRF Instance\nOnce all details are correctly entered, go ahead and launch your Gelato VRF instance.\nPrevious\nQuick Start\nNext\nMigrating from Chainlink VRF\nLast modified 1mo ago\nON THIS PAGE\n1. Gather Necessary Addresses\n2. Access the VRF Deployment Portal\n3. Choose your VRF Type\n5. Specify the Request Contract\n6. Launch your VRF Instance"
  },
  {
    "title": "Test, Deploy & Run Solidity Functions - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/quick-start/test-deploy-and-run-solidity-functions",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n➡\nWriting Typescript Functions\n➡\nTest, Deploy & Run Typescript functions\n➡\nWriting Solidity Functions\n➡\nTest, Deploy & Run Solidity Functions\n➡\nInitiate an Automated Transaction\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n➡\nTest, Deploy & Run Solidity Functions\nTesting Solidity Functions\nThe purpose of this repo is to showcase unit tests examples of using Gelato Solidity Functions in a Hardhat environment.\nGitHub - gelatodigital/automate-unit-testing: The purpose of this repo is to showcase unit tests examples of using Gelato Automate in a Hardhat enviroment.\nGitHub\nIt's advised to conduct tests by impersonating Gelato's address within a Hardhat environment to ensure accurate simulation of Gelato Solidity Function executions.\nDeploying Solidity Functions\nTo deploy your Solidity functions, please proceed with deploying your contract to the network. Once deployed, ensure you verify your contract on Etherscan to enable automatic ABI fetching within our app.\nCheck out an example script here to see how you can deploy your Solidity Functions.\nCreating Solidity Function Tasks\nBefore creating solidity function tasks, familiarize yourself with the available \nTrigger Types\n!\n1.\nSelection of Function\nNavigate to the What to trigger section.\nChoose the Solidity Function option\n2.\nNetwork Configuration\nLocate the Network dropdown.\nSelect your desired blockchain network where the contract is deployed, e.g., \"Göerli.\"\n3.\nFunction Details Input\nUnder the Solidity Function section, find the input labeled Contract Address.\nEnter the Ethereum address of your deployed Solidity contract. Ensure accuracy as this determines where your functions will interact.\nOnce the contract address is entered, the ABI (Application Binary Interface) should automatically populate. If using a custom ABI, select the Custom ABI option and input it accordingly.\n4.\nTask Configuration\nA checker function evaluates conditions before triggering the main function. From the Checker Function dropdown, choose the specific function you want as a condition checker.\nEnter the Target Contract where the automated function call should be sent. From the subsequent dropdown, select the specific function you wish to automate.\nPrevious\nWriting Solidity Functions\nNext\nInitiate an Automated Transaction\nLast modified 2mo ago\nON THIS PAGE\nTesting Solidity Functions\nDeploying Solidity Functions\nCreating Solidity Function Tasks"
  },
  {
    "title": "Initiate an Automated Transaction - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/quick-start/initiate-an-automated-transaction",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n➡\nWriting Typescript Functions\n➡\nTest, Deploy & Run Typescript functions\n➡\nWriting Solidity Functions\n➡\nTest, Deploy & Run Solidity Functions\n➡\nInitiate an Automated Transaction\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n➡\nInitiate an Automated Transaction\nAn execution attempt in Gelato allows you to pre-define the inputs for a function. By doing so, every time Gelato calls the function, it uses the same arguments, ensuring consistent behavior in your automated tasks.\n1. Prepare Your Smart Contract for Automation\nIdentify Your Smart Contract: Ensure you have the correct smart contract address and know the specific function you want to automate.\nFunction Restrictions: Some functions may not be compatible with Gelato due to certain restrictions. Familiarize yourself with these to ensure seamless automation.\n2. Set Your Trigger Condition\nChoosing Your Trigger: Gelato allows you to set specific conditions to determine when your function is called. This could be at regular intervals (time interval) or based on specific events (cron expression).\nNo Custom Code Required: For initiating tranaction tasks, there's no need for you to write code. Simply set your desired trigger and move forward.\nFinally, Click on \"Create Task\" button! Its just that simple!\n​\nPrevious\nTest, Deploy & Run Solidity Functions\nNext\nAnalytics & Monitoring\nLast modified 2mo ago\nON THIS PAGE\n1. Prepare Your Smart Contract for Automation\n2. Set Your Trigger Condition"
  },
  {
    "title": "Test, Deploy & Run Typescript functions - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/quick-start/test-deploy-and-run-typescript-functions",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n➡\nWriting Typescript Functions\n➡\nTest, Deploy & Run Typescript functions\n➡\nWriting Solidity Functions\n➡\nTest, Deploy & Run Solidity Functions\n➡\nInitiate an Automated Transaction\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n➡\nTest, Deploy & Run Typescript functions\nTesting Typescript Functions\nTo test your Typescript Function locally, run:\nnpx hardhat w3f-run W3FNAME\nExample:\nnpx hardhat w3f-run oracle\nOptional flags:\n--logs Show internal Web3 Function logs\n--debug Show Runtime debug messages\n--network [NETWORK] Set the default runtime network & provider.\nExample:\nnpx hardhat w3f-run oracle --logs --network hardhat\nOutput:\nWeb3Function Build result:\n ✓ Schema: /Users/chuahsonglin/Documents/GitHub/Gelato/contract/w3f-template/web3-functions/oracle/schema.json\n ✓ Built file: /Users/chuahsonglin/Documents/GitHub/Gelato/contract/w3f-template/.tmp/index.js\n ✓ File size: 2.47mb\n ✓ Build time: 947.91ms\n​\nWeb3Function user args validation:\n ✓ currency: ethereum\n ✓ oracle: 0x71B9B0F6C999CBbB0FeF9c92B80D54e4973214da\n​\nWeb3Function running logs:\n> Last oracle update: 0\n> Next oracle update: 3600\n> Updating price: 1898\n​\nWeb3Function Result:\n ✓ Return value: {\n  canExec: true,\n  callData: [\n    {\n      to: '0x71B9B0F6C999CBbB0FeF9c92B80D54e4973214da',\n      data: '0x8d6cc56d000000000000000000000000000000000000000000000000000000000000076a'\n    }\n  ]\n}\n​\nWeb3Function Runtime stats:\n ✓ Duration: 1.35s\n ✓ Memory: 113.55mb\n ✓ Storage: 0.03kb\n ✓ Rpc calls: 3\nDeploying Typescript Functions\nTo compile your Typescript Function and deploy it to IFPS, use\nnpx hardhat w3f-deploy W3FNAME\nExample:\nnpx hardhat w3f-deploy oracle \nOnce uploaded, Gelato Nodes will pin the file on your behalf on IPFS. If the upload was successful, you should get the IPFS CID of your Typescript Function returned. \n ✓ Web3Function deployed to ipfs.\n ✓ CID: QmbQJC5XGpQUsAkLq6BqpvLtD8EPNDEaPqyFf4xK3TM6xj\nNote: This CID will be different for every new Typescript Function version that you will deploy.\nCreating Typescript Function Task\nBefore creating solidity function tasks, familiarize yourself with the available \nTrigger Types\n!\n1.\nSelection of Function\nNavigate to the What to trigger section.\nWithin the Typescript Function subsection, find the IPFS CID input box.\n2.\nFunction Details Input\nInput the CID you secured after deploying your Typescript function. Upon entry, you should see a message like \"Typescript Function code imported,\" signifying a successful connection.\n3.\nNetwork Configuration\nScroll to the Network dropdown menu.\nChoose the blockchain network where the Typescript function should work, e.g., \"Göerli.\"\n4.\nTask Configuration\nIf your Typescript function needs secret variables or API keys, securely enter them in the Task Secrets section. For every secret:\nKey: Define the name of the variable or key, e.g., \"API_KEY\".\nValue: Enter the associated secret value.\nClick Save after each input to guarantee its safe storage.\n\n\n\n​\nPrevious\nCallbacks\nNext\nWriting Solidity Functions\nLast modified 2mo ago\nON THIS PAGE\nTesting Typescript Functions\nOptional flags:\nDeploying Typescript Functions\nCreating Typescript Function Task"
  },
  {
    "title": "Using the Automate SDK - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/understanding-web3-functions/create-a-web3-function-task/using-the-automate-sdk",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n1⃣\nTrigger Types\n2⃣\nTypescript Function\n3⃣\nSolidity Function\n4⃣\nAutomated Transactions\n5⃣\nCreate a Web3 Function Task\n⏩\nUsing the UI\n⏩\nUsing a Smart Contract\n⏩\nUsing the Automate SDK\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n⏩\nUsing the Automate SDK\nUsing Automate SDK\nThe SDK is suitable when you need to integrate task creation into your development environment or automated scripts. It's also useful for complex setups that require conditional logic before task submission.\nUse the automate-sdk to easily create a new task:\nyarn install @gelatonetwork/automate-sdk\nTypescript Functions are still in private beta, make sure to use the beta version of the automate-sdk to have access to it\nTypescript Function\nImport the sdk and create task, passing your typescript function CID & arguments:\nimport { AutomateSDK, Web3Function } from \"@gelatonetwork/automate-sdk\";\n​\nconst automate = new AutomateSDK(chainId, deployer);\n​\nconst { taskId, tx } = await automate.createBatchExecTask({\n  name: \"Web3Function - Eth Oracle\",\n  web3FunctionHash: cid,\n  web3FunctionArgs: {\n    oracle: oracle.address,\n    currency: \"ethereum\",\n  },\n  trigger: {\n    // Run every minutes\n    type: TriggerType.TIME,\n    interval: 60 * 1000,\n  },\n});\nawait tx.wait();\nYou can specify cron trigger this way:\ntrigger: {\n  type: TriggerType.CRON,\n  cron: \"0 8 * * *\", // Run every day at 8:00\n}\nevent trigger like this:\ntrigger: {\n  type: TriggerType.EVENT,\n  filter: {\n    // Listen to PriceUpdated event on Oracle contract\n    address: oracle.address,\n    topics: [[oracle.getEventTopic(\"PriceUpdated\")]],\n  },\n  blockConfirmations: 0, // Trigger immediately\n},\nAnd block trigger this way:\ntrigger: {\n  type: TriggerType.BLOCK,\n}\nIf your task utilizes secrets, you can set them after the task has been created.\nconst web3Function = new Web3Function(chainId, deployer);\n​\nconst secrets = {\n  API_KEY: \"...\" // Set your secret environment variables\n}\nawait web3Function.secrets.set(secrts, taskId);\nSolidity Function\nRepeat the installation step as shown above, then import and instantiate the SDK:\nconst automate = new AutomateSDK(chainId, signer);\nUse createTask to automate your function calls:\ninterface CreateTaskOptions {\n  name: string;             // your task name\n​\n  // Function to execute\n  execAddress: string;      // address of your target smart contract\n  execSelector: string;     // function selector to execute on your target smart contract\n  execAbi?: string;         // ABI of your target smart contract\n​\n  // Proxy caller\n  dedicatedMsgSender: boolean;  // task will be called via a dedicated msg.sender which you can whitelist (recommended: true)\n​\n  // Optional: Pre-defined / static target smart contract inputs\n  execData?: string;        // exec call data \n  \n  // Optional: Dynamic target smart contract inputs (using a resolver)\n  resolverAddress?: string; // resolver contract address\n  resolverData?: string;    // resolver call data (encoded data with function selector)\n  resolverAbi?: string;     // your resolver contract ABI\n​\n  // Optional: Time based task params\n  interval?: number;        // execution interval in seconds\n  startTime?: number;       // start timestamp in seconds or 0 to start immediately (default: 0)\n  \n  // Optional: Single execution task\n  singleExec?: boolean;     // task cancels itself after 1 execution if true.\n  \n  // Optional: Payment params\n  useTreasury?: boolean;    // use false if your task is self-paying (default: true)\n}\n​\nconst params: CreateTaskOptions = {\n  name,\n  execAddress,\n  execSelector,\n  interval\n};\n​\nconst { taskId, tx }: TaskTransaction = await automate.createTask(params);\nExamples\nDeploy a contract & automate your function call:\n// Deploying Counter contract\nconst counterFactory = await hre.ethers.getContractFactory(\"Counter\");\nconst counter = await counterFactory.deploy(GELATO_ADDRESSES[chainId].automate);\nawait counter.deployed();\n​\n// Call Counter.increaseCount(42) every 10 minutes\nconst  { taskId, tx }: TaskTransaction = await automate.createTask({\n  execAddress: counter.address,\n  execSelector: counter.interface.getSighash(\"increaseCount(uint256)\"),\n  execData: counter.interface.encodeFunctionData(\"increaseCount\", [42]),\n  execAbi: counter.interface.format(\"json\") as string,\n  interval: 10 * 60, // execute every 10 minutes\n  name: \"Automated counter every 10min\",\n  dedicatedMsgSender: true\n});​\nUse a Checker to automate your function call:\nIf you need more configurable execution condition and/or dynamic input data, you can create a task using Checker \n// Prepare Task data to automate\nconst counter = new Contract(COUNTER_ADDRESSES, counterAbi, signer);\nconst resolver = new Contract(COUNTER_RESOLVER_ADDRESSES, counterResolverAbi, signer);\nconst selector = counter.interface.getSighash(\"increaseCount(uint256)\");\nconst resolverData = resolver.interface.getSighash(\"checker()\");\n​\n// Create task\nconst { taskId, tx }: TaskTransaction = await automate.createTask({\n  execAddress: counter.address,\n  execSelector: selector,\n  resolverAddress: resolver.address,\n  resolverData: resolverData,\n  name: \"Automated counter using resolver\",\n  dedicatedMsgSender: true\n});\nAutomated Transaction\nThe CreateTaskOptions interface is used for configuring Automated Transactions with the same structure and options as defined above.\nThe only difference is you need to configure your automated transaction without the need for a checker function.\nExample:\ninterface CreateTaskOptions {\n  name: string; // Name your task\n  execAddress: string; // Address of your target smart contract\n  execSelector: string; // Function selector to call on your target smart contract\n  execAbi?: string; // ABI of your target smart contract (optional)\n  execData?: string; // Call data for the function execution (optional)\n}\nSingle Execution Task\nIf you want to have Gelato call your function only once. If so, set singleExec flag to true  when calling createTask.  \nconst { taskId, tx }: TaskTransaction = await automate.createTask({\n  execAddress: counter.address,\n  execSelector: selector,\n  resolverAddress: counter.address,\n  resolverData: resolverData,\n  dedicatedMsgSender: true,\n  name: \"Automated counter using resolver\",\n  dedicatedMsgSender: true,\n  singleExec: true\n});\nPrevious\nUsing a Smart Contract\nNext\nSecurity Considerations\nLast modified 1mo ago\nON THIS PAGE\nUsing Automate SDK\nTypescript Function\nSolidity Function\nAutomated Transaction\nSingle Execution Task"
  },
  {
    "title": "Writing Typescript Functions - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/quick-start/writing-typescript-functions",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n➡\nWriting Typescript Functions\n⏩\nEvent Trigger\n⏩\nPrivate Typescript Functions\n⏩\nCallbacks\n➡\nTest, Deploy & Run Typescript functions\n➡\nWriting Solidity Functions\n➡\nTest, Deploy & Run Solidity Functions\n➡\nInitiate an Automated Transaction\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n➡\nWriting Typescript Functions\n1) Clone the Web3 Function Hardhat Template\ngit clone https://github.com/gelatodigital/web3-functions-hardhat-template.git\ncd web3-functions-hardhat-template\nor use the template on Github's UI. \n2) Install dependencies \nyarn install\n3) Copy the example .env file\ncp .env.example .env\n4) Fill in your Alchemy & private key for local testing\nNote: PRIVATE_KEY is optional, and only needed if you wish to deploy contracts or create a task from the CLI instead of the UI \nALCHEMY_ID= // <= Your Alchemy key\nPRIVATE_KEY= // <= Your Private key\nTypescript Function Example\nThis typescript function updates an oracle smart contract with data returned by Coingecko's price API at an interval. Check out more examples here.\nimport { Web3Function, Web3FunctionContext } from \"@gelatonetwork/web3-functions-sdk\";\nimport { Contract, ethers } from \"ethers\";\nimport ky from \"ky\"; // we recommend using ky as axios doesn't support fetch by default\n​\nconst ORACLE_ABI = [\n  \"function lastUpdated() external view returns(uint256)\",\n  \"function updatePrice(uint256)\",\n];\n​\nWeb3Function.onRun(async (context: Web3FunctionContext) => {\n  const { userArgs, gelatoArgs, multiChainProvider } = context;\n  const provider = multiChainProvider.default();\n​\n  // Retrieve Last oracle update time\n  const oracleAddress = \"0x71b9b0f6c999cbbb0fef9c92b80d54e4973214da\";\n  const oracle = new Contract(oracleAddress, ORACLE_ABI, provider);\n  const lastUpdated = parseInt(await oracle.lastUpdated());\n  console.log(`Last oracle update: ${lastUpdated}`);\n​\n  // Check if it's ready for a new update\n  const nextUpdateTime = lastUpdated + 300; // 5 min\n  const timestamp = (await provider.getBlock(\"latest\")).timestamp;\n  console.log(`Next oracle update: ${nextUpdateTime}`);\n  if (timestamp < nextUpdateTime) {\n    return { canExec: false, message: `Time not elapsed` };\n  }\n​\n  // Get current price on coingecko\n  const currency = \"ethereum\";\n  const priceData: any = await ky\n    .get(\n      `https://api.coingecko.com/api/v3/simple/price?ids=${currency}&vs_currencies=usd`,\n      { timeout: 5_000, retry: 0 }\n    )\n    .json();\n  price = Math.floor(priceData[currency].usd);\n  console.log(`Updating price: ${price}`);\n​\n  // Return execution call data\n  return {\n    canExec: true,\n    callData: [{\n      to: oracleAddress,\n      data: oracle.interface.encodeFunctionData(\"updatePrice\", [price])\n  }],\n  };\n});\nCreate your function schema.json to specify your runtime configuration. \n{\n  \"web3FunctionVersion\": \"2.0.0\",\n  \"runtime\": \"js-1.0\",\n  \"memory\": 128, \n  \"timeout\": 30,\n  \"userArgs\": {}\n}\nNote: For now the configuration is fixed and cannot be changed. \nTypescript Function Context\nWhen writing the Web3 Function, it is very helpful to understand the context Gelato injects into the execution, providing additional features to widen the Web3 Functions applicability.\nWeb3Function.onRun(async (context: Web3FunctionContext) => {\n  const { userArgs, storage, secrets, multiChainProvider, gelatoArgs} = context;\n  const provider = multiChainProvider.default();\n  ...\n}\nUser Arguments\n1.\nDeclare your expected userArgs in your schema, accepted types are string, string[], number, number[], boolean, boolean[]:\n{\n  \"web3FunctionVersion\": \"2.0.0\",\n  \"runtime\": \"js-1.0\",\n  \"memory\": 128, \n  \"timeout\": 30,\n  \"userArgs\": {\n    \"currency\": \"string\",\n    \"oracle\": \"string\"\n  }\n}\n2.\nAccess your userArgs from the Web3Function context:\nWeb3Function.onRun(async (context: Web3FunctionContext) => {\n  const { userArgs, gelatoArgs, secrets } = context;\n​\n  // User args:\n  console.log('Currency:', userArgs.currency)\n  console.log('Oracle:', userArgs.oracle)\n  ...\n});\n3.\nIn the same directory as your web3 function, create a file userArgs.json  and fill in your userArgs to test your web3 function:\n{\n  \"currency\": \"ethereum\",\n  \"oracle\": \"0x71B9B0F6C999CBbB0FeF9c92B80D54e4973214da\"\n}\nTest out the Coingecko oracle web3 function:\nnpx hardhat w3f-run oracle --logs\nState / Storage\nWeb3Functions are stateless scripts, that will run in a new & empty memory context on every execution. If you need to manage some state variable, we provide a simple key/value store that you can access from your web3 function context.\nSee the above example to read & update values from your storage:\nimport {\n  Web3Function,\n  Web3FunctionContext,\n} from \"@gelatonetwork/web3-functions-sdk\";\n​\nWeb3Function.onRun(async (context: Web3FunctionContext) => {\n  const { storage, multiChainProvider } = context;\n  const provider = multiChainProvider.default();\n​\n  // Use storage to retrieve previous state (stored values are always string)\n  const lastBlockStr = (await storage.get(\"lastBlockNumber\")) ?? \"0\";\n  const lastBlock = parseInt(lastBlockStr);\n  console.log(`Last block: ${lastBlock}`);\n​\n  const newBlock = await provider.getBlockNumber();\n  console.log(`New block: ${newBlock}`);\n  if (newBlock > lastBlock) {\n    // Update storage to persist your current state (values must be cast to string)\n    await storage.set(\"lastBlockNumber\", newBlock.toString());\n  }\n​\n  return {\n    canExec: false,\n    message: `Updated block number: ${newBlock.toString()}`,\n  };\n});\nTo populate the storage values in your testing, in the same directory as your web3 function, create a file storage.json and fill in the storage values.\n{\n  \"lastBlockNumber\": \"1000\"\n}\nTest out the storage web3 function:\nnpx hardhat w3f-run storage --logs\nSecrets\n1.\nIn the same directory as your web3 function, create a .env file and fill up your secrets.\nCOINGECKO_API=https://api.coingecko.com/api/v3\n2.\nAccess your secrets from the Web3Function context:\n  // Get api from secrets\n  const coingeckoApi = await context.secrets.get(\"COINGECKO_API\");\n  if (!coingeckoApi) {\n    return { canExec: false, message: `COINGECKO_API not set in secrets` };\n  }\n3.\nTest your web3 function using secrets:\nnpx hardhat w3f-run secrets --logs\n4.\nWhen deploying a task, you will be able to set your web3 function secrets on our UI or using the SDK, see here​\nimport hre from \"hardhat\";\nimport { AutomateSDK, Web3Function } from \"@gelatonetwork/automate-sdk\";\n​\nconst { ethers, w3f } = hre;\n​\nconst adBoardW3f = w3f.get(\"advertising-board\");\n​\nconst [deployer] = await ethers.getSigners();\nconst chainId = (await ethers.provider.getNetwork()).chainId;\n​\nconst automate = new AutomateSDK(chainId, deployer);\nconst web3Function = new Web3Function(chainId, deployer);\n​\n// Deploy Web3Function on IPFS\nconsole.log(\"Deploying Web3Function on IPFS...\");\nconst cid = await adBoardW3f.deploy();\nconsole.log(`Web3Function IPFS CID: ${cid}`);\n​\n// Create task using automate sdk\nconsole.log(\"Creating automate task...\");\n​\nconst { taskId, tx } = await automate.createBatchExecTask({\n  name: \"Web3Function - Ad Board\",\n  web3FunctionHash: cid,\n  web3FunctionArgs: {},\n});\n​\nawait tx.wait();\nconsole.log(`Task created, taskId: ${taskId} (tx hash: ${tx.hash})`);\nconsole.log(\n  `> https://beta.app.gelato.network/task/${taskId}?chainId=${chainId}`\n);\n​\n// Set task specific secrets\nconst secrets = adBoardW3f.getSecrets();\nif (Object.keys(secrets).length > 0) {\n  await web3Function.secrets.set(secrets, taskId);\n  console.log(`Secrets set`);\n}\nMultichain Provider\nThe multichainProvider allows us to instantiate RPC providers for every network Gelato is deployed on.\nimport {\n  Web3Function,\n  Web3FunctionContext,\n} from \"@gelatonetwork/web3-functions-sdk\";\n​\nWeb3Function.onRun(async (context: Web3FunctionContext) => {\n  const { multiChainProvider } = context;\n​\n  // multichainProvider.default() will instantiate\n  // the provider of the chain the W3F is deployed\n  const provider = multiChainProvider.default();\n​\n  // passing the chainId as follows, we can instantiate\n  // a rpc provider for that network\n  const polygonProvider = multiChainProvider.chainId(137)\n  ...\n}\nWhen testing locally, we can provide the different providers by including them in .env at the root folder.\n// .env file\nPROVIDER_URLS=RPC1,RPC2\nInteroperability with Other Libraries\nAlthough multiChainProvider is designed to work seamlessly within the Gelato Web3 Functions SDK, it is possible to extract the underlying RPC URL and use it with other client libraries. This flexibility is valuable for developers who prefer or require features from other libraries, such as viem.\nHere's an example of how to utilize the RPC URL from multiChainProvider with the viem library, which can be useful if you need to leverage features specific to viem:\nimport { createPublicClient, http } from \"viem\";\nimport { polygon } from \"viem/chains\";\n​\nWeb3Function.onRun(async (context: Web3FunctionContext) => {\n  const { multiChainProvider } = context;\n  const provider = multiChainProvider.default();\n  const url = provider.connection.url;\n​\n  // Initialize viem client with the extracted URL\n  const rpc = createPublicClient({\n    chain: polygon,\n    transport: http(url),\n  });\n  \n  // Now you can use the viem client for your operations\n  // ...\n});\nGelato Arguments\nGelato injects the chainId, the gasPrice, and the taskId into the context.\n1.\nchainId: The unique number identifying the blockchain network where the function is running.\n2.\ngasPrice: The cost of executing transactions on the blockchain.\n3.\ntaskId: A string that uniquely identifies the task.\nimport {\n  Web3Function,\n  Web3FunctionContext,\n} from \"@gelatonetwork/web3-functions-sdk\";\n​\nWeb3Function.onRun(async (context: Web3FunctionContext) => {\n  const { gelatoArgs } = context;\n​\n  // chainId: number\n  const chainId = gelatoArgs.chainId;\n​\n  // gasPrice: BigNumber\n  const gasPrice = gelatoArgs.gasPrice;\n  \n  // taskId: string\n  const taskId = gelatoArgs.taskId;\n  ...\n}\nPrevious\nQuick Start\nNext\nEvent Trigger\nLast modified 1mo ago\nON THIS PAGE\n1) Clone the Web3 Function Hardhat Template\n2) Install dependencies\n3) Copy the example .env file\n4) Fill in your Alchemy & private key for local testing\nTypescript Function Example\nTypescript Function Context\nUser Arguments\nState / Storage\nSecrets\nMultichain Provider\nInteroperability with Other Libraries\nGelato Arguments"
  },
  {
    "title": "Writing Solidity Functions - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/quick-start/writing-solidity-functions#1.-understand-the-role-of-a-checker",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n➡\nWriting Typescript Functions\n➡\nTest, Deploy & Run Typescript functions\n➡\nWriting Solidity Functions\n➡\nTest, Deploy & Run Solidity Functions\n➡\nInitiate an Automated Transaction\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n➡\nWriting Solidity Functions\n1. Understand the Role of a Checker\nA Checker acts as a bridge between conditions and smart contract executions. Its purpose? To check conditions and determine whether a task should be executed by Gelato. Every Checker returns two main things:\ncanExec (Boolean): Indicates if Gelato should execute the task.\nexecData (Bytes): Contains the data that executors will use during execution.\nSolidity functions must adhere to the block gas limit for checker calls; exceeding it will cause the call to fail.\n2. Solidity Function Example\nBefore we delve into complexities, let's understand the structure of a simple Checker:\ncontract CounterChecker{\n    ICounter public immutable counter;\n​\n    constructor(ICounter _counter) {\n        counter = _counter;\n    }\n​\n    function checker()\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        uint256 lastExecuted = counter.lastExecuted();\n​\n        canExec = (block.timestamp - lastExecuted) > 180;\n​\n        execPayload = abi.encodeCall(ICounter.increaseCount, (1));\n    }\n}\nIn the above, the checker checks the state of a counter and prompts Gelato to execute if 3 minutes (180 seconds) have elapsed since its last execution.\n3. Making your Checker Reusable\nAvoid hardcoding addresses. Instead, allow the passing of arguments to your checker. This lets you reuse the checker for multiple tasks:\nfunction checker(address _counter)\n    external\n    view\n    returns (bool canExec, bytes memory execPayload)\n{\n    uint256 lastExecuted = ICounter(_counter).lastExecuted();\n​\n    canExec = (block.timestamp - lastExecuted) > 180;\n​\n    execPayload = abi.encodeCall(ICounter.increaseCount, (1));\n}\n4. Advanced: Checking Multiple Functions\nSuppose you're automating tasks across different pools. Instead of creating multiple tasks, iterate through your list of pools within a single checker:\nfunction checker()\n    external\n    view\n    returns (bool canExec, bytes memory execPayload)\n{\n    uint256 delay = harvester.delay();\n​\n    for (uint256 i = 0; i < vaults.length(); i++) {\n        IVault vault = IVault(getVault(i));\n​\n        canExec = block.timestamp >= vault.lastDistribution().add(delay);\n​\n        execPayload = abi.encodeWithSelector(\n            IHarvester.harvestVault.selector,\n            address(vault)\n        );\n​\n        if (canExec) return(true, execPayload);\n    }\n​\n    return(false, bytes(\"No vaults to harvest\"));\n}\n5. Incorporating Feedback with Logs\nWith the Gelato Web3 Functions UI, you can use custom return messages to pinpoint where your checker might be \"stuck\":\nfunction checker()\n    external\n    view\n    returns (bool canExec, bytes memory execPayload)\n{\n    uint256 lastExecuted = counter.lastExecuted();\n​\n    if(block.timestamp - lastExecuted < 180) return(false, bytes(\"Time not elapsed\"));\n​\n    execPayload = abi.encodeCall(ICounter.increaseCount, (1));\n    return(true, execPayload);\n}\n6. Limit the Gas Price of your execution\nOn networks such as Ethereum, gas will get expensive at certain times. If what you are automating is not time-sensitive and don't mind having your transaction mined at a later point, you can limit the gas price used in your execution in your checker.\nfunction checker()\n\texternal\n\tview\n\treturns (bool canExec, bytes memory execPayload)\n{\n\t// condition here\n\t\n\tif(tx.gasprice > 80 gwei) return (false, bytes(\"Gas price too high\"));\n}\n​\nThis way, Gelato will not execute your transaction if the gas price is higher than 80 GWEI. \nPrevious\nTest, Deploy & Run Typescript functions\nNext\nTest, Deploy & Run Solidity Functions\nLast modified 2mo ago\nON THIS PAGE\n1. Understand the Role of a Checker\n2. Solidity Function Example\n3. Making your Checker Reusable\n4. Advanced: Checking Multiple Functions\n5. Incorporating Feedback with Logs\n6. Limit the Gas Price of your execution"
  },
  {
    "title": "Create a Web3 Function Task - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/understanding-web3-functions/create-a-web3-function-task",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n1⃣\nTrigger Types\n2⃣\nTypescript Function\n3⃣\nSolidity Function\n4⃣\nAutomated Transactions\n5⃣\nCreate a Web3 Function Task\n⏩\nUsing the UI\n⏩\nUsing a Smart Contract\n⏩\nUsing the Automate SDK\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n5⃣\nCreate a Web3 Function Task\nBefore creating a Web3 Function Task, make sure to Deploy a Web3 Function! Check out \nTest, Deploy & Run Typescript functions\n,\nTest, Deploy & Run Solidity Functions\n & \nInitiate an Automated Transaction\n \nOverview\nA Web3 Function Task links your Web3 Function to your target smart contract and enables you to configure what should trigger your Web3 Function to execute, any arguments you want to pass to it and the target smart contract to execute.\nWays to submit Web3 Function Tasks\n⏩\nUsing the UI\n⏩\nUsing a Smart Contract\n⏩\nUsing the Automate SDK\n​\nPrevious\nAutomated Transactions\nNext\nUsing the UI\nLast modified 2mo ago\nON THIS PAGE\nOverview\nWays to submit Web3 Function Tasks"
  },
  {
    "title": "Automated Transactions - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/understanding-web3-functions/automated-transactions",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n1⃣\nTrigger Types\n2⃣\nTypescript Function\n3⃣\nSolidity Function\n4⃣\nAutomated Transactions\n5⃣\nCreate a Web3 Function Task\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n4⃣\nAutomated Transactions\nWhat is an Automated Transaction?\nAutomated Transaction ensures that a specific function on the target smart contract gets reliably triggered. When you pre-define the inputs, it means that every time Gelato initiates the function call, it uses consistent, predetermined arguments.\nAutomation Transaction enable automation in conjunction with the various trigger types outlined on our \nTrigger Types\n page. \nEssential Roles for Automated Transactions\nConsistency: With set arguments, each function activation remains uniform.\nReliability: Minimize errors from inconsistent arguments, ensuring predictable function behavior.\nSimplicity: Avoid the complexities of decision-making or added input stages during execution.\nScenarios for Automated Transactions\n1.\nPeriodic Payments: Automate regular payments, like subscriptions or salaries, where the amount and recipient remain constant.\n2.\nMaintenance Operations: Execute routine smart contract operations, such as refreshing oracles or updating interest rates, where the action does not change.\n3.\nTrigger-Based Actions: For actions that must occur in response to a specific event, a transaction can be scheduled to execute when the event is observed.\n4.\nAutomated Token Transfers: Transfer tokens at specified intervals or when your contract’s logic deems it necessary, without additional input or variation.\nNext Steps\nHead over to the quick start on how to initiate an Automated Transaction: \nInitiate an Automated Transaction\n​\nPrevious\nSolidity Function\nNext\nCreate a Web3 Function Task\nLast modified 2mo ago\nON THIS PAGE\nWhat is an Automated Transaction?\nEssential Roles for Automated Transactions\nScenarios for Automated Transactions\nNext Steps"
  },
  {
    "title": "Solidity Function - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/understanding-web3-functions/solidity-function",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n1⃣\nTrigger Types\n2⃣\nTypescript Function\n3⃣\nSolidity Function\n4⃣\nAutomated Transactions\n5⃣\nCreate a Web3 Function Task\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n3⃣\nSolidity Function\nWhat are Solidity Functions?\nSolidity functions are essentially a piece of logic written in Solidity that determines whether certain conditions are met to execute a task.\nSolidity Functions enable automation in conjunction with the various trigger types outlined on our \nTrigger Types\n page. \nEssential Role of Solidity Functions\nEnsure Precision: They ensure that functions are triggered only when the right conditions are met.\nBoost Efficiency: By automating repetitive and conditional tasks, they save time and resources.\nEnhance Flexibility: Developers can encode a variety of conditions, allowing for a wide range of automated functionalities.\nScenarios for Solidity Function Automation\n1.\nOn-Chain Logic is Required: Use them when the logic for your automation needs to reside entirely on the blockchain.\n2.\nFine tune gas price: Limit the gas price of the execution ensuring your automation doesn't overpay network fees. \n3.\nSecurity and Immutability are Key: Automated tasks that require the highest level of security benefit from Solidity's immutable contract execution environment.\nNext steps\nHead over to the quick start on how to write Solidity Functions: \nWriting Solidity Functions\n​\nPrevious\nTypescript Function\nNext\nAutomated Transactions\nLast modified 2mo ago\nON THIS PAGE\nWhat are Solidity Functions?\nEssential Role of Solidity Functions\nScenarios for Solidity Function Automation\nNext steps"
  },
  {
    "title": "Relay Context Contracts ERC2771 - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/erc-2771-recommended/callwithsyncfeeerc2771/relay-context-contracts-erc2771#transferring-fees-to-gelato",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n1⃣\nsponsoredCallERC2771\n2⃣\ncallWithSyncFeeERC2771\n🍧\nRelay Context Contracts ERC2771\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🍧\nRelay Context Contracts ERC2771\nGetting your smart contracts compatible with Gelato Relay's callWithSyncFeeERC2771\nIf you are using @gelatonetwork/relay-sdk v3 or contracts from the package @gelatonetwork/relay-context v2 please follow this migration guide to migrate to the new versions.\nAfter reading this page: \nYou'll learn how to use our helper functions to get useful information from directly within your target contract. \nThese allow you access to the feeCollector, feeToken address , fee, and _msgSenderamount from within your target contract.\nWhen using callWithSyncFeeERC2771, you need to pay Gelato's fee collecting contract when your target function is called, otherwise your relay request will not execute. To carry out this payment, your target contract needs to know the address of the fee collector so that you can transfer funds during the call. Furthermore, you need to know in what token to pay the fee in, and how much to pay the fee collector. \nGelato Relay appends this useful information to the end of the calldata, when using the callWithSyncFeeERC2771 SDK method.  Gelato Relay's Context contracts give you helper functions which you can use via inheritance in your target contract allowing you to decode information from the relay calldata, giving you access to:\n uint256 _getFee(): a value denoting how much fee to pay.\n address _getFeeToken(): the address of the token the fee is paid in.\naddress _getFeeCollector(): the address to which to send your payment.\naddress _getMsgSender(): the address of the off-chain signer.\nNOTE: \nIf you need target function needs to know all four variables from the relay calldata, see GelatoRelayContextERC2771. \nIf you only need the feeCollector address (i.e. you already encode the fee and feeToken inside your own function parameters), see GelatoRelayFeeCollectorERC2771.\nGetting Started\nInstalling relay-context \nrelay-context is an extremely simple way to create a Gelato Relay compatible smart contract, with just one import.\nnpm: @gelatonetwork/relay-context\nnpm\nTerminal\nNote: please make sure to use version v3.0.0 and above.\nnpm install --save-dev @gelatonetwork/relay-context\nor\nyarn add -D @gelatonetwork/relay-context\nSmart Contract\n1\nimport {\n2\n    GelatoRelayContextERC2771 \n3\n} from \"@gelatonetwork/relay-context/contracts/GelatoRelayContextERC2771.sol\";\nfor GelatoRelayContextERC2771.\nOR:\nimport {\n    GelatoRelayFeeCollectorERC2771\n} from \"@gelatonetwork/relay-context/contracts/GelatoRelayFeeCollectorERC2771.sol\";\nfor GelatoRelayFeeCollectorERC2771.\nGelatoRelayContextERC2771\nGelatoRelayContextERC2771 allows your smart contract to retrieve the following information from the relay calldata:\n1.\nGelato's fee collector address, a contract specifically deployed for collecting relay fees securely. This allows a smart contract to transfer fees directly if you are using the syncFee payment method.\n2.\nThe fee token address specifying which address the fee will be paid in, which Gelato resolved from the original relay-SDK request body.\n3.\nThe fee itself, which includes the gas cost + Gelato's 10% fee on top.\n4.\nThe _getMsgSender() address, the off-chain signer address. \nBelow is an example:\n1\n// SPDX-License-Identifier: MIT\n2\npragma solidity 0.8.17;\n3\n​\n4\nimport {\n5\n    GelatoRelayContextERC2771\n6\n} from \"@gelatonetwork/relay-context/contracts/GelatoRelayContextERC2771.sol\";\n7\n​\n8\ncontract Counter is GelatoRelayContextERC2771 {\n9\n    mapping(address => uint256) public counter;\n10\n    \n11\n    event IncrementCounter();\n12\n    \n13\n    // `increment` is the target function to call\n14\n    // this function increments a counter variable after payment to Gelato\n15\n    function increment() external onlyGelatoRelay {\n16\n        // Payment to Gelato\n17\n        // NOTE: be very careful here!\n18\n        // if you do not use the onlyGelatoRelay modifier,\n19\n        // anyone could encode themselves as the fee collector\n20\n        // in the low-level data and drain tokens from this contract.\n21\n        _transferRelayFee();\n22\n​\n23\n        counter[_getMsgSender()] += 1;\n24\n​\n25\n        emit IncrementCounter();\n26\n    }\n27\n}\nLine 21 inherits the GelatoRelayContextERC2771 contract, giving access to these features:\nVerifying the caller:\nonlyGelatoRelay: a modifier which will only allow Gelato Relay to call this function.\n_isGelatoRelay(address _forwarder): a function which returns true if the address matches Gelato Relay's address.\nDecoding the calldata:\n_getFeeCollector() : a function to retrieve the fee collector address.\n_getFee(): a function to retrieve the fee that Gelato will charge. \n_getFeeToken(): a function to retrieve the address of the token used for fee payment.\n_getMsgSender(): a function to retrieve the off-chain signer address.\n_getMsgData():  a function to access the original msg.data without appended information.\nTransferring Fees to Gelato\nAs you are using the callWithSyncFeeERC2771 SDK method, you can use the below helper functions to pay directly to Gelato:\n_transferRelayFee(): a function which transfers the fee amount to Gelato, with no cap. \n_transferRelayFeeCapped(uint256 _maxFee): a function which transfers the fee amount to Gelato which a set cap from the argument maxFee in wei. This helps limit fees on function calls in case of gas volatility or just for general budgeting.\nGelatoRelayFeeCollectorERC2771\nWhy are there two different contracts that I can inherit? \nYou can choose to inherit either GelatoRelayContextERC2771 or GelatoRelayFeeCollectorERC2771. GelatoRelayContextERC2771 gives you access to all four pieces of information: feeCollector, feeToken, fee, and msg.sender whereas GelatoRelayFeeCollectorERC2771 assumes only the feeCollector and the msg.sender addresses are appended to the calldata.\nWhich contract should I inherit?\nIn the majority of scenarios, inheriting from GelatoRelayContextERC2771 is recommended. This approach provides the most convenient way to handle fees, as it only requires you to call either the _transferRelayFee() or _transferRelayFeeCapped(uint256 _maxFee) method. All other processes are managed seamlessly behind the scenes.\nIf the fee is known in advance - for instance, if you have already queried our fee oracle for the fee amount and a user has given their approval on this amount and the token to be used for payment via a front-end interface - you would only need to inform your smart contract where to direct this fee. In this case, you would require only the feeCollector address. For this purpose, please inherit from GelatoRelayFeeCollectorERC2771. Refer to the following details.\nRecommendation: maximum fee signing\nThe fee oracle allows you to query and display a fee to your users before sending their transaction via Gelato Relay. Therefore, you could also give them the option to sign off on a certain fee. In this case, you might want to pass the fee you receive from the oracle directly to your target function as an argument.\nThis makes sense, but be wary that due to gas price volatility, a smoother UX might be to query the fee oracle and calculate a maximum fee by adding some overhead, and displaying this maximum fee to the user. This way, if gas prices do fluctuate more than normal, you can be certain that your user's transaction is executed. You can choose to set a very large overhead, or a smaller one, depending on your own trade-off between execution likelihood and cost to the user. This way, you can also integrate a fee check from inside target function to avoid any overpayments. \nGelatoRelayFeeCollectorERC2771 Integration\nGelatoRelayFeeCollector allows your smart contract to retrieve the following information from the relay calldata:\n1.\nGelato's fee collector address, a contract specifically deployed for collecting relay fees securely. This allows a smart contract to transfer fees directly if you are using the syncFee payment method.\n2.\nThe _getMsgSender() address, the off-chain signer address. \nBelow is an example:\n1\n// SPDX-License-Identifier: MIT\n2\npragma solidity 0.8.17;\n3\n​\n4\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n5\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n6\nimport {\n7\n    SafeERC20\n8\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n9\nimport {\n10\n    GelatoRelayFeeCollectorERC2771\n11\n} from \"@gelatonetwork/relay-context/contracts/GelatoRelayFeeCollectorERC2771.sol\";\n12\n​\n13\ncontract Counter is GelatoRelayFeeCollectorERC2771 {\n14\n    using SafeERC20 for IERC20;\n15\n    mapping(address => uint256) public counter;\n16\n    \n17\n    event IncrementCounter();\n18\n    \n19\n    // `increment` is the target function to call\n20\n    // this function increments a counter variable after payment to Gelato\n21\n    function increment() external onlyGelatoRelay {\n22\n        // Retreiving the feeCollector address, using the nativeToken\n23\n        address feeCollector = _getFeeCollector();\n24\n        address nativeToken = \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\"; \n25\n        // Hardcoding the fee to 100 wei - NOTE: this is just for example\n26\n        // If you do not pay enough to feeCollector, \n27\n        // your relay request will not go through\n28\n        // In reality, you should pass in user signatures TODO\n29\n        uint256 fee = 100;\n30\n        \n31\n        // Payment to Gelato\n32\n        // NOTE: be very careful here!\n33\n        // if you do not use the onlyGelatoRelay modifier,\n34\n        // anyone could encode themselves as the fee collector\n35\n        // in the low-level data and drain tokens from this contract.\n36\n        transfer(nativeToken, feeCollector, fee);\n37\n​\n38\n        counter[_getMsgSender()] += 1;\n39\n        emit IncrementCounter();\n40\n    }\n41\n    \n42\n    \n43\n    function transfer(\n44\n        address _token,\n45\n        address _to,\n46\n        uint256 _amount\n47\n    ) internal {\n48\n        if (_amount == 0) return;\n49\n        _token == NATIVE_TOKEN\n50\n            ? Address.sendValue(payable(_to), _amount)\n51\n            : IERC20(_token).safeTransfer(_to, _amount);\n52\n    }\n53\n}\nLine 13 inherits the GelatoRelayFeeCollectorERC2771 contract, giving access to these features:\nVerifying the caller:\nonlyGelatoRelay: a modifier which will only allow Gelato Relay to call this function.\n_isGelatoRelay(address _forwarder): a function which returns true if the address matches Gelato Relay's address.\nDecoding the calldata:\n_getFeeCollector() : a function to retrieve the fee collector address.\n_getMsgSender(): a function to retrieve the off-chain signer address.\n_getMsgData():  a function to access the original msg.data without appended information.\nPrevious\ncallWithSyncFeeERC2771\nNext\nNon-ERC-2771\nLast modified 4mo ago\nON THIS PAGE\nGetting Started\nInstalling relay-context\nGelatoRelayContextERC2771\nGelatoRelayFeeCollectorERC2771\nWhy are there two different contracts that I can inherit?\nWhich contract should I inherit?\nGelatoRelayFeeCollectorERC2771 Integration"
  },
  {
    "title": "Relay Context Contracts - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/non-erc-2771/callwithsyncfee/relay-context-contracts",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n3⃣\nsponsoredCall\n2⃣\ncallWithSyncFee\n🍧\nRelay Context Contracts\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🍧\nRelay Context Contracts\nGetting your smart contracts compatible with Gelato Relay's callWithSyncFee\nAfter reading this page: \nYou'll learn how to use our helper functions to get useful information from directly within your target contract. \nThese allow you access to the feeCollector, feeToken address , and fee amount from within your target contract.\nWhen using callWithSyncFee, you need to pay Gelato's fee collecting contract when your target function is called, otherwise your relay request will not execute. To carry out this payment, your target contract needs to know the address of the fee collector so that you can transfer funds during the call. Furthermore, you need to know in what token to pay the fee in, and how much to pay the fee collector. \nGelato Relay appends this useful information to the end of the calldata, when using the callWithSyncFee SDK method.  Gelato Relay's Context contracts give you helper functions which you can use via inheritance in your target contract allowing you to decode information from the relay calldata, giving you access to:\n uint256 _getFee(): a value denoting how much fee to pay.\n address _getFeeToken(): the address of the token the fee is paid in.\naddress _getFeeCollector(): the address to which to send your payment.\nNOTE: \nIf you need target function needs to know all three variables from the relay calldata, see GelatoRelayContext. \nIf you only need the feeCollector address (i.e. you already encode the fee and feeToken inside your own function parameters), see GelatoRelayFeeCollector.\nGetting Started\nInstalling relay-context \nrelay-context is an extremely simple way to create a Gelato Relay compatible smart contract, with just one import. \nnpm: @gelatonetwork/relay-context\nnpm\nTerminal\nNote: please make sure to use version v3.0.0 and above.\nnpm install --save-dev @gelatonetwork/relay-context\nor\nyarn add -D @gelatonetwork/relay-context\nSmart Contract\n1\nimport {\n2\n    GelatoRelayContext \n3\n} from \"@gelatonetwork/relay-context/contracts/GelatoRelayContext.sol\";\nfor GelatoRelayContext.\nOR:\nimport {\n    GelatoRelayFeeCollector\n} from \"@gelatonetwork/relay-context/contracts/GelatoRelayFeeCollector.sol\";\nfor GelatoRelayFeeCollector.\nGelatoRelayContext\nGelatoRelayContext allows your smart contract to retrieve the following information from the relay calldata :\n1.\nGelato's fee collector address, a contract specifically deployed for collecting relay fees securely. This allows a smart contract to transfer fees directly if you are using the syncFee payment method.\n2.\nThe fee token address specifying which address the fee will be paid in, which Gelato resolved from the original relay-SDK request body.\n3.\nThe fee itself, which includes the gas cost + Gelato's fee on top.\nBelow is an example:\n1\n// SPDX-License-Identifier: MIT\n2\npragma solidity 0.8.17;\n3\n​\n4\nimport {\n5\n    GelatoRelayContext\n6\n} from \"@gelatonetwork/relay-context/contracts/GelatoRelayContext.sol\";\n7\n​\n8\n// Inheriting GelatoRelayContext gives access to:\n9\n// 1. onlyGelatoRelay modifier\n10\n// 2. payment methods, i.e. _transferRelayFee\n11\n// 3. _getFeeCollector(), _getFeeToken(), _getFee()\n12\ncontract Counter is GelatoRelayContext {\n13\n    uint256 public counter;\n14\n    \n15\n    event IncrementCounter();\n16\n    \n17\n    // `increment` is the target function to call\n18\n    // this function increments a counter variable after payment to Gelato\n19\n    function increment() external onlyGelatoRelay {\n20\n        // Remember to autheticate your call since you are not using ERC-2771\n21\n        // _yourAuthenticationLogic()\n22\n            \n23\n        // Payment to Gelato\n24\n        // NOTE: be very careful here!\n25\n        // if you do not use the onlyGelatoRelay modifier,\n26\n        // anyone could encode themselves as the fee collector\n27\n        // in the low-level data and drain tokens from this contract.\n28\n        _transferRelayFee();\n29\n​\n30\n        counter++;\n31\n​\n32\n        emit IncrementCounter();\n33\n    }\n34\n}\nLine 12 inherits the GelatoRelayContext contract, giving access to these features:\nVerifying the caller:\nonlyGelatoRelay: a modifier which will only allow Gelato Relay to call this function.\n_isGelatoRelay(address _forwarder): a function which returns true if the address matches Gelato Relay's address.\nDecoding the calldata:\n_getFeeCollector() : a function to retrieve the fee collector address.\n_getFee(): a function to retrieve the fee that Gelato will charge. \n_getFeeToken(): a function to retrieve the address of the token used for fee payment.\nTransferring Fees to Gelato:\nAs you are using the callWithSyncFee SDK method, you can use the below helper functions to pay directly to Gelato:\n_transferRelayFee(): a function which transfers the fee amount to Gelato, with no cap. \n_transferRelayFeeCapped(uint256 _maxFee): a function which transfers the fee amount to Gelato which a set cap from the argument maxFee in wei. This helps limit fees on function calls in case of gas volatility or just for general budgeting.\nGelatoRelayFeeCollector\nWhy are there two different contracts that I can inherit? \nYou can choose to inherit either GelatoRelayContext or GelatoRelayFeeCollector. GelatoRelayContext gives you access to all three pieces of information: feeCollector, feeToken, and fee, whereas GelatoRelayFeeCollector assumes only the feeCollector address is appended to the calldata.\nWhich contract should I inherit?\nIn the majority of scenarios, inheriting from GelatoRelayContext is recommended. This approach provides the most convenient way to handle fees, as it only requires you to call either the _transferRelayFee() or _transferRelayFeeCapped(uint256 _maxFee) method. All other processes are managed seamlessly behind the scenes.\nIf the fee is known in advance - for instance, if you have already queried our fee oracle for the fee amount and a user has given their approval on this amount and the token to be used for payment via a front-end interface - you would only need to inform your smart contract where to direct this fee. In this case, you would require only the feeCollector address. For this purpose, please inherit from GelatoRelayFeeCollector. Refer to the following details.\nRecommendation: maximum fee signing\nThe fee oracle allows you to query and display a fee to your users before sending their transaction via Gelato Relay. Therefore, you could also give them the option to sign off on a certain fee. In this case, you might want to pass the fee you receive from the oracle directly to your target function as an argument.\nThis makes sense, but be wary that due to gas price volatility, a smoother UX might be to query the fee oracle and calculate a maximum fee by adding some overhead, and displaying this maximum fee to the user. This way, if gas prices do fluctuate more than normal, you can be certain that your user's transaction is executed. You can choose to set a very large overhead, or a smaller one, depending on your own trade-off between execution likelihood and cost to the user. This way, you can also integrate a fee check from inside target function to avoid any overpayments. \nGelatoRelayFeeCollector Integration\nGelatoRelayFeeCollector allows your smart contract to retrieve the following information from the relay calldata:\nGelato's fee collector address, a contract specifically deployed for collecting relay fees securely. This allows a smart contract to transfer fees directly if you are using the syncFee payment method.\nBelow is an example:\n1\n// SPDX-License-Identifier: MIT\n2\npragma solidity 0.8.17;\n3\n​\n4\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n5\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n6\nimport {\n7\n    SafeERC20\n8\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n9\nimport {\n10\n    GelatoRelayFeeCollector\n11\n} from \"@gelatonetwork/relay-context/contracts/GelatoRelayFeeCollector.sol\";\n12\n​\n13\ncontract Counter is GelatoRelayFeeCollector {\n14\n    using SafeERC20 for IERC20;\n15\n    uint256 public counter;\n16\n    \n17\n    event IncrementCounter();\n18\n    \n19\n    // `increment` is the target function to call\n20\n    // this function increments a counter variable after payment to Gelato\n21\n    function increment() external onlyGelatoRelay {\n22\n        // Remember to autheticate your call since you are not using ERC-2771\n23\n        // _yourAuthenticationLogic()\n24\n​\n25\n        // Retreiving the feeCollector address, using the nativeToken\n26\n        address feeCollector = _getFeeCollector();\n27\n        address nativeToken = \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\"; \n28\n        // Hardcoding the fee to 100 wei - NOTE: this is just for example\n29\n        // If you do not pay enough to feeCollector, \n30\n        // your relay request will not go through\n31\n        // In reality, you should pass in user signatures TODO\n32\n        uint256 fee = 100;\n33\n        \n34\n        // Payment to Gelato\n35\n        // NOTE: be very careful here!\n36\n        // if you do not use the onlyGelatoRelay modifier,\n37\n        // anyone could encode themselves as the fee collector\n38\n        // in the low-level data and drain tokens from this contract.\n39\n        transfer(nativeToken, feeCollector, fee);\n40\n​\n41\n        counter++;\n42\n​\n43\n        emit IncrementCounter();\n44\n    }\n45\n    \n46\n    \n47\n    function transfer(\n48\n        address _token,\n49\n        address _to,\n50\n        uint256 _amount\n51\n    ) internal {\n52\n        if (_amount == 0) return;\n53\n        _token == NATIVE_TOKEN\n54\n            ? Address.sendValue(payable(_to), _amount)\n55\n            : IERC20(_token).safeTransfer(_to, _amount);\n56\n    }\n57\n}\nLine 13 inherits the GelatoRelayFeeCollector contract, giving access to these features:\nVerifying the caller:\nonlyGelatoRelay: a modifier which will only allow Gelato Relay to call this function.\n_isGelatoRelay(address _forwarder): a function which returns true if the address matches Gelato Relay's address.\nDecoding the calldata:\n_getFeeCollector(): a function to retrieve the fee collector address.\nPrevious\ncallWithSyncFee\nNext\nGelato's Fee Oracle\nLast modified 4mo ago\nON THIS PAGE\nGetting Started\nInstalling relay-context\nGelatoRelayContext\nGelatoRelayFeeCollector\nWhy are there two different contracts that I can inherit?\nWhich contract should I inherit?\nGelatoRelayFeeCollector Integration"
  },
  {
    "title": "Typescript Function - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/understanding-web3-functions/typescript-function",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n1⃣\nTrigger Types\n2⃣\nTypescript Function\n3⃣\nSolidity Function\n4⃣\nAutomated Transactions\n5⃣\nCreate a Web3 Function Task\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n2⃣\nTypescript Function\nWhat are Typescript Functions?\nTypescript Functions are decentralized cloud functions. They enable developers to execute on-chain transactions based on arbitrary off-chain data (APIs / subgraphs, etc) & computation. These functions are written in Typescript, stored on IPFS and run by Gelato. \nTypescript Functions enable automation in conjunction with the various trigger types outlined on our \nTrigger Types\n page. \nEssential Role of Typescript Functions\nSeamless Integration with Off-Chain Data: They provide an elegant solution for incorporating real-time data from the outside world, enabling smart contracts to respond to external events and changes.\nEnhanced Computation Capabilities: Typescript Functions allow for complex calculations that would be too gas-intensive to perform on-chain, facilitating more sophisticated decision-making processes in your DApps.\nCustomizable Logic Execution: Developers can bring the full power of Typescript to create flexible advanced logic to deliver their application use cases.\nNext steps\nHead over to our quick start guide and get hands on with writing typescript functions:\n​\nWriting Typescript Functions\n​\nWhen you use an on-chain event to trigger your Typescript function you can tap into the full context of this event - learn more here:\n​\nEvent Trigger\n​\nPrevious\nTrigger Types\nNext\nSolidity Function\nLast modified 2mo ago\nON THIS PAGE\nWhat are Typescript Functions?\nEssential Role of Typescript Functions\nNext steps"
  },
  {
    "title": "Trigger Types - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/understanding-web3-functions/trigger-types",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n1⃣\nTrigger Types\n2⃣\nTypescript Function\n3⃣\nSolidity Function\n4⃣\nAutomated Transactions\n5⃣\nCreate a Web3 Function Task\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n1⃣\nTrigger Types\n1. Time Interval\nUse this trigger to execute tasks at regular intervals, e.g., every 10 minutes or once every 24 hours. It's like setting a straightforward, recurring alarm.\n2. Cron Expressions\nThis offers a more refined control compared to the Time Interval. With cron expressions, you can set tasks to run at specific moments, such as \"every Tuesday at 3 PM\" or \"on the 1st of every month\". It gives you precision in task scheduling.\n3. On-Chain Event\nIdeal for those wanting their tasks to respond dynamically to blockchain activities. Whenever a specified event occurs on the blockchain, e.g. \n   //event creation with argument types and names\n   event ownerChanged(address indexed _from, address indexed _to);\nthis trigger springs your task into action. \n4. Every Block\nThis function operates with the rhythm of the blockchain itself, executing your chosen function each time a new block is created.\nNote: Irrespective of the trigger type you opt for, you can tie it to running any of the following:\nTypescript Function\nSolidity Function\nTransaction\nPrevious\nUnderstanding Web3 Functions\nNext\nTypescript Function\nLast modified 2mo ago"
  },
  {
    "title": "Subscription Plans - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/1balance/subscription-plans",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\n1Balance Alerts\nSubscription Plans\nSubscription Notifications\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nSubscription Plans\nHow to view and manage your Gelato subscription plans\nOverview\nWe have launched subscription plans for some of our services to provide your project with access to increased thresholds and premium features at a predictable monthly cost, billed seamlessly from 1Balance.\nWeb3 Functions is the first Gelato service to have this feature. When you go to your 1Balance page and login you will see which subscription plan(s) you have active. By default you are enrolled on our free Accelerate plan which we subsidize. \nYour active subscription is shown on your 1Balance page\nClicking on Limits & costs unfolds a panel that details your plan limits and the premiums applied to your transactions. For more information on how these work please see the Fees & Limits section in Web3 Functions. \nUpgrading your subscription\nYou can upgrade your subscription immediately at any time. Click on the Manage button to display the subscriptions managements page.\nTo upgrade your plan, simply click on the Upgrade button for the plan you would like to move up to. You will be asked to confirm the selection. On confirmation, payment will be taken from your 1Balance and your new limits will take immediate effect. \nHow subscription payments work\nSubscription plans renew monthly. 3-days before the end of the month the system will take payment for the upcoming month. For example, on 28th June the system will take payment for your July subscription. If you have insufficient balance, the system will retry every 24 hours. \nIf payment has not been taken by the start of your new month the system will downgrade you to the free plan.\nWe are working on an alerts service to notify you of any upcoming subscription payments and warn you of any problems taking payment\nCustom Subscription Plans\nWe offer tailored plans for customers with particular limit or transaction premium needs. We encourage you to reach out to us to discuss your requirements.\nWhen you have upgraded to a custom plan you will see your limits and costs when you are logged into your account.\nDowngrading & Cancelling\nYou can cancel or downgrade your plan at any time. \nDowngrades or cancellations take effect from the end of the calendar month in which they are triggered. For example, if you are on the Growth Plan and cancel mid-June then you will be downgraded to the Accelerate plan from 1syt July onwards. \nIf you Cancel or Downgrade and change your mind before the end of the month you can reactivate your current plan at any point before the end of the month.\nNotifications\nTo receive email notifications regarding upcoming subscription payments and renewals please setup your notifications.\nPrevious\n1Balance Alerts\nNext\nSubscription Notifications\nLast modified 1mo ago\nON THIS PAGE\nOverview\nUpgrading your subscription\nHow subscription payments work\nCustom Subscription Plans\nDowngrading & Cancelling\nNotifications"
  },
  {
    "title": "ERC-2771 Delegatecall Vulnerability - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/security-considerations/erc-2771-delegatecall-vulnerability",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n⚠\nERC-2771 Delegatecall Vulnerability\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n⚠\nERC-2771 Delegatecall Vulnerability\nMake sure your contracts are not affected by the recently disclosed vulnerability\nPlease read the following resources from OpenZeppelin and ThirdWeb explaining the vulnerability:\n​Arbitrary Address Spoofing Attack: ERC2771Context Multicall Public Disclosure​\n​Security Vulnerability Incident Report 12/8​\nVulnerability explained\nERC-2771 is a standard enabling contracts to authenticate users during transaction relaying. Before delving into the security risks of its implementation, it is crucial to understand the mechanics of the ERC-2771 flow.\nERC-2771 Overview\nUser Request Signing\nThe user signs their request and incorporates this signature into the payload.\nRelay Contract Verification\nThe relay contract validates the signature and appends the user's 20-byte address to the end of the calldata.\nTarget Contract Decoding\nThe target contract decodes the user address by extracting the last 20 bytes from the calldata, but only when msg.sender is the relay contract, known as the Trusted Forwarder.\nDecoding is done using assembly for efficiency, as shown in the following code snippet:\n// Decoding the user Address\nfunction _msgSender() internal view virtual override returns (address sender) {\n    if (isTrustedForwarder(msg.sender)) {\n        // The assembly code is more direct than the Solidity version using `abi.decode`.\n        assembly {\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\n        }\n    } else {\n        return super._msgSender();\n    }\n}\nRisks of delegatecall\nContext Preservation in delegatecall\nWhen Contract A invokes Contract B using delegatecall(), msg.sender in Contract B remains the original caller, as delegatecall() preserves the caller's context.\nAddress Extraction in ERC-2771\nAs outlined above, extracting the original user address involves verifying that msg.sender is the Trusted Forwarder, then retrieving the user address from the final 20 bytes of callData.\nERC-2771 Relayer Specifics\nIf an ERC-2771 Relayer is employed and the target method uses delegatecall() to its own address (address(this).delegatecall(...)), the Trusted Forwarder check will always pass, as msg.sender will consistently be the Gelato Relay Contract.\nIn scenarios where the target method modifies the calldata, it becomes uncertain whether the last 20 bytes accurately represent the original user when _msgSender() is invoked.\n🚨 If you're implementing delegatecall() in conjunction with ERC-2771, please reach out to us for assistance. We'll help ensure that your implementation is robust and secure.\nVulnerability conditions\nThe vulnerability described arises when all three of the following conditions are met in a smart contract. It's crucial to avoid these conditions concurrently.\nAvoid the following conditions in the same smart contract:\n1.\nImplementation of ERC2771Context or assumptions on data from the trusted forwarder: the contract either implements ERC2771Context or operates under the assumption that data from the trusted forwarder will be appended to and subsequently extracted from the calldata.\n2.\nUse of delegatecall to Self-Contract: the contract uses delegatecall to call itself, typically indicated by address(this).delegatecall(...).\n3.\nCalldata manipulation: situations involving the manipulation of calldata, common in functions like multicall.\n🚨 Avoid multicall in combination with ERC-2771\nThe vulnerability is evident in a typical multicall function, structured as follows:\nfunction multicall(bytes[] calldata data) external returns(bytes[] memory results) {\n    results = new bytes[](data.length);\n    for(uint i = 0; i < data.length; i++) {\n        (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n        require(success);\n        results[i] = result;\n    }\n    return results;\n}\nVulnerability Mechanism\nWithin the loop, delegateCall() is executed, targeting the contract itself (address(this).delegatecall(data[i]).\nWhen _msgSender() is evaluated within this call, it does not return the original user who signed the transaction. Instead, it yields the last 20 bytes of data[i].\nPotential for Exploitation\nA malicious actor could exploit this by appending a victim's address at the end of data[i].\nAs a result, _msgSender() would erroneously identify the victim's address as the validated user who signed the transaction, leading to potential security breaches.\n​✅ Safe multicall & ERC-2771 implementation\nTo securely implement multicall in conjunction with ERC-2771, it is recommended to manually append the context to each data[i], as outlined in OpenZeppelin's blog. The approach involves the following steps:\nfunction multicall(bytes[] calldata data) external returns(bytes[] memory results) {\n    bytes memory context = msg.sender == _msgSender()\n        ? new bytes(0)\n        : msg.data[msg.data.length - 20:];\n    results = new bytes[](data.length);\n    for(uint i = 0; i < data.length; i++) {\n        (bool success, bytes memory result) = \n            address(this).delegatecall(bytes.concat(data[i], context));\n        require(success);\n        results[i] = result;\n    }\n    return results;\n}\nKey Points\nContext Determination: The context is derived by comparing msg.sender and _msgSender(). If they match, no additional context is appended. Otherwise, the last 20 bytes of msg.data are used.\nSecure Delegatecall: By appending the context to each data[i] before the delegatecall, the function ensures that the original sender's address is correctly interpreted in subsequent calls.\nRobust Error Handling: The use of require(success) after each delegatecall ensures that any call that fails will halt the execution, maintaining the integrity of the operation.\n\n\n\nPrevious\nSecurity Considerations\nNext\nInstallation\nLast modified 1mo ago\nON THIS PAGE\nVulnerability explained\nVulnerability conditions\n🚨 Avoid multicall in combination with ERC-2771\n✅ Safe multicall & ERC-2771 implementation"
  },
  {
    "title": "Governance Process - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/gelato-dao/governance-process",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nGovernance Process\nOne of the GEL token's core functions is to facilitate the governance of the Gelato DAO. \nThe following Medium article describes how our governance process currently operates. \nGelato Network Governance Process\nMedium\nGELATO DAO - Previous\nGEL Token Contracts\nNext\nSocial Media\nLast modified 1yr ago"
  },
  {
    "title": "GEL Token Contracts - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/gelato-dao/gel-token-contracts",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nGEL Token Contracts\nThe official GEL token contract addresses for each network on which it has been deployed are:\nChain\nGEL Token Contract Address\nEthereum (ERC20)\n0x15b7c0c907e4C6b9AdaAaabC300C08991D6CEA05\nFantom\n0x15b7c0c907e4C6b9AdaAaabC300C08991D6CEA05\nPolygon \n0x15b7c0c907e4C6b9AdaAaabC300C08991D6CEA05\nAny \"GEL\" token with a contract address that is not listed on this page is a fake.\nGELATO DAO - Previous\nDAO & Token (GEL)\nNext - GELATO DAO\nGovernance Process\nLast modified 1yr ago"
  },
  {
    "title": "Social Media - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/social-media",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nSocial Media\nDiscord: https://discord.com/invite/ApbA39BKyJ​\nTwitter: https://twitter.com/gelatonetwork​\nTelegram: https://t.me/gelatonetwork​\n​\nGELATO DAO - Previous\nGovernance Process\nLast modified 2mo ago"
  },
  {
    "title": "DAO & Token (GEL) - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/gelato-dao/dao-and-token-gel",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nDAO & Token (GEL)\nFrom day one, Gelato was envisioned to be an open-source and community-driven project. Gelato is designed to be a protocol owned by the people who use it the most. Making decisions in the Network should be done by all the stakeholders collaboratively giving the power back to the people. \nIn order to achieve this, the Gelato DAO was created. The Gelato DAO is powered by the Gelato token (GEL). The Gelato token is the central focal point of all relevant stakeholders in the network. The token exists as a utility for effective incentive alignment amongst the protocols' participants. Token holders will be able to signal their support for or opposition to Proposals in the Gelato DAO.\n1) Governance\nAll token holders are able to have a say in the future direction of the protocol via voting on proposals in the Gelato DAO. The goal is that in the long run, developers that use Gelato to automate their smart contracts functions will govern over the protocol in order to determine the “rules” by which the Executor bots that serve the network have to adhere by.\nDecisions include setting fees for Executors, deciding on developer incentive schemes, and enforcing that Executors always execute transactions in the best interest of the end-user.\n2) Staking\nFor Executors, in order to be able to participate in executing transactions in the Gelato Network and thus earning rewards from doing so, they will need to acquire & stake $GEL. Staking will allow executors to earn the ability to reserve “slots’’ which give them the exclusive right to earn fees from executing transactions in a certain period of time.\nRewards revenue comes from two sources: 1) transaction fees charged on top of each transaction and 2) market opportunities that can be taken advantage of by back running transactions.\n\nWe are currently heavily optimizing for increasing the number of transactions because this will be the most important factor determining the future success of Gelato in the long run.\nPotentially slashing the stake of Executors will serve the purpose of disincentivizing bad behavior, such as censoring or front running transactions, making such actions uneconomical. The Gelato DAO will have the power to enforce these decisions and the obligation to monitor the behavior of Executors. Executors will become more accountable for their actions which will enable us to further decentralize who can run these Nodes as well as providing some interesting future functionalities such as executing transactions based on off-chain conditions.\nGEL staking, similar to ETH 2.0, is done by operators of the clients as they are doing the work and are also running the risk of getting punished for being down. \nFor passive GEL holders, we envisage that services similar to Lido will emerge that will provide regular holders access to GEL staking rewards without having to actually do the hard work by charging a fee on the revenue earned by these GEL holders. \nThe control of the bots will thus be distributed to the dApps and developers that are using Gelato the most by overseeing the protocol and influencing the decisions within the infrastructure of the network. The infrastructure is designed to extract as much value out of the system to ensure that they continue to operate in the best interests of the end-user. \nWith the Gelato DAO, stakeholders of the network will have the power to check, verify and influence these bots continuously certifying that they are operating as intended. Having a stake in the network will allow governance to monitor and regulate the network of bots ensuring that they are playing by the rules set by the DAO to always operate in the best interests of the user.   \nTotal Supply\nThe initial supply of the Gelato Token will be 420,690,000. After two years, additional tokens can be minted if the Token Holders vote in favor of such a proposal. \n\nHead over to our Medium post for more details.\nGelato Treasury: \nTreasury Address: https://etherscan.io/address/0x163407FDA1a93941358c1bfda39a868599553b6D​\nDAO Address: https://etherscan.io/address/0x4C64ce7C270E1316692067771bbb0DCe6Ec69B7C​\nPrevious\nLegacy Automate Migration Guide\nNext - GELATO DAO\nGEL Token Contracts\nLast modified 2mo ago\nON THIS PAGE\n1) Governance\n2) Staking\nTotal Supply\nGelato Treasury:"
  },
  {
    "title": "Automate (Legacy) - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/automate-legacy",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nAutomate (Legacy)\nReliable, developer-friendly & decentralized smart contract automation\nDeprecation Notice: Gelato Functions is set to replace Automate, providing enhanced automation capabilities, access to off-chain data, unified payments across networks, and a performance boost. Migrate your tasks to Gelato Functions before Legacy Automate's end of life on June 30th, 2024 for uninterrupted service.\nQuick Start\nNew to smart contract automation? To quickly understand the process and how Gelato Automate enables you to automate a contract yourself, we recommend running through the Tutorial. \nGelato Automate provides an intuitive, self-service app for you to create and manage your automation tasks. Before diving we recommend you:\n1.\nCheck we support the network the contract you want to automate is on\n2.\nDoes your task match the types of tasks that can be automated?\n3.\nWhat is going to trigger your task? Is it based on a time frequency? If so Gelato Automate already has you covered. If it is based on more complex conditions (for example, when the yield to harvest exceeds the costs of doing so) then you'll need to consider writing a resolver. \n4.\nWhat arguments does your task require? Are they static or do they also need to be provided from your resolver?\nWith this information you should be good to go through the same Tutorial steps to automate your your real-world contract. The Template real-world examples may also be useful for you. \nIf you hit any problems or have any questions, please do reach out to the team and we'll be happy to help you. \n​\nPrevious\nSupported Networks\nNext\nSupported Networks\nLast modified 2mo ago"
  },
  {
    "title": "Supported Networks - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/supported-networks",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n✅\nSupported Networks\nPlease note that our support for the Goerli, Optimism Goerli, and Arbitrum Goerli test networks will be discontinued after December 31, 2023. We recommend users to transition their operations to Sepolia, Optimism Sepolia, or Arbitrum Sepolia to ensure uninterrupted service and support.\nThe following networks are supported:\nName\nDeployment\nEthereum\nMainnet\nTestnet\nPolygon\nMainnet\nTestnet\nFantom\nMainnet\nAvalanche\nMainnet\nBinance Smart Chain\nMainnet\nOptimism\nMainnet\nTestnet\nArbitrum\nMainnet\nTestnet\nGnosis\nMainnet\nTestnet\nzkSync Era\nMainnet\nTestnet\nPolygon zkEVM\nMainnet\nBase\nMainnet\nTestnet\nLinea\nMainnet\nAstar\nTestnet\nGelato OP\nTestnet\nTangible Unreal\nTestnet\nIf you don't see a network that you'd like supported, feel free to reach out to us.\nPrevious\nAnalytics & Monitoring\nNext\nContract Addresses\nLast modified 1mo ago"
  },
  {
    "title": "VRF - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/vrf",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\n📙\nUnderstanding VRF\n❔\nHow does Gelato VRF Work?\n🔓\nSecurity Considerations\n📄\nTemplate\n🚀\nQuick Start\n💡\nMigrating from Chainlink VRF\n💰\nPricing & Rate Limits\n✅\nSupported Networks\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nVRF\nIn the world of cryptography and decentralized applications, randomness plays a critical role. While randomness is a foundational concept, achieving genuine unpredictability in a transparent and verifiable manner on the blockchain is challenging. Enter Gelato VRF (Verifiable Random Function) - a tool designed to provide robust randomness with inherent verifiability.\nNew to VRFs?\n📙\nUnderstanding VRF\nAlready Familiar?\n🚀\nQuick Start\n🔓\nSecurity Considerations\nPrevious\nPricing & Rate Limits\nNext\nUnderstanding VRF\nLast modified 1mo ago\nON THIS PAGE\nNew to VRFs?\nAlready Familiar?"
  },
  {
    "title": "Contract Addresses - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/contract-addresses",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🔗\nContract Addresses\nWeb3 Functions during the private beta uses a custom deployment of the `Automate.sol` contract as an entry point. \n\nOn the Automate smart contract users create or cancel and Gelato executes tasks. By default, Web3 Functions uses the dedicated msg.sender module, which means all transactions to the defined destination contract will be routed via your dedicated msg.sender proxy contract. \nNote: If you have an access restriction in your smart contract function and want to whitelist your personal Gelato smart contract wallet as a msg.sender, you don't need to do anything. We automatically deploy your own dedicated msg.sender for you at the first task creation  - the address to whitelist will be shown in the UI and can also be retrieved via the Automate SDK.\nAll other networks\nZkSync Era\nContract\nAddress\nAutomate\n0x2A6C106ae13B558BB9E2Ec64Bd2f1f7BEFF3A5E0\n1Balance (where you deposit funds)\n0x7506C12a824d73D9b08564d5Afc22c949434755e\nPrevious\nSupported Networks\nNext\nPricing & Rate Limits\nLast modified 2mo ago"
  },
  {
    "title": "Analytics & Monitoring - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/analytics-and-monitoring",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🔍\nAnalytics & Monitoring\nTask Performance Dashboard\nGelato's Web3 Function UI offers enriched monitoring and analytics capabilities, allowing you to closely track the performance and usage statistics of your Typescript and Solidity function tasks.\nUsage Insights: Get a clear picture of how much you've used from your Web3 function plan. Our intuitive metrics and forecast charts help you understand your current usage and predict future needs.\nTask Identification: Quickly figure out if a task is powered by Typescript or Solidity. This feature simplifies how you view and manage your suite of Gelato Web3 functions.\nTrend Tracking: Our updated chart design lets you track how your usage changes day-to-day, providing insights for better planning and task management.\nPlan Details: Know exactly what you're getting with your subscription. \nLogs & Status\nBesides the task logs available in the UI, Gelato Web3 Functions offer a more detailed and granular monitoring system providing status and logs APIs.\nTask Status URL\nProvided the ChainId and taskId,  this API will return the current Task status\nhttps://api.gelato.digital/tasks/web3functions/networks/{chainId}/tasks/{taskId}/status\nFor example, if your chainId, taskId are:\nchainId: 137\ntaskId: 0xdeaeee394c952d8b23c86eacc704adf7b605d89d992cec9a5fc86e4a517f053b\nThen the URL to go to is:\nhttps://api.gelato.digital/tasks/web3functions/networks/137/tasks/0xdeaeee394c952d8b23c86eacc704adf7b605d89d992cec9a5fc86e4a517f053b/status\nFor this taskId, here is the returned task information:\n{\n    \"task\":{\n    \"chainId\":137,               \n    \"taskId\":\n\"0xdeaeee394c952d8b23c86eacc704adf7b605d89d992cec9a5fc86e4a517f053b\",\n    \"taskState\":\"CheckPending\",\n    \"creationDate\":\"2023-06-01T20:10:39.985Z\",\n    \"lastCheckDate\":\"2023-06-09T06:22:44.966Z\",\n    \"lastCheckMessage\":\"Fail to run Web3Function: Web3Function exited with code=1\",\n    \"lastExecDate\":\"2023-06-09T08:15:11.883Z\",\n    \"lastExecTransactionHash\":\n\"0xc2e57f5b56bf24ae77eca31fbe76ecf16cd30cb0fc5592207bb567addff62402\"\n          }\n }\nThe first thing to look at is the taskState key:\nTask states:\nFor the taskState key, these are the possible values:\nCheckPending: the task is pending simulation.\nExecPending: the task is executable and is awaiting inclusion into the blockchain.\nWaitingForConfirmation: the task was included into the blockchain but is still awaiting the required amount of blocks confirmations.\nExecSuccess: the task has been successfully executed.\nCancelled: the task has been canceled by the owner\nExecReverted: the task transaction has been reverted.\nTask  Logs URL\nProvided the ChainId and taskId,  this API will return the logs in the last 24 hours, the query param limit is optional\nhttps://api.gelato.digital/tasks/web3functions/networks/{chainId}/tasks/{taskId}/logs?limit=NrLogs\nFor example, if your chainId, taskId and NrLogs are:\nchainId: 137\ntaskId: 0xdeaeee394c952d8b23c86eacc704adf7b605d89d992cec9a5fc86e4a517f053b\nNrLogs:2\nThen the URL to go to is:\nhttps://api.gelato.digital/tasks/web3functions/networks/137/tasks/0xdeaeee394c952d8b23c86eacc704adf7b605d89d992cec9a5fc86e4a517f053b/logs?limit=2\nFor this taskId, here is the returned task information:\n{\n    {\"logs\":\n      [\n        {\"date\":\"2023-06-09T08:43:52.404Z\",\n        \"state\":\"WaitingForConfirmation\",\n        \"type\":\"WaitingForConfirmation\",\n        \"message\":\"txHash: 0x788726ed95f2f916a47cae0c6cdfbea91e1c8e3756f91e0efc08fa501daed8f0\"\n        },\n        {\"date\":\"2023-06-09T08:43:51.835Z\",\n        \"state\":\"ExecPending\",\n        \"type\":\"ExecPendingCheck\",\n        \"message\":\"Task submitted for execution\",\n        \"web3FunctionLogs\":[\"Text generated: \",\"Chaffinches are small, colourful birds which feed on seeds and insects. They have buff-coloured breasts streaked with brown markings, bright pinkish-red faces and wings marked with white bars. In summer they breed in woodlands; in winter many move south to warmer areas.\",\"Text generated: \",\"Chameleons are lizards known for their ability to change color, excellent vision and long, sticky tongues used to catch prey.\"]\n        }\n    ]\n}\nAlerts\nWeb3 Functions provides an alerting service to enable you to get notified about your task executions, problems or when your balance is getting low. Alerting currently supports notifications in Telegram and Discord, with other channels on the way.\nTypes of notifications\nType\nDescription\nBalance\nIf your task uses Gelato Balance you need to ensure that you always have enough funds deposited, otherwise your executions will stop executing until you top-up. \n\nSet a balance alert to be notified when your funds are running low - you can use our default levels or set your own threshold.\nSetting up Telegram Notifications\nYou can visit your notifications area to follow the steps listed below.\n1.\nAdd GelatoWatcherBot to your Telegram - if you have Telegram installed you can just click on the link to do this.  \n2.\nEnter the command /start\n3.\nThe bot will show you the main alerts that you can request by entering the command.\nWhen you enter each command the bot will step you through the inputs required to finish setting up the alert. \nYou can view the full list of commands at any time by entering /help\nTelegram Bot Commands\nCommand\nUsage\n/balance\nAlerts when your Gelato Balance drops below the minimum balance threshold. The default thresholds are listed here. \n​\nThe bot will prompt you for the wallet address that you use to create and manage your tasks. \n​\nTo provide multiple addresses enter each one as a new message to the bot.\n​\nIf you use the same wallet address across multiple networks, you will be alerted when any of these drop below the default thresholds.\n\nIf you would like to set your own threshold use the /balance_threshold command.\n/balance_threshold\nAlerts you when your Gelato Balance drops below the threshold you set on a specific network.\n\nAfter entering the /balance_threshold command the bot will prompt you to specify the chain IDs and your threshold level. Chain IDs are listed here. \n\n\nFor example to be alerted when your Gelato Balance drops below 0.15 ETH on mainnet you would enter 1,0.15\n/list_threshold\nList all custom and default balance thresholds of each network\nDiscord DM Notifications\nIn this mode you receive your alerts as DM's to your Discord handle. To activate:\n1.\nJoin our Gelato Discord server​\n2.\nChoose from the list of commands below\nIf you would prefer to receive alerts in a specific channel please see how to get Discord notifications in your server.\nCommand\nUsage\n/balance-dmaddress\nAlerts when your Gelato Balance drops below the default threshold for the specified wallet address. The default thresholds are listed below. \n​\nTo provide multiple addresses enter a new command to the bot for each address.\n​\nIf you use the same wallet address across multiple networks, you will be alerted when any of these drop below the default thresholds.\n\nTo set your own threshold use the /balance-threshold-dm command.\n/balance-threshold-dm chain_id threshold\nAlerts you when your Gelato Balance drops below the threshold you set on a specific network.\n\nUse the /balance-dm command to set the address(es) that you would like to monitor. \n\nChain IDs are listed here. \n\n\nFor example to be alerted when your Gelato Balance drops below 0.15 ETH on mainnet you would enter 1 0.15\n/list-threshold-dm\nList all custom and default balance thresholds of each network\nDiscord notifications in your own server\n1.\nAdd our Gelato Bot to your server using this invite link (you need to be admin of the server)\n2.\nIf you want to receive notifications in a private channel, make sure to add Gelato Bot as a member in the channel where you want to receive the notification.\n3.\nEnter the following commands in the channel you want to receive alerts.\nCommand\nUsage\n/balance-channeladdress\nAlerts when your Gelato Balance drops below the default threshold for the specified wallet address. The default thresholds are listed below. \n​\nTo provide multiple addresses enter a new command to the bot for each address.\n​\nIf you use the same wallet address across multiple networks, you will be alerted when any of these drop below the default thresholds.\n\nTo set your own threshold use the /balance-threshold-dm command.\n/balance-threshold-channel chain_id threshold\nAlerts you when your Gelato Balance drops below the threshold you set on a specific network.\n\nUse the /balance-dm command to set the address(es) that you would like to monitor. \n\nChain IDs are listed here. \n\n\nFor example to be alerted when your Gelato Balance drops below 0.15 ETH on mainnet you would enter 1 0.15\n/list-threshold-channel\nList all custom and default balance thresholds of each network\n/stop-balance-channel\nSwitch off all low balance alerts\nDefault Thresholds\nUnless overridden these are the default levels that are used for each network.\nNetwork\nChain ID\nDefault Threshold\nEthereum\n1\n0.05 ETH\nPolygon\n137\n20 MATIC\nFantom\n250\n20 FTM\nAvalanche\n43114\n0.5 AVAX\nBNB Chain\n56\n0.05 BNB\nOptimism\n10\n0.05 ETH\nArbitrum\n42161\n0.05 ETH\nGnosis\n100\n5 XDAI\nzkSync Era\n324\n​\nPolygon zkEVM\n1101\n​\nBase\n8453\n​\nLinea\n59144\n​\nIf you need more notifications or new communication channels, your feedback and suggestions are always welcome. \nPrevious\nInitiate an Automated Transaction\nNext\nSupported Networks\nLast modified 1mo ago\nON THIS PAGE\nTask Performance Dashboard\nLogs & Status\nTask Status URL\nTask Logs URL\nAlerts\nTypes of notifications\nDiscord DM Notifications\nDiscord notifications in your own server\nDefault Thresholds"
  },
  {
    "title": "Security Considerations - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/security-considerations",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🔐\nSecurity Considerations\nDedicated msg.sender\nFor security reasons, during task creation, you will see an address which will be the msg.sender for your task executions.\nIf you are the owner of the target contract in question, it's recommended to implement a msg.sender restriction within your smart contract. This involves whitelisting a dedicated msg.sender address. Such a measure ensures that only tasks you have created can call your function, significantly elevating the security posture of your operations. For a hands-on guide and to manage your dedicated msg.sender settings, please connect to the app and visit your own Settings page.\nRemember that your dedicated msg.sender can vary across different blockchain networks. You can view the dedicated msg.sender for each network through the provided settings link.\nmsg.sender restrictions should be added to the function that Gelato will call during execution, not the checker function. Learn more about it here: \n1.-understand-the-role-of-a-checker\n​\nYou can have this restriction by inheriting AutomateReady​\nAutomateReady exposes a modifier onlyDedicatedMsgSender which restricts msg.sender to only task executions created by taskCreator defined in the constructor.\n    modifier onlyDedicatedMsgSender() {\n        require(msg.sender == dedicatedMsgSender, \"Only dedicated msg.sender\");\n        _;\n    }\nIf you would like to have additional callers for your function. You can implement a whitelist like so.\n    mapping(address => bool) public whitelisted;\n​\n    modifier onlyWhitelisted() {\n        require(\n            whitelisted[msg.sender] || msg.sender == dedicatedMsgSender,\n            \"Only whitelisted\"\n        );\n        _;\n    }\n​\nPrevious\nUsing the Automate SDK\nNext\nTemplate & Use Cases\nLast modified 1mo ago"
  },
  {
    "title": "Template & Use Cases - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/template-and-use-cases",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n📝\nTemplate & Use Cases\nTemplate\nTypescript Function \nHardhat Template\nGitHub - gelatodigital/web3-functions-hardhat-template: A template to get started using Gelato Web3 Functions in your hardhat dev environment.\nGitHub\nVanilla Template\nGitHub - gelatodigital/web3-functions-template: Gelato Web3 Functions template & examples\nGitHub\nSolidity Function\nHardhat Template\nGitHub - gelatodigital/automate-unit-testing: The purpose of this repo is to showcase unit tests examples of using Gelato Automate in a Hardhat enviroment.\nGitHub\nFoundry Template\nGitHub - gelatodigital/gelato-automate-foundry-template: Gelato Automate examples on Foundry\nGitHub\nUse Cases Repo\nGithub repo listing the existing use-cases and PoCs to speed run your learning.\nGitHub - gelatodigital/w3f-use-cases-demos: Repository with all W3F use cases and PoC\nGitHub\nQuick Links Use Cases\n​BProtocol Liquidation​\n​Pyth Oracle PoC​\n​RedStone Oracle PoC​\n​Contract dynamically creating Web3 Functions​\n​Shared Storage between Tasks​\n​Automatic Bribing​\n​Lens GPT​\n​Gelato Nft Bot​\n​Enzyme Vault​\n​Airdrop Claiming​\n​Automated Topup​\n​Aggregate Fee Swapper​\n​Gasless CCTP​\nPrevious\nSecurity Considerations\nNext\nQuick Start\nLast modified 2mo ago\nON THIS PAGE\nTemplate\nTypescript Function\nSolidity Function\nUse Cases Repo\nQuick Links Use Cases"
  },
  {
    "title": "Quick Start - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/quick-start",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n➡\nWriting Typescript Functions\n➡\nTest, Deploy & Run Typescript functions\n➡\nWriting Solidity Functions\n➡\nTest, Deploy & Run Solidity Functions\n➡\nInitiate an Automated Transaction\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🚀\nQuick Start\nWelcome to the Quick Start guide for Web3 Functions! Whether you're familiarizing yourself with Typescript Functions, diving deep into Solidity Functions, or aiming to set up simple Transactions, this guide is tailor-made for you.\nIn this Quick Start, you'll:\nUnderstand and navigate the Typescript Function process from writing to deployment.\nMaster the art of crafting a Solidity Function.\nGet acquainted with the simplicity of Transactions, where no additional coding is required; just pick your contract and function.\nGenerate tasks for your Typescript Function, Solidity Function or Transaction seamlessly.\nDive in, and let's get started with Web3's Functions functionalities!\nPrevious\nTemplate & Use Cases\nNext\nWriting Typescript Functions\nLast modified 2mo ago"
  },
  {
    "title": "Understanding Web3 Functions - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/understanding-web3-functions",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n1⃣\nTrigger Types\n2⃣\nTypescript Function\n3⃣\nSolidity Function\n4⃣\nAutomated Transactions\n5⃣\nCreate a Web3 Function Task\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n📙\nUnderstanding Web3 Functions\nDetermining your Needs\nOff-chain Data or Computation?\nSometimes, automation tasks require data that isn't readily available on the blockchain, or they might need computations that are better performed off-chain. In such cases, Typescript Functions should be the choice.\nAll Checks On-chain?\nIf all the conditions necessary for your automation task can be directly verified on the blockchain, you have the option to select between Typescript Functions, Solidity Functions & Automated Transactions\nImplementation path\nStep\nDescription\n1.\nHow you want to trigger your run?\nStart by deciding on the type of trigger you want to use. (Time, event, or every block)\n2.\nWhat to run?\nTypescript Function\nSolidity Function\nTransaction\n3.\nTask Creation\nCreate a Web3 Function task to allow the execution of typescript, solidity or transaction\n3.\nFinalize & Monitor\nOnce you've defined your function ensure you monitor its execution to confirm that it works as expected. Make any necessary adjustments.\n​\nCore Features of Web3 Functions\nMain features of Web3 Functions include Typescript Functions, Solidity Functions & Automated Transactions\nBefore jumping into the core features of the Web3 Functions, it is highly recommended that you first learn how you'd like to trigger your run. To learn more:\n1⃣\nTrigger Types\nLearn more about each of the 3 actions that your trigger can run:\n2⃣\nTypescript Function\n3⃣\nSolidity Function\n4⃣\nAutomated Transactions\nPre-Requisite of Target Smart Contract\nSmart contract functions in the target contract that can be automated should follow these properties:\nThey need to be functions that are usually called by the development team or external keepers, not \"user facing\" functions called by users directly\nThey need to be either public or external\nThey do not have access restrictions like an onlyOwner modifier, unless the user's dedicated msg.sender address is whitelisted through the proxy module.\nThey do not require msg.sender to be tx.origin\nServices - Previous\nWeb3 Functions\nNext\nTrigger Types\nLast modified 2mo ago\nON THIS PAGE\nDetermining your Needs\nOff-chain Data or Computation?\nAll Checks On-chain?\nImplementation path\nCore Features of Web3 Functions\nPre-Requisite of Target Smart Contract"
  },
  {
    "title": "Relay - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/relay",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nNetworks & Rate Limits\n💸\nPayment & Fees\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nRelay\nEnabling developers to get transactions validated fast, reliably and securely\nGelato Relay enables web3 developers like you to get on with what you do best, building. Gelato handles the blockchain complexities for you, every step of the way, from the moment you initiate the transaction, to the moment it is validated on-chain. We take the utmost care to make sure your transaction is relayed from off-chain to successfully carried out on-chain in the shortest amount of time, reliably within the next few blocks, and with no downtime. \nWe support 17 EVM networks and a multitude of ways to pay using either native or ERC-20 tokens. In combination with Gelato 1Balance, a flexible cross-chain gas tank system which allows for payment across all supported networks using just one balance on the chain of your choosing.\nWhat is the Gelato Relay SDK?\nGelato Relay SDK offers a convenient suite of functions in order to interact with the Gelato Relay API. Gelato Relay API is a service that allows users and developers to get transactions validated fast, reliably and securely, without having to deal with the low-level complexities of blockchains.\nOverview of how Gelato Relay works\nAs requests are submitted to Gelato Relay, a network of decentralised Gelato Executors will execute and get the transactions validated as soon as possible. EIP-712 signatures enforce the integrity of data, while gas fee payments can be handled in any of our supported payment methods. In this way, developers can rely on Gelato's battle-tested blockchain infrastructure improving the UX, costs, security and liveness of their Web3 systems.​ \nSecurity Considerations\nWhile Gelato Relay offers very powerful features, improper implementation can introduce vulnerabilities in your contracts. We strongly recommend always using the built-in ERC-2771 user signature verification found in our sponsoredCallERC2771 or callWithSyncFeeERC2771 methods to enhance security.\nPlease read the Security Considerations section to understand all potential security risks and measures to mitigate them when using a Gelato Relay.\nHow can I get started with gasless transactions?\n1.\nDeploy a compatible contract, or use one of ours (see code example links below).\n2.\nRun the code examples found on each SDK method page:\n​sponsoredCallERC2771​\n​callWithSyncFeeERC2771​\n​sponsoredCall​\n​callWithSyncFee​\nThat's all it takes to get started with Gelato Relay and the Gelato Relay SDK! \nWe hope you have as much fun using Gelato Relay as we did building it! \n😄\n \nAny feedback, please get in touch!\nAPI Docs\nIf your codebase is not JS compatible, you can use the Gelato Relay API directly. Please find the API docs here. \nPrevious\neth_chainId\nNext\nWhat is Relaying?\nLast modified 2mo ago\nON THIS PAGE\nWhat is the Gelato Relay SDK?\nSecurity Considerations\nHow can I get started with gasless transactions?\nAPI Docs"
  },
  {
    "title": "Web3 Functions - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nWeb3 Functions\nOverview\nGelato's Web3 Functions is a powerful automation system designed to streamline and enhance Web3 operations. Web3 Functions serve as a comprehensive tool, enabling developers to effortlessly set up, manage, and automate their smart contract tasks.\nNew to Web3 Functions? \n📙\nUnderstanding Web3 Functions\nAlready familiar with Web3 Functions? \n🚀\nQuick Start\n🔐\nSecurity Considerations\nPrevious\nJoin our Discord\nNext\nUnderstanding Web3 Functions\nLast modified 2mo ago\nON THIS PAGE\nOverview\nNew to Web3 Functions?\nAlready familiar with Web3 Functions?"
  },
  {
    "title": "Account Abstraction - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/account-abstraction",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nAccount Abstraction\nERC-4337 Compatible Bundler & Paymaster\nUsers interact with Ethereum using externally owned accounts (EOAs) which are public-private key pairs. Anyone with access to the private key can perform actions within the rules of the Ethereum Virtual Machine (EVM). By design, the Ethereum network can only go through state transition when an EOA triggers a transaction and consequently pays a gas fee in ETH. These factors limit how users can interact with the blockchain.\n1.\nPoor security\n1.\nLost private keys cannot be recovered\n2.\nCompromised private keys give attackers instant access to all funds in the account\n3.\nRigid security rules (e.g., must use ECDSA)\n2.\nLack of customization\n1.\nMust initiate or sign every transaction\n2.\nNot programmable (i.e., can not define custom rules)\n3.\nGas payment\n1.\nAccount must hold ETH at all times in order to cover transaction fees\n2.\nCan not use other tokens (e.g., ERC20)\nSmart contract wallets are the solution to these problems by allowing users to flexibly program better security and user experiences into their accounts. Account abstraction enables smart contracts to initiate transactions themselves, without the user having to manage a separate EOA and ETH balance. This opens up the door to many exciting use cases.\nWhat is a Smart Wallet?\nSmart wallets are wallets controlled by smart contracts following the ERC-4337 specification. Ethereum has two types of accounts:\n1.\nExternally Owned Accounts (EOAs)\n2.\nContract Accounts (Smart Contracts)\nA Contract Account is managed by a Smart Contract rather than an EOA and relies on code instead of private keys to secure and recover wallet information.\nBenefits of Smart Wallets\n1.\nFully programmable\nCan do anything a smart contract can\nUpgradeable to add new features\n2.\nArbitrary verification logic & recovery\nECDSA (EOA controller account)\nSocial Login\nSession Keys\nBiometric\n3.\nAtomic multi-operations\nCombine multiple transactions into a single atomic transaction\nBetter efficiency as call overhead is only incurred once\nE.g., approve & spend tokens\n4.\nGasless transactions\nFully sponsored & ERC-20 payment\nCompatible with all smart contracts out of the box\n5.\nSemi-abstracted nonces\nConcurrent execution channels\nWhy ERC-4337?\nUnlike other proposals, ERC-4337 avoids changes to the consensus layer itself increasing the chance of faster adoption.\nTerminology\nSender\nThe sender is an ERC-4337 compatible smart contract wallet storing the users assets.\nIt must implement the following interface:\ninterface IAccount {\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external returns (uint256 validationData);\n}\nUserOperation\nA UserOperation is a pseudo-transaction object sent by the user into an alternate mempool.\nIt contains the following fields:\nField\nType\nDescription\nsender\naddress\nAccount requesting the operation\nnonce\nuint256\nAnti-replay parameter\ninitCode\nbytes\nAccount creation code (only required if not yet created i.e., first transaction)\ncallData\nbytes\nData passed to sender during execution\ncallGasLimit\nuint256\nGas allocated for main execution\nverificationGasLimit\nuint256\nGas allocated for verification\npreVerificationGas\nuint256\nAmount allocated to compensate the bundler for any gas overhead not tracked on-chain by the EntryPoint\nmaxFeePerGas\nuint256\nSimilar to EIP-1559​\nmaxPriorityFeePerGas\nuint256\nSimilar to EIP-1559​\npaymasterAndData\nbytes\nPaymaster address and callData (empty for self-sponsored transactions)\nsignature\nbytes\nData passed to the account along with the nonce during the verification step\nEntryPoint\nThe EntryPoint is a singleton smart contract that handles the verification and execution of bundles of UserOperations. This ensures much of the complicated logic is not required in the wallet itself and Instead, wallets trust the EntryPoint to perform proper validation (similar to a trusted forwarder).\nBundler\nA bundler is a node that bundles together multiple UserOperations from an alternate mempool and forwards them to the EntryPoint contract as a single transaction. The bundler executes transactions via EOAs which cover the transaction fees upfront and are later compensated. The Gelato Bundler is built on top of the existing Gelato Relay service and sponsors transactions via 1Balance.\nSee Advantages & Highlights.\nPaymaster\nA paymaster is a service that covers transaction fees on behalf of the user. Unlike other solutions, Gelato does not rely on the on-chain EntryPoint to compensate transaction costs. Instead, fees are settled by the 1Balance paymaster post-execution which avoids overcharging users and reduces the overall on-chain footprint.\nSee Advantages & Highlights.\nPrevious\nSubscription Notifications\nNext\nSupported Networks\nLast modified 2mo ago"
  },
  {
    "title": "1Balance - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/1balance",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\n1Balance Alerts\nSubscription Plans\nSubscription Notifications\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n1Balance\nGelato's unified multi-chain payments system\nOverview\nWhen you use each of Gelato's services there are two costs that you need to pay:\nGas costs of your executed transactions (or those of your end users if you are sponsoring them)\nService fees - Gelato subscriptions or % premiums on the gas costs of each transaction\n1Balance makes it easy for you to pay all of your costs across all the networks that you are using from one single easy-to-manage balance.\nSupported Gelato Services\n​Relay and Web3 Functions are currently integrated with 1Balance. \nGetting Started\nTo get started with 1Balance on mainnets you will need USDC on Polygon (plus some MATIC to cover Polygon gas costs for depositing). We will be extending 1Balance support to other networks. \nWe currently support the bridged version of USDC, USDCe. Make sure you are using the correct USDC token by verifying the contract address. For your convenience, here is the contract address for USDCe on Polygon:\nUSDC.e Contract Address: 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174​\n1.\n​Access the 1Balance in the Gelato app​\n2.\nConnect your wallet if you have not already done so\n3.\nSwitch to Polygon\n4.\nClick on deposit and then approve USDC into your 1Balance\n\n\n\n5.\nAfter confirming your deposit transaction in your wallet you will see a Pending deposit appear in your deposits history: \n\n\n\nOnce the required number of confirmations has been reached your deposit will be credited and your 1Balance is ready for use. \n1Balance does not yet support withdrawals - this feature will be added soon. Please select your deposit amount accordingly.\nFees\nMore details on the fees applied by each service are available:\n​Relay Fees and more detailed guide to using 1Balance with Relay\n​Web3 Function Fees​\nLow Balance Alerts\nTo ensure that your transactions execute as you expect, it is critical that you have sufficient funds deposited in 1Balance. To help you monitor your balance and receive alerts when it drops below you preferred threshold, we provide a 1Balance Alerts service.​\nINTRODUCTION - Previous\nExecutor Operators\nNext\n1Balance Alerts\nLast modified 1mo ago"
  },
  {
    "title": "Executor Operators - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/introduction/executor-operators",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nExecutor Operators\nIntroduction to Gelato's \"bots\"\nWhat is an Executor?\nExecutors are Gelato Network participants who provide infrastructure as a service to execute transactions as instructed by users of the Gelato Network. Executors are also referred to as “bots” or \"keepers\".\nHow do they work?\nExecutors receive tasks to be executed via the network Checkers. All Gelato Checkers are connected to all Executors on the network and when a task becomes executable it is shared among the Executors.\nAs soon as Executor receives a task to be executed, the Executor usually performs a simulation and if the simulation does well, the Executor submits the transaction on chain. The Executor then checks for its inclusion on every new block, and, in case of a task execution needing a resubmission, the Executor is responsible for bumping the gas price and re-submitting it.\nCoordination of Executors\nOne of the early core inventions of the Gelato Network was to coordinate task executions on a single platform amongst a broad set of transaction relayers (\"Executors\"). Whilst many Defi protocols that need decentralised keeper services default to primitive coordination mechanisms, such as asking executors to outbid each other in expensive gas wars, Gelato Network employs a coordination mechanism amongst its executors that comes at a fraction of the cost to miners and avoids racing conditions and winner-takes-all games. \n​\nNode operators that take part in the execution of tasks on the Gelato Network are running parallelised software that allocates a distinct portion of the global task pool to them at any given time. This parallel algorithm ensures none of the Executors are forced into expensive bidding wars with other Executors.  One of the breakthroughs of recent Gelato V2 developments was to move from the primitive Round-Robin mechanism it pioneered to a fully parallelised task distribution algorithm that ensures that all open Gelato tasks can be serviced by Executors simultaneously, without racing conditions. \nWho can become an Executor?\nGelato currently works with a set of whitelisted partners who provide Executor services. A core aim for Gelato is to further decentralize and enable anyone with the right resources to become an Executor. Executors will be required to stake a GEL tokens to become an Executor - creating accountability and incentivising them to act in the best interests of the user and protocol. \nINTRODUCTION - Previous\nGelato Network Contracts\nNext - Services\n1Balance\nLast modified 1yr ago"
  },
  {
    "title": "eth_maxPriorityFeePerGas - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/account-abstraction/bundler-api-endpoints/eth_maxpriorityfeepergas",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\neth_sendUserOperation\neth_estimateUserOperationGas\neth_getUserOperationByHash\neth_getUserOperationReceipt\neth_supportedEntryPoints\neth_maxPriorityFeePerGas\neth_chainId\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\neth_maxPriorityFeePerGas\nPlease refer to 1Balance & Relay to create a sponsorApiKey.\nThis method is implemented for compatibility reasons and always returns zero.\nPrevious\neth_supportedEntryPoints\nNext\neth_chainId\nLast modified 1mo ago"
  },
  {
    "title": "eth_supportedEntryPoints - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/account-abstraction/bundler-api-endpoints/eth_supportedentrypoints",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\neth_sendUserOperation\neth_estimateUserOperationGas\neth_getUserOperationByHash\neth_getUserOperationReceipt\neth_supportedEntryPoints\neth_maxPriorityFeePerGas\neth_chainId\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\neth_supportedEntryPoints\nPlease refer to 1Balance & Relay to create a sponsorApiKey.\nPrevious\neth_getUserOperationReceipt\nNext\neth_maxPriorityFeePerGas\nLast modified 1mo ago"
  },
  {
    "title": "eth_getUserOperationReceipt - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/account-abstraction/bundler-api-endpoints/eth_getuseroperationreceipt",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\neth_sendUserOperation\neth_estimateUserOperationGas\neth_getUserOperationByHash\neth_getUserOperationReceipt\neth_supportedEntryPoints\neth_maxPriorityFeePerGas\neth_chainId\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\neth_getUserOperationReceipt\nPlease refer to 1Balance & Relay to create a sponsorApiKey.\nPrevious\neth_getUserOperationByHash\nNext\neth_supportedEntryPoints\nLast modified 1mo ago"
  },
  {
    "title": "Gelato Network Contracts - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/introduction/gelato-network-contracts",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nGelato Network Contracts\nIntro to Gelato's use of the Diamond Proxy pattern\nGelato Network is designed to handle the rapidly evolving multi-chain landscape with its diversity of L1, L2 and sidechain designs. Significant differences can be found across aspects such as consensus mechanisms, block times, likelihood of block re-orgs and transaction fee models. \nTo handle the nuances that each blockchain design entails, GelatoV2 smart contracts follow a modular upgradeability standard: EIP-2535 Diamond Proxy.\nDiamond Proxy Pattern\nA Diamond contains:\nProxy contract that holds all state variables. \nFacets which are smart contracts that implement any desired functionality and can be replaced at any time. \nLibraries, which can be used to share state variables and utility functions across all Facets.\nBenefits of Diamond Proxy Pattern\nHaving a single smart contract holding all the state, while not running into issues of exceeding bytecode size. \nAbility to share state variables and functions between multiple Facets.\nFine-grained control in terms of which components of the protocol to upgrade. This means that protocol upgrades are gas-efficient.\nOptionality of changing GelatoV2 from upgradeable to immutable at any time, simply by revoking rights to upgrade Facets.\nImplementing GelatoV2 as a Diamond means that we can easily accommodate new use cases by eliminating integration friction with users and developers, adapt to lower level changes such as a chain changing from the legacy transaction fee model to EIP-1559, and simply adding or removing features as needed without enforcing strong opinions at the application interface level.\nGelatoV2 on Ethereum mainnet can be found here: https://louper.dev/diamond/0x3CACa7b48D0573D793d3b0279b5F0029180E83b6​\nFacets of GelatoV2\nBrief guide to the facets that make up GelatoV2 on Ethereum mainnet:\nFacet\nFunction\nDiamondCutFacet\nUsed to make upgrades to the Diamond, such as removing and adding new Facets, and possibly initialising their state variables upon deployment.\nDiamondLoupeFacet\nHelper smart contract which allows one to inspect all Facets in the Diamond at any given time.\nOwnershipFacet\nManage the ownership of GelatoV2, whose owner is currently the Gelato Multisig smart contract.\nAddressFacet\nManage Gelato specific utility smart contracts such as the gas price oracle and oracle aggregator.\nGelatoV1Facet\nBackward compatibility with GelatoV1.\nConcurrentCanExecFacet\nCoordination algorithm between multiple Gelato executors.\nExecAccessFacet\nManage Gelato executors.\nExecAccessFlashbotsFacet\nManage Gelato executors that submit their tasks as Flashbots bundles.\nExecAccountingFacet\nManage accounting of transaction fees, and soon also payroll to Gelato executors.\nExecFacet\nMain Facet. All tasks submitted to Gelato will be routed through the exec method.\nPrepaidExecFacet\nFacet where some use-case specific calls will be routed. Currently deprecated.\nUniswapV2SwapFacet\nSimilar to ExecFacet, but automatically handles token swaps upon payment. Currently deprecated.\nTransferFacet\nFee withdrawal from GelatoV2, managed by Gelato Multisig.\nImplementations of GelatoV2 on other chains can also be found on Louper. \nINTRODUCTION - Previous\nArchitecture\nNext - INTRODUCTION\nExecutor Operators\nLast modified 4mo ago"
  },
  {
    "title": "eth_getUserOperationByHash - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/account-abstraction/bundler-api-endpoints/eth_getuseroperationbyhash",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\neth_sendUserOperation\neth_estimateUserOperationGas\neth_getUserOperationByHash\neth_getUserOperationReceipt\neth_supportedEntryPoints\neth_maxPriorityFeePerGas\neth_chainId\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\neth_getUserOperationByHash\nPlease refer to 1Balance & Relay to create a sponsorApiKey.\nPrevious\neth_estimateUserOperationGas\nNext\neth_getUserOperationReceipt\nLast modified 1mo ago"
  },
  {
    "title": "Architecture - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/introduction/architecture",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nArchitecture\nArchitecture Overview\nAll Gelato's product run on the same core Gelato Network architecture which is responsible for ensuring that tasks are executed correctly and efficiently. \nIn essence the Gelato Network needs to continuously check if the conditions for a task to execute have been met and when they are met, execute the transaction and ensure that it gets confirmed as quickly and efficiently as possible. \nCore Components\nEvent Listener\nThe Event Listener is responsible for continuously querying the chain and monitoring emitted events. \nOn EVM compatible platforms, events are often used as a lower cost option to share data that is not required to be accessed on-chain (i.e data that does not need to be kept in storage thus requiring less gas consumption). Events allow external entities, like our Event Listener, to do efficient queries of indexed data. For a more detailed and technical description of events, please refer to the Solidity Event Documentation.\nEach Checker has access to the Event Listener and can subscribe to an arbitrary number of smart contracts and topics to watch. The tracked events are then decoded/translated into a specific data structure using predefined mappers, resulting in either a new task being created or existent tasks being updated/cancelled/executed.\nChecker\nThe Checker defines arbitrary/custom logic to check if a Gelato task is executable at a given moment. It defines the conditions required for a task to become executable. It can also define other conditions that can update a task's state, such as limit order cancellations.\nGelato Network is composable of several independent Checkers, such as Gelato Automate and Limit Orders for example.\nExecutor\nAn Executor is responsible to reliably submit transactions on chain and making sure that they are mined as quickly as possible with the lowest cost.\nFor a more detailed description of Executors, please refer to the Executor Operators section.\nINTRODUCTION - Previous\nHow it works\nNext - INTRODUCTION\nGelato Network Contracts\nLast modified 1yr ago"
  },
  {
    "title": "eth_estimateUserOperationGas - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/account-abstraction/bundler-api-endpoints/eth_estimateuseroperationgas",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\neth_sendUserOperation\neth_estimateUserOperationGas\neth_getUserOperationByHash\neth_getUserOperationReceipt\neth_supportedEntryPoints\neth_maxPriorityFeePerGas\neth_chainId\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\neth_estimateUserOperationGas\nPlease refer to 1Balance & Relay to create a sponsorApiKey.\nThe estimated preVerificationGas is always zero as it is not required by the bundler. Instead, transaction fees are settled post-execution which avoids overcharging the user. Other implementations unconditionally charge users the entire preVerificationGas amount since this is not metered by the EntryPoint.\nSee Advantages & Highlights.\nPOST\nhttps://api.gelato.digital\n/bundlers/{chainId}/rpc\neth_estimateUserOperationGas\n\nReturns estimated gas values for a UserOperation.\n\nParameters\nPath\nchainId*\nnumber\nTarget network chain identifier.\nQuery\nsponsorApiKey*\nstring\n1Balance API key which covers transaction costs.\nBody\nExample\nSchema\n{​\n  \"id\": 0,​\n  \"jsonrpc\": \"2.0\",​\n  \"method\": \"eth_estimateUserOperationGas\",​\n  \"params\": [​\n    {​\n      \"sender\": \"string\",​\n      \"nonce\": \"string\",​\n      \"initCode\": \"string\",​\n      \"callData\": \"string\",​\n      \"signature\": \"string\",​\n      \"paymasterAndData\": \"0x\"​\n    },​\n    \"0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789\"​\n  ]​\n​}\nResponses\n200: OK\nSuccessful response\n400: Bad Request\nValidation error\nPrevious\neth_sendUserOperation\nNext\neth_getUserOperationByHash\nLast modified 30d ago"
  },
  {
    "title": "How it works - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/introduction/how-it-works",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nHow it works\nOur mission is to provide developers with modular web3 devops services they can use to build decentralized and robust protocols.\nTo accomplish this, Gelato Network operates as a marketplace bringing together two parties: developers wanting to automate transactions on one side and infrastructure operators on the other side who run executor bots looking for tasks to complete in return for a small fee. \nKey Benefits\n1.\nNo need to self-host servers on AWS or other cloud providers\n2.\nRPC aggregation with multiple fallbacks\n3.\nReliable transaction relay service that always gets transactions mined fast\n4.\nCatches reorgs automatically\n5.\nMulti-chain; works with the most popular EVM-compatible networks\n6.\nNo single point of failure; multiple Executors are operating all over the world\n7.\nNo need to self-manage your private key in the cloud\n8.\nBuilt-in consensus / coordination layer to avoid racing conditions\n9.\nFlexible payment options; pay with a prepaid balance or have txs pay themselves\n10.\nCost effective: cheaper than building, running & maintaining custom servers\nEconomies of scale\nThe Gelato Network is a sustainable, revenue-generating protocol. The network is “transaction hungry” — the more transactions are being automated via the infrastructure services of Executors, the less they need to get paid per transaction, in order to cover their fixed infrastructure costs. \nExecutors will justify the costs of running their infrastructure by the increase in transaction quantity and not the rise of value captured by individuals’ transactions. This makes Gelato more cost effective to use for dApps than running their own centralized keeper system.\nINTRODUCTION - Previous\nWhat is Gelato?\nNext - INTRODUCTION\nArchitecture\nLast modified 1yr ago"
  },
  {
    "title": "What is Gelato? - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/introduction/what-is-gelato",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nWhat is Gelato?\nWeb3's decentralized backend\nGelato is web3’s decentralized backend empowering builders to create augmented smart contracts that are automated, gasless & off-chain aware on all major EVM-compatible blockchains including Ethereum, Polygon, Fantom, Arbitrum, BNB Chain, Optimism and many more. \nGelato currently offers 4 main services:\nWeb3 Functions: Connect your smart contracts to off-chain data & computation by running decentralized cloud functions. \nAutomate: Automate your smart contracts by executing transactions automatically in a reliable, developer-friendly & decentralized manner. \nRelay: Give your users access to reliable, robust and scalable gasless transactions via a simple to use API.\nGasless Wallet: A powerful SDK that enables developers to provide a wordclass UX by combining Gelato Relay + Safe's Smart Contract Wallet to enable Account Abstraction.\nOver 200+ web3 projects rely on Gelato for years to power the execution of millions of transactions across DeFi, NFT and Gaming.\nVision\nGelato is web3's decentralized backend that empowers the world to run on smart contracts.\nOur mission is to solve the issues of lacking reliability, scalability, and centralization around web3 applications that want to augment their smart contracts with off-chain computation capabilities to overcome the limitations that current EVM based blockchains impose on them. Gelato solves these issues by providing decentralized backend services that enables developers to make their smart contracts automated, gasless and off-chain aware.\nMission\nWe measure the success of Gelato by the time we accelerated worldwide adoption of smart contracts and web3 technology. This is why we pledged to help developers to onboard the first billion users to web3 by taking care of all their web3 backend services needs so they can focus on building a stellar UX that rivals those of their web2 counterparts.\nUsers of Gelato\nWe've been working with the world's leading projects in the web3 space, from blockchain protocols to DeFi apps and wallets. \n​MakerDAO: DeFi's oldest lending protocol where the stablecoin DAI is created\n​Safe: The most trusted decentralized custody protocol and collective asset management platform on Ethereum and the EVM\n​Connext: The leading protocol for fast, fully noncustodial transfers and contract calls between EVM-compatible chains\n​Optimism: One of the most widely used Ethereum L2 scaling solutions\n​Olympus: A community-owned, decentralized and censorship-resistant reserve currency\n​PancakeSwap: The #1 AMM on BNB Chain with over $100 million daily trading volume\n​Beefy Finance: A decentralized, multi-chain yield optimizer platform on Polygon, BNB Chain, Fantom, Avalanche, and 10 other blockchain networks\n​Abracadabra: Multichain lending and borrowing protocol which generates the stablecoin MIM\nand many more...\nUseful Links:\n​Whitepaper​\n​Social Media​\n​Contact us​\nNext - INTRODUCTION\nHow it works\nLast modified 1mo ago"
  },
  {
    "title": "eth_sendUserOperation - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/account-abstraction/bundler-api-endpoints/eth_senduseroperation",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\neth_sendUserOperation\neth_estimateUserOperationGas\neth_getUserOperationByHash\neth_getUserOperationReceipt\neth_supportedEntryPoints\neth_maxPriorityFeePerGas\neth_chainId\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\neth_sendUserOperation\nPlease refer to 1Balance & Relay to create a sponsorApiKey.\nThe maxFeePerGas and paymasterAndData fields must be zero to avoid on-chain EntryPoint fee payments. This decreases overhead and leads to gas savings.\nSee Advantages & Highlights.\nPOST\nhttps://api.gelato.digital\n/bundlers/{chainId}/rpc\neth_sendUserOperation\n\nSends a UserOperation to the specified network.\n\nParameters\nPath\nchainId*\nnumber\nTarget network chain identifier.\nQuery\nsponsorApiKey*\nstring\n1Balance API key which covers transaction costs.\nretries\nnumber\nNumber of times to retry failing transactions.\nBody\nExample\nSchema\n{​\n  \"id\": 0,​\n  \"jsonrpc\": \"2.0\",​\n  \"method\": \"eth_sendUserOperation\",​\n  \"params\": [​\n    {​\n      \"sender\": \"string\",​\n      \"nonce\": \"string\",​\n      \"initCode\": \"string\",​\n      \"callData\": \"string\",​\n      \"signature\": \"string\",​\n      \"paymasterAndData\": \"0x\",​\n      \"callGasLimit\": \"string\",​\n      \"verificationGasLimit\": \"string\",​\n      \"preVerificationGas\": \"0x0\",​\n      \"maxFeePerGas\": \"0x0\",​\n      \"maxPriorityFeePerGas\": \"string\"​\n    },​\n    \"0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789\"​\n  ]​\n​}\nResponses\n200: OK\nSuccessful response\n400: Bad Request\nValidation error\nPrevious\nBundler API Endpoints\nNext\neth_estimateUserOperationGas\nLast modified 30d ago"
  },
  {
    "title": "What is Gelato? - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/introduction/what-is-gelato",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nWhat is Gelato?\nWeb3's decentralized backend\nGelato is web3’s decentralized backend empowering builders to create augmented smart contracts that are automated, gasless & off-chain aware on all major EVM-compatible blockchains including Ethereum, Polygon, Fantom, Arbitrum, BNB Chain, Optimism and many more. \nGelato currently offers 4 main services:\nWeb3 Functions: Connect your smart contracts to off-chain data & computation by running decentralized cloud functions. \nAutomate: Automate your smart contracts by executing transactions automatically in a reliable, developer-friendly & decentralized manner. \nRelay: Give your users access to reliable, robust and scalable gasless transactions via a simple to use API.\nGasless Wallet: A powerful SDK that enables developers to provide a wordclass UX by combining Gelato Relay + Safe's Smart Contract Wallet to enable Account Abstraction.\nOver 200+ web3 projects rely on Gelato for years to power the execution of millions of transactions across DeFi, NFT and Gaming.\nVision\nGelato is web3's decentralized backend that empowers the world to run on smart contracts.\nOur mission is to solve the issues of lacking reliability, scalability, and centralization around web3 applications that want to augment their smart contracts with off-chain computation capabilities to overcome the limitations that current EVM based blockchains impose on them. Gelato solves these issues by providing decentralized backend services that enables developers to make their smart contracts automated, gasless and off-chain aware.\nMission\nWe measure the success of Gelato by the time we accelerated worldwide adoption of smart contracts and web3 technology. This is why we pledged to help developers to onboard the first billion users to web3 by taking care of all their web3 backend services needs so they can focus on building a stellar UX that rivals those of their web2 counterparts.\nUsers of Gelato\nWe've been working with the world's leading projects in the web3 space, from blockchain protocols to DeFi apps and wallets. \n​MakerDAO: DeFi's oldest lending protocol where the stablecoin DAI is created\n​Safe: The most trusted decentralized custody protocol and collective asset management platform on Ethereum and the EVM\n​Connext: The leading protocol for fast, fully noncustodial transfers and contract calls between EVM-compatible chains\n​Optimism: One of the most widely used Ethereum L2 scaling solutions\n​Olympus: A community-owned, decentralized and censorship-resistant reserve currency\n​PancakeSwap: The #1 AMM on BNB Chain with over $100 million daily trading volume\n​Beefy Finance: A decentralized, multi-chain yield optimizer platform on Polygon, BNB Chain, Fantom, Avalanche, and 10 other blockchain networks\n​Abracadabra: Multichain lending and borrowing protocol which generates the stablecoin MIM\nand many more...\nUseful Links:\n​Whitepaper​\n​Social Media​\n​Contact us​\nNext - INTRODUCTION\nHow it works\nLast modified 1mo ago"
  },
  {
    "title": "Subscription & Payments - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/subscription-and-payments",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n💰\nSubscription & Payments\nSubscription Plans\nWith our subscription plans, users can choose the level of service that best fits their development and operational needs. Our plans are designed to cater to everything from small-scale projects to large enterprise operations.\nGelato Units (G-units)\nWe're introducing a new way to measure your usage: Gelato Units, or G-Units. G-Units are a straightforward way to calculate how much computing power your tasks use. They replace the old method of counting each task run, allowing you to run more tasks with less resource use. If your tasks are simple and use fewer resources, you can do more of them each month. The less computing power you use, the more tasks you can run—making G-Units a fairer way to measure and pay for what you actually use.\nText\nResource Used\nGelato Units\nSolidity Function\n1 Run\n1 GU\nTypescript Function\n1 RPC Call\n1 CPU Second\n1 GU\n2 GU\nTransaction Simulation\nEach time a solidity or a typescript function returns an executable payload, we verify that the transaction is not reverting\n1 GU\nYou decide when your Function triggers; running it more often will use up more G-Units. For instance, if a task is executed with every new block on the Polygon network, it will use more G-Units than if it’s scheduled to execute just once at month's end.\nYou can keep track of your current subscription and handle all aspects of your plan with ease. To view your current plan, click here. To manage your subscriptions, click here. \nPayments\nIn order for the network to be sustainable & decentralized, Gelato Nodes charge fees for running off-chain computation and executing transactions.\nOur default method is to pay for all your Web3 Function costs across all networks from a single balance using  Gelato 1Balance.  Learn more about it by heading over the linked page:\n1Balance\nIf you exceed these limits your Web3 Function runs will be throttled. If you have any questions or would like to discuss your subscription, please reach out to us here. \nTransaction Charges\nEach transaction that Gelato Nodes execute require a small fee to incentivize Nodes to adhere to the protocol and get your transactions included into your desired blockchain in a fast and secure fashion. \nTo achieve this, Nodes charge a fee as a percentage of total gas cost for the executed transaction. This varies across networks - Nodes charge higher premiums on cheaper networks and vice versa.\nNetwork\nPercentage Premium (%)\nEthereum\n20\nPolygon\n70\nFantom\n50\nAvalanche\n40\nBNB\n30\nOptimism\n50\nArbitrum\n50\nGnosis\n100\nZkSync Era\n50\nPolygon zkEvm\n50\nBase\n50\nLinea\n50\nTable 1 - Fee premiums as a percentage of total gas cost per network. Testnet transactions are subsidized by Gelato.\nThese transaction premiums can be customised for users. Please reach out to us here to discuss your needs.\nTransaction pays for itself\nYou can also choose to have your function pay the fee during executions. It must be remembered that running Web3 Functions has computational costs. Please see here the Free Tier limits, in the case that the Web3 Functions goes above these limits, 1Balance will be also required to pay for the computational costs. \nThis can be done by inheriting AutomateReady.\ncontract CounterWT is AutomateReady {\n    uint256 public count;\n    uint256 public lastExecuted;\n​\n    constructor(address _automate, address _taskCreator)\n        AutomateReady(_automate, _taskCreator)\n    {}\n​\n    receive() external payable {}\n​\n    function increaseCount(uint256 amount) external onlyDedicatedMsgSender {\n        count += amount;\n        lastExecuted = block.timestamp;\n​\n        (uint256 fee, address feeToken) = _getFeeDetails();\n​\n        _transfer(fee, feeToken);\n    }\n}\n​\nIn the increaseCount function, we use _transfer inherited from AutomateReady to pay Gelato.\n_transfer has two parameters, fee and feeToken which has to be queried from the Automate contract by using getFeeDetails()\nTo create a task that pays for itself, head over to the task properties and enable the 'Transaction pays itself\"\n​\nPrevious\nContract Addresses\nNext - Services\nVRF\nLast modified 2d ago"
  },
  {
    "title": "SyncFee Payment Tokens - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/subscriptions-and-payments/syncfee-payment-tokens",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n1⃣\n1Balance & Relay\n2⃣\nSyncFee Payment Tokens\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n2⃣\nSyncFee Payment Tokens\nLearn what payment tokens you can use in your transactions.\nWhen utilizing the callWithSyncFeeERC2771 or callWithSyncFee relay methods, you have the option to pay transaction fees with a token other than the native one. In addition to the native token, support is also extended to the wrapped native token, and on mainnets, the major ERC20 tokens. Please refer to the table below for the full array of supported tokens.\nMainnets\nNetwork\nPayment Tokens\nAll networks\nNATIVE:  0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\nArbitrum\nWETH:    0x82af49447d8a07e3bd95bd0d56f35241523fbab1\nDAI:     0xda10009cbd5d07dd0cecc66161fc93d7c9000da1\nUSDC.e:  0xff970a61a04b1ca14834a43f5de4533ebddb5cc8\nUSDC:    0xaf88d065e77c8cc2239327c5edb3a432268e5831\nUSDT:    0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9\nWBTC:    0x2f2a2543b76a4166549f7aab2e75bef0aefc5b0f\nAvalanche\nWAVAX:   0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7\nDAI.e:   0xd586e7f844cea2f87f50152665bcbc2c279d8d70\nUSDC.e:  0xa7d7079b0fead91f3e65f86e8915cb59c1a4c664\nUSDC:    0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e\nUSDT.e:  0xc7198437980c041c805a1edcba50c1ce5db95118\nUSDT:    0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7\nWBTC.e:  0x50b7545627a5162f82a992c33b87adc75187b218\nWETH.e:  0x49d5c2bdffac6ce2bfdb6640f4f80f226bc10bab\n\n\nBase \nWETH:    0x4200000000000000000000000000000000000006\nUSDbC:   0xd9aaec86b65d86f6a7b5b1b0c42ffa531710b6ca\nBNB\nWBNB:    0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\nBUSD:    0xe9e7cea3dedca5984780bafc599bd69add087d56\nBSC-USD: 0x55d398326f99059ff775485246999027b3197955\nHERO:    0xd40bedb44c081d2935eeba6ef5a3c8a31a1bbe13\nCAKE:    0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82\nBTCB:    0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c\nUSDC:    0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d\nEthereum\nWETH:    0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\nDAI:     0x6b175474e89094c44da98b954eedeac495271d0f\nUSDC:    0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\nUSDT:    0xdac17f958d2ee523a2206206994597c13d831ec7\nWBTC:    0x2260fac5e5542a773aa44fbcfedf7c193bc2c599\nGnosis\nWXDAI:   0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d\nGNO:     0x9C58BAcC331c9aa871AFD802DB6379a98e80CEdb\nUSDC:    0xDDAfbb505ad214D7b80b1f830fcCc89B60fb7A83\nUSDT:    0x4ECaBa5870353805a9F068101A40E0f32ed605C6\nWETH:    0x6A023CCd1ff6F2045C3309768eAd9E68F978f6e1\nLinea \nWETH:    0xe5D7C2a44FfDDf6b295A15c148167daaAf5Cf34f\nOptimism\nWETH:    0x4200000000000000000000000000000000000006\nDAI:     0xda10009cbd5d07dd0cecc66161fc93d7c9000da1\nUSDC:    0x7f5c764cbc14f9669b88837ca1490cca17c31607\nUSDT:    0x94b008aa00579c1307b0ef2c499ad98a8ce58e58\nWBTC:    0x68f180fcce6836688e9084f035309e29bf0a2095\nSNX:     0x8700daec35af8ff88c16bdf0418774cb3d7599b4\nAELIN:   0x61baadcf22d2565b0f471b291c475db5555e0b76\nFRAX:    0x2e3d870790dc77a83dd1d18184acc7439a53f475\nPolygon \nWMATIC:  0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270\nDAI:     0x8f3cf7ad23cd3cadbd9735aff958023239c6a063\nUSDC:    0x2791bca1f2de4661ed88a30c99a7a9449aa84174\nUSDT:    0xc2132d05d31c914a87c6611c10748aeb04b58e8f\nWBTC:    0x1bfd67037b42cf73acf2047067bd4f2c47d9bfd6\nWETH:    0x7ceb23fd6bc0add59e62ac25578270cff1b9f619\nPolygon zkEVM \nWETH:    0x4F9A0e7FD2Bf6067db6994CF12E4495Df938E6e9\nUSDC:    0xA8CE8aee21bC2A48a5EF670afCc9274C7bbbC035\nzkSync Era\nWETH:    0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91\nUSDC:    0x3355df6D4c9C3035724Fd0e3914dE96A5a83aaf4\nZora\nWETH:    0x4200000000000000000000000000000000000006\nShibarium\nWBONE:   0xC76F4c819D820369Fb2d7C1531aB3Bb18e6fE8d8\n​\nTestnets\nNetwork\nPayment Tokens\nAll networks\nNATIVE:  0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\nGelato OP Testnet\nWETH:    0x4200000000000000000000000000000000000006\nAstar zKatana\nWETH:    0x22f92e5a6219bEf9Aa445EBAfBeB498d2EAdBF01\nTangible Unreal\nWETH:    0x22f92e5a6219bEf9Aa445EBAfBeB498d2EAdBF01\nArbitrum Goerli\nWETH:    0xEe01c0CD76354C383B8c7B4e65EA88D00B06f36f\nBase Goelri\nWETH:    0x44D627f900da8AdaC7561bD73aA745F132450798\nGoerli\nWETH:    0x44D627f900da8AdaC7561bD73aA745F132450798\nChiado\nWXDAI:   0x18c8a7ec7897177E4529065a7E7B0878358B3BfF\nLinea Goerli\nWETH:    0x2C1b868d6596a18e32E61B901E4060C872647b6C\nMumbai\nWMATIC:  0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889\nOptimism Goerli\nWETH:    0x4200000000000000000000000000000000000006\nPolygon zkEVM  Goerli\nWETH:    0xeE589e91401066068AF129B0005aC3EF69E3fdB4\nzkSync Era Goerli\nWETH:    0x20b28B1e4665FFf290650586ad76E977EAb90c5D\nPrevious\n1Balance & Relay\nNext\nAPI\nLast modified 10d ago"
  },
  {
    "title": "Identity & KYC - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/gelato-rollup-as-a-service-raas/marketplace/identity-and-kyc",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\nDeploy your L2 Chain\nExecution Frameworks\nData Availability\nReliability & Security\nScaling Solutions Wiki\nMarketplace\nGelato Services\nData Indexers\nBlock Explorers\nOracles\nBridges\nAccount Abstraction\nOn & Off-ramp\nCommunity\nIdentity & KYC\nOthers\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nIdentity & KYC\nAdd an identity layer to your L2 chain to ensure compliance and minimize risk\nFractal ID\n​Fractal ID is the KYC identity provider for web3 that works for everyone, everywhere. It is a decentralized identity system for Web3, offering an integrated identity stack for identity creation and access management.  The platform streamlines identity processes, allowing for the reusability and portability of verified identity information across dApps \nidOS\n​idOS enables a decentralized, chain-agnostic, and self-sovereign identity layer for user data control and ownership on your L2\nidOS  is live with:\nUser Control: Users have full ownership and control over their identity data. They can edit, grant, or revoke access to interact with dApps.\nSecure Data Storage: Node operators store encrypted user data safely.\ndApp Integration: dApps can request read or write access to user data or credentials.\nIdentity Verification: Providers check user data, issue credentials, and may add them to the user's idOS profile.\nPrevious\nCommunity\nNext\nOthers\nLast modified 11d ago"
  },
  {
    "title": "Community - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/gelato-rollup-as-a-service-raas/marketplace/community",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\nDeploy your L2 Chain\nExecution Frameworks\nData Availability\nReliability & Security\nScaling Solutions Wiki\nMarketplace\nGelato Services\nData Indexers\nBlock Explorers\nOracles\nBridges\nAccount Abstraction\nOn & Off-ramp\nCommunity\nIdentity & KYC\nOthers\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nCommunity\nCommunity is a dynamic network of web3 users and partners that engages and grows through reward-based loyalty programs, digital credential interaction, and NFT Marketplace.\nGalxe\n​Galxe is the leading platform for building web3 communities with more than +14m users, It has powered the growth of Optimism, Polygon, Arbitrum, and over 4k partners with reward-based loyalty programs.\nGalxe is live with:\nLoyalty Programs: Helps protocols to build loyalty programs using web3 credentials, Soul Bound Tokens, and to enhance community engagement.\nGalxe Passport: Provides a large on-chain KYC solution with over 455K current holders.\nGuild.xyz\n​Guild.xyz is a modular community toolkit and CRM for managing membership, Sybil protection, and campaigns for your onchain community\nGuild.xyz is live with:\nAccess Management: Infrastructure for creating portable memberships and social structures across both on-chain and off-chain platforms.\nReal-time Interaction: Utilizes a powerful query engine for blockchain interaction, supporting asset tracking and community management.\nRaribleX\nWith RaribleX, deploy your own custom NFT marketplace on your L2.\nRaribleX is live with:\nRevenue Opportunities: Primary sales, custom fees, protected royalties, auctions, delayed/instant reveals, and packs.\nCustomization: Tailored features like UI, rewards programs, and native token support.\n\n\n\nPrevious\nOn & Off-ramp\nNext\nIdentity & KYC\nLast modified 11d ago"
  },
  {
    "title": "Gelato Services - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/gelato-rollup-as-a-service-raas/marketplace/gelato-services",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\nDeploy your L2 Chain\nExecution Frameworks\nData Availability\nReliability & Security\nScaling Solutions Wiki\nMarketplace\nGelato Services\nData Indexers\nBlock Explorers\nOracles\nBridges\nAccount Abstraction\nOn & Off-ramp\nCommunity\nIdentity & KYC\nOthers\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nGelato Services\n​\n​Gelato presents a full range of middleware solutions that enable smart contracts to operate autonomously based on both on-chain and off-chain conditions, gasless transactions to overcome the hurdle of transaction costs, and unbiased randomness.\nFunctions\n​Gelato's Functions are serverless, event-responsive tools designed for automating smart contracts activities triggered by both on-chain and off-chain data and computations.\nRelay\n​Gelato Relay offers streamlined access to gasless transactions that are reliable, robust, and scalable, all accessible through an easy-to-use API.\nVRF\n​Gelato VRF provides a purpose-built solution for generating unbiased randomness in smart contracts, ensuring fairness and trust in blockchain-based applications.\nPrevious\nMarketplace\nNext\nData Indexers\nLast modified 11d ago"
  },
  {
    "title": "On & Off-ramp - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/gelato-rollup-as-a-service-raas/marketplace/on-and-off-ramp",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\nDeploy your L2 Chain\nExecution Frameworks\nData Availability\nReliability & Security\nScaling Solutions Wiki\nMarketplace\nGelato Services\nData Indexers\nBlock Explorers\nOracles\nBridges\nAccount Abstraction\nOn & Off-ramp\nCommunity\nIdentity & KYC\nOthers\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nOn & Off-ramp\nOn & off ramp enable users to convert between fiat currencies and cryptocurrencies.\nMonerium\n​Monerium enables sending and receiving euros between any bank account and Web3 wallets with Monerium's EURe stablecoin, bridging traditional and decentralized finance for your L2\nMonerium is live with:\nEURe Stablecoin: Fully authorized, overcollateralized onchain euro token, easily manageable and exchangeable on major DeFi platform\nEUR Transfers: Monerium's web3 IBAN allows for euro transactions between bank accounts and web3 wallets\nPayment API: Offer services for account management, payment processing, and automated fiat transactions.\nMoonPay\n​MoonPay facilitates the buying and selling of cryptocurrencies and NFTs using traditional payment methods such as cards and bank transfers for your L2.\nMoonPay is live with:\nOff/On ramp: Seamlessly convert traditional money into cryptocurrencies and vice versa with onramp and offramp services.\nSwap: Enable users to swap crypto across different chains while benefiting from low transaction fees.\nCheckout: Provides a seamless buying experience for brands, creators, and marketplaces, enabling users to purchase NFTs and Web3 Digital Goods with credit or debit cards.\n\n\n\nPrevious\nAccount Abstraction\nNext\nCommunity\nLast modified 11d ago"
  },
  {
    "title": "Oracles - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/gelato-rollup-as-a-service-raas/marketplace/oracles",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\nDeploy your L2 Chain\nExecution Frameworks\nData Availability\nReliability & Security\nScaling Solutions Wiki\nMarketplace\nGelato Services\nData Indexers\nBlock Explorers\nOracles\nBridges\nAccount Abstraction\nOn & Off-ramp\nCommunity\nIdentity & KYC\nOthers\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nOracles\nOracles provide external data (like temperature, price feeds, etc.) to smart contracts, bridging the gap between off-chain and on-chain environments.\nRedstone (Natively Integrated)\n​RedStone oracle delivers frequently updated, reliable, and diverse data feeds for your dApp and smart contracts on the L2 Chain.\nRedstone is live with:\n​Price Feeds:  Offering over 1000 feeds for data on crypto, stocks, currencies, commodities, and ETFs.\n​NFT Data Feeds: Providing floor price data for 20 popular NFT collections from OpenSea.\n​Randomness: Using entropy from Drand to generate pseudo-random numbers in smart contracts.\nPyth\n​Pyth provides smart contracts with fast, reliable market data from top-tier sources, ideal for building applications with high-accuracy Oracle feeds for critical systems.\nPyth is live with:\n​Price Feeds: Pyth offers real-time data from real-world markets by delivering verified information from first-party sources on a sub-second timescale and includes 388 distinct price feeds.\n​Benchmarks: Access historical market data directly from any Pyth feed for application in both on- and off-chain environments.\nAPI3\n​API3 provides decentralized and trust-minimized off-chain data through first-party oracles without intermediaries for your L2 Chain.\nAPI3 is live with:\n​dAPIs: First-party aggregated data feeds sourced directly from the data providers.\n​Airnode: The first-party serverless Oracle solution to bring any REST API onchain.\n​QRNG: Quantum Random Number Generator for verifiable quantum RNG onchain.\nDIA\n​DIA is a cross-chain data platform that delivers customizable data feeds from 80+ sources for your L2 Chain.\nDIA is live with:\n​Token Price Feeds: Providing market price feeds for over 3,000 tokens, sourced from multiple high-volume markets.\n​NFT Floor Price Feeds: Delivering multi-source and trade-based accurate pricing for more than 18,000 NFT collections.\n​LST Price Feeds: Offering fair-value based pricing for 10 LST tokens that account for the collateral ratio.\n​On-chain Randomness: Facilitate the building of DeFi and GameFi dApps with DIA's multi-chain randomness, featuring 2,880 updates per day.\n​DIA Oracle Builder: Enables building, deploying, and monitoring of custom oracles, instantly and autonomously\n\n\n\nPrevious\nBlock Explorers\nNext\nBridges\nLast modified 11d ago"
  },
  {
    "title": "Bridges - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/gelato-rollup-as-a-service-raas/marketplace/bridges",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\nDeploy your L2 Chain\nExecution Frameworks\nData Availability\nReliability & Security\nScaling Solutions Wiki\nMarketplace\nGelato Services\nData Indexers\nBlock Explorers\nOracles\nBridges\nAccount Abstraction\nOn & Off-ramp\nCommunity\nIdentity & KYC\nOthers\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nBridges\nBridges allow interoperability in blockchain is the ability for different blockchain systems to communicate and transact with each other seamlessly\nLayerZero (Natively Integrated)\n​Layerzero is Omnichain communication for your L2 that supports direct, trust-minimized communication across multiple blockchain networks.\nDevelopers can easily send arbitrary data, external function calls, and tokens with omnichain messaging while preserving full autonomy and control over their application.\nConnext\n​Connext securely interacts with users, tokens, and other applications on any chain with your L2\nConnext is live with:\n​Modular bridge: Design for tailored, secure cross-chain communication, adapting to various transaction needs while ensuring maximum security through an optimal path and an optimistic verification layer.\n​xERC20: Cross-chain iteration of ERC-20, ensuring seamless transfers across chains without slippage or security compromises. \nHyperlane\n​Hyperlane connects your rollup with any blockchain leveraging the permissionless interoperability layer, right out-of-the-box.\nHyperlane is live with:\nMessaging: Utilize on-chain API to seamlessly send and receive interchain messages across any blockchain network.\nInterchain Accounts: Easily create and manage accounts on remote chains without the requirement for deploying on those specific chains.\nWarp Routes: Bridge any token to any chain without restrictions using Hyperlane, eliminating the need for token whitelisting.\nInterchain Queries: Conveniently query the state of any contract on any chain supported by Hyperlane, and effortlessly bring Oracle services to your blockchain or rollup.\n​\nPrevious\nOracles\nNext\nAccount Abstraction\nLast modified 3d ago"
  },
  {
    "title": "Data Indexers - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/gelato-rollup-as-a-service-raas/marketplace/data-indexers",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\nDeploy your L2 Chain\nExecution Frameworks\nData Availability\nReliability & Security\nScaling Solutions Wiki\nMarketplace\nGelato Services\nData Indexers\nBlock Explorers\nOracles\nBridges\nAccount Abstraction\nOn & Off-ramp\nCommunity\nIdentity & KYC\nOthers\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nData Indexers\nData indexers organize and index blockchain data, enhancing the efficiency of data retrieval and querying for applications and users.\nThe Graph\n​The Graph The Graph is a decentralized protocol for indexing and querying data from blockchains, simplifying access to data that is otherwise difficult to query directly.\nThe Graph is live with:\n​Subgraph: Extracts data from a blockchain, processing it and storing it so that it can be easily queried via GraphQL.\nGoldsky\n​Goldsky is the go-to data indexer for web3 builders, offering high-performance subgraph hosting and real-time data replication pipelines.\nGoldsky is live with:\n​Subgraph: Customized endpoint that allows applications or backends to directly access live, real-time data, eliminating the need for maintenance.\n​Mirror: Goldsky's Mirror feature provides a tool for directly streaming live data into databases or data warehouses, enabling easy and efficient data integration.\n\n\n\nPrevious\nGelato Services\nNext\nBlock Explorers\nLast modified 11d ago"
  },
  {
    "title": "Account Abstraction - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/gelato-rollup-as-a-service-raas/marketplace/account-abstraction",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\nDeploy your L2 Chain\nExecution Frameworks\nData Availability\nReliability & Security\nScaling Solutions Wiki\nMarketplace\nGelato Services\nData Indexers\nBlock Explorers\nOracles\nBridges\nAccount Abstraction\nOn & Off-ramp\nCommunity\nIdentity & KYC\nOthers\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nAccount Abstraction\nAccount abstraction simplifies user experiences by enabling smart contracts to handle transaction rules and account permissions.\nSafe (Natively Integrated)\n​Safe is a customizable non-custodial wallet infrastructure powered by MPC enabling quick user onboarding to Web3 via familiar OAuth logins across web and mobile platforms.\nSafe is live with:\n​Safe{Core} Account Abstraction (AA) SDK: Simplify integrating Safe with third parties and abstract the complexity of setting up a smart contract account.\n​Safe {Core} Protocol: Discover, integrate, and develop using Safe’s robust, battle-tested smart contract account standard and its programmable modules.\nZeroDev\n​Zerodev is an embedded wallet powered by account abstraction (AA) that enables users to interact seamlessly with DApps through AA wallets, offering them significant user experience benefits.\nFacilitate self-custody wallets with Web2 logins, removing seed phrase dependency\nSimplify gas payments by sponsoring or accepting ERC20 tokens like USDC\nEnhance user experience with batched transactions, fewer signing prompts, and offline automation\nEnable wallet recovery for users with lost login credentials\nPrivy\n​Privy offers a unified library for web3 authentication enabling onboarding with options for email, social sign-ins, and embedded wallet creation for your L2\n​Authentication: Integrate familiar web2-style user experience features like email and social media sign-ins, ensuring easy and efficient user authentication.\n​Embedded Wallets: Self-custodial Ethereum wallets that integrate directly into your app, enabling users to effortlessly perform wallet-based actions on your site without the need for an external wallet.\nBiconomy\n​Biconomy offers full Stack Account Abstraction with modular smart accounts, paymasters, and bundlers for your L2.\nBiconomy is live with:\n​Modular smart accounts:  Add UX capability by easily & securely plugging in programmable modules like social logins, batching transactions, and session keys.\n​Paymaster-as-a-Service: Abstract gas complexities with flexible payment options by offering gas payment options in all major stablecoins, WETH & WBTC or get it sponsored.\n​Bundler-as-a-Service: Execute ERC4337 UserOps which is designed to automatically scale up or down as per your dApp traffic with accurate ERC4337 Gas Estimates.\nWeb3Auth\nWeb3Auth is a customizable wallet infrastructure enabling quick user onboarding to Web3 via familiar OAuth logins across web and mobile platforms for your L2s\nWeb3Auth is live with:\nMPC/TSS: Utilize Web3Auth’s MPC architecture for transaction signing with distributed partial keys and TSS for final blockchain signature generation.\nWhitelabeled Wallet UI: Fully customize your wallet's user interface on mobile and web to match your brand.\nFiat-to-Crypto API: Partner with leading providers for competitive rates and high global conversions.\nIdentity Verification: Implement ‘Sign-in With Ethereum’ and CAIP proposals for server-side user verification.\nAccount Abstraction: Leverage Account Abstraction and MPC for a simplified, gas-less, and innovative Web3 user experience.\n\nBYO Auth/Identity Provider: Integrate your preferred login providers, including Firebase, Auth0, and Cognito.\nPrevious\nBridges\nNext\nOn & Off-ramp\nLast modified 11d ago"
  },
  {
    "title": "Block Explorers - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/gelato-rollup-as-a-service-raas/marketplace/block-explorers",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\nDeploy your L2 Chain\nExecution Frameworks\nData Availability\nReliability & Security\nScaling Solutions Wiki\nMarketplace\nGelato Services\nData Indexers\nBlock Explorers\nOracles\nBridges\nAccount Abstraction\nOn & Off-ramp\nCommunity\nIdentity & KYC\nOthers\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nBlock Explorers\nBlockscout\n​Blockscout is a comprehensive, easy-to-use block explorer for viewing, confirming, and inspecting transactions on your L2\nBlockscout is live with:\nDeep Search: Integrated search capabilities provide detailed information on transactions, tags, and more.\nContract Interaction: Engage with contracts directly through the Blockscout UI.\nContract Verification: Multiple tools are available for swift and reliable contract verification\nAPI Requests: Standardized and customizable endpoints ensure seamless API interactions.\nCustom Views: The user interface can be tailored with features like tags, watchlists, and more.\nOnDora\n​OnDora leverages a multi-ecosystem blockchain search engine for your L2.\nDora Search Engine offers a seamless integration with Gelato L2 chains, allowing users to efficiently extract, visualize, and review network metrics from the genesis block. It features a user-friendly UI, ensuring a smooth user experience and enables tracking of Transfers, Swaps, and Mints within a multi-chain environment\nEtherscan\n​Etherscan is the leading block explorer and search, API & analytics platform for your L2 chain\nTransaction Tracking: View and search for Ethereum transactions, blocks, and addresses.\nSmart Contract Analysis: Analyze and verify smart contracts.\nGas Tracker: Monitor Ethereum gas prices.\nToken Explorer: Explore ERC-20 tokens and their activities.\nBlockchain Analytics: Access detailed data and analytics on Ethereum network activities.\nDeveloper APIs: Provide APIs for developers to interact with Ethereum blockchain data.\n\n\n\nPrevious\nData Indexers\nNext\nOracles\nLast modified 11d ago"
  },
  {
    "title": "Custom logic triggers - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/guides/custom-logic-triggers",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nTutorials\nWhat tasks can be automated?\nDefining function inputs\nCustom logic triggers\nSmart Contract Resolvers\nWeb3 Functions\nDedicated msg.sender\nSingle Execution Task\nMulti contract execution\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nCustom logic triggers\nWhat is a resolver and when do you need it?\nA resolver is a smart contract in which developers can embed their logic of \"when\" an execution should occur and what data should executors use for the execution. Gelato will query these resolvers periodically to check if it is time to execute. \nYou need a resolver if\nYou want to define the conditions of \"when\" Gelato should execute your task.\nYou want to have different arguments for the function you are automating on each execution.\nYou do not need a resolver if\nYou simply want to repeatedly call a smart contract function with the same or without arguments (e.g. every 1 hour). \nIf you just want Gelato to try to execute a particular function in case it does NOT revert\nWe give developers the freedom to choose what kind of resolver they want to use. \n​\nSmart contract resolver\nA smart contract resolver is deployed on the corresponding network. (e.g. Ethereum Mainnet, Fantom) If you feel more comfortable writing in solidity, or have a simple condition that only uses on-chain data, you could go with this option.\n(BETA) Web3 Functions\nWeb3 Functions enables you to define conditions and generate payload for execution based on off-chain data. (e.g. API calls & subgraph queries).\nPrevious\nDefining function inputs\nNext\nSmart Contract Resolvers\nLast modified 2mo ago"
  },
  {
    "title": "Contract Addresses - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/contract-addresses",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nContract Addresses\nGelato Automate addresses for each supported network.\nDeprecation Notice: Gelato Functions is set to replace Automate, providing enhanced automation capabilities, access to off-chain data, unified payments across networks, and a performance boost. Migrate your tasks to Gelato Functions before Legacy Automate's end of life on June 30th, 2024 for uninterrupted service.\nGelato Network is the entry point for Gelato Executors to execute transactions. The contract does several security checks and then calls the exec() function on the Automate(formerly Ops) contract. \nThe Automate smart contract then either calls your target smart contract directly or, if you use the dedicated msg.sender module, it will route the call via your dedicated msg.sender contract. \nNote: If you have an access restriction for your smart contract function and want to whitelist Gelato as a msg.sender,we automatically deploy your own dedicated msg.sender - the address to whitelist will be shown in the UI and can also be retrieved via the Automate SDK.\nMainnet\nContract\nAddress\nGelato Network\n0x3CACa7b48D0573D793d3b0279b5F0029180E83b6\nAutomate\n0xB3f5503f93d5Ef84b06993a1975B9D21B962892F\nTaskTreasury\n0x2807B4aE232b624023f87d0e237A3B1bf200Fd99\nPolygon / Matic\nContract\nAddress\nGelato Network\n0x7598e84B2E114AB62CAB288CE5f7d5f6bad35BbA\nAutomate\n0x527a819db1eb0e34426297b03bae11F2f8B3A19E\nTaskTreasury\n0x32DC6700AC87f6300277a63b0A4fDf132A8392bd\nFantom\nContract\nAddress\nGelato Network\n0xebA27A2301975FF5BF7864b99F55A4f7A457ED10\nAutomate\n0x6EDe1597c05A0ca77031cBA43Ab887ccf24cd7e8\nTaskTreasury\n0x0af13072280E10907911ce5d046c2DfA1B604d23\nArbitrum\nContract\nAddress\nGelato Network\n0x4775aF8FEf4809fE10bf05867d2b038a4b5B2146\nAutomate\n0xB3f5503f93d5Ef84b06993a1975B9D21B962892F\nTaskTreasury\n0xB2f34fd4C16e656163dADFeEaE4Ae0c1F13b140A\nAvalanche\nContract\nAddress\nGelato Network\n0x7C5c4Af1618220C090A6863175de47afb20fa9Df\nAutomate\n0x8aB6aDbC1fec4F18617C9B889F5cE7F28401B8dB\nTaskTreasury\n0xe167199A490b04042414aFD71830bBF165f44C09\nBNB Chain\nContract\nAddress\nGelato Network\n0x7C5c4Af1618220C090A6863175de47afb20fa9Df\nAutomate\n0x527a819db1eb0e34426297b03bae11F2f8B3A19E\nTaskTreasury\n0xbECe6A2101eC94E817c072622671B399A3508Ac1\n​\nGnosis\nContract\nAddress\nGelato Network\n0x29b6603D17B9D8f021EcB8845B6FD06E1Adf89DE\nAutomate\n0x8aB6aDbC1fec4F18617C9B889F5cE7F28401B8dB\nTaskTreasury\n0x04462c8ad55a3d970fd9b4944A2f4C7c15700883\nOptimism\nContract\nAddress\nGelato Network\n0x01051113D81D7d6DA508462F2ad6d7fD96cF42Ef\nAutomate\n0x340759c8346A1E6Ed92035FB8B6ec57cE1D82c2c\nTaskTreasury\n0xB3f5503f93d5Ef84b06993a1975B9D21B962892F\n​\nStaging\nGoerli\nContract\nAddress\nGelato Network\n0x683913B3A32ada4F8100458A3E1675425BdAa7DF\nAutomate\n0xc1C6805B857Bef1f412519C4A842522431aFed39\nTaskTreasury\n0xF381dfd7a139caaB83c26140e5595C0b85DDadCd\nArbitrum Goerli\nContract\nAddress\nGelato Network\n0xF82D64357D9120a760e1E4C75f646C0618eFc2F3\nAutomate\n0xa5f9b728ecEB9A1F6FCC89dcc2eFd810bA4Dec41\nTaskTreasury\n0x8aB6aDbC1fec4F18617C9B889F5cE7F28401B8dB\nOptimism Goerli\nContract\nAddress\nGelato Network\n0xF82D64357D9120a760e1E4C75f646C0618eFc2F3\nAutomate\n0x255F82563b5973264e89526345EcEa766DB3baB2\nTaskTreasury\n0x644CB00854EDC55FE8CCC9c1967BABb22F08Ad2f\nBase Goerli\nContract\nAddress\nGelato Network\n0xbe77Cd403Be3F2C7EEBC3427360D3f9e5d528F43\nAutomate\n0x2501648Bf32e6ea8804d4603e3794f651CCEceC0\nTaskTreasury\n0x8b8997c0d5cb5d117C636FebF35979AF6C3B46E5\nPolygon Mumbai\nContract\nAddress\nGelato Network\n0x25aD59adbe00C2d80c86d01e2E05e1294DA84823\nAutomate\n0xB3f5503f93d5Ef84b06993a1975B9D21B962892F\nTaskTreasury\n0x527a819db1eb0e34426297b03bae11F2f8B3A19E\nPrevious\nCode Repositories\nNext\nLegacy Automate Migration Guide\nLast modified 2mo ago\nON THIS PAGE\nMainnet\nPolygon / Matic\nFantom\nArbitrum\nAvalanche\nBNB Chain\nGnosis\nOptimism\nStaging\nGoerli\nArbitrum Goerli\nOptimism Goerli\nBase Goerli\nPolygon Mumbai"
  },
  {
    "title": "What tasks can be automated? - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/guides/what-tasks-can-be-automated",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nTutorials\nWhat tasks can be automated?\nDefining function inputs\nCustom logic triggers\nDedicated msg.sender\nSingle Execution Task\nMulti contract execution\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nWhat tasks can be automated?\nFunctions that can be automated should follow these properties:\nThey need to be functions that are usually called by the development team or external keepers, not \"user facing\" functions called by users directly\nThey need to be either public or external\nThey do not have access restrictions like an onlyOwner modifier, unless the Automate contract is a whitelisted address\nThey do not require msg.sender to be tx.origin\nPrevious\nTutorials\nNext\nDefining function inputs\nLast modified 1mo ago"
  },
  {
    "title": "Legacy Automate Migration Guide - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/legacy-automate-migration-guide",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nLegacy Automate Migration Guide\nDeprecation Notice: Gelato Functions is set to replace Automate, providing enhanced automation capabilities, access to off-chain data, unified payments across networks, and a performance boost. Migrate your tasks to Gelato Functions before Legacy Automate's end of life on June 30th, 2024 for uninterrupted service.\nGelato Functions replacing Automate\nWith the launch of Gelato Functions we are deprecating our Automate service.\nThe key benefits of Gelato Functions include:\n\n\nAccess off-chain data & computation via Typescript Functions\nUnified payments across all networks via 1Balance\nListen to on-chain Events to trigger your Functions\nSupport for many more networks\nMuch higher performance and lower latencies\nEnhanced UX, DevX and analytics\nTo get these benefits users need to migrate their tasks from Automate (now Legacy Automate) to Gelato Functions.\nWhen should I migrate?\nLegacy Automate will be deprecated 30th June 2024 so users should plan to migrate to Functions before this date.\nLegacy Automate: Key Changes\nFrom 1st December 2023, some Legacy Automate tasks will be expired and won’t be checked anymore. Check conditions for expired tasks. \nFrom 1st January 2024, Automate Legacy transactions will cost 50% higher than on new Gelato Functions. Check details on cost changes. \nCost changes\nGelato Functions unifies your transaction costs across all networks using our 1Balance system. For each execution of your target contract you will be billed the USDC equivalent of your gas costs plus a fee - the fee varies depending on the network and your subscription plan.\nFees will be applied to all Automate Legacy transactions from 1st January 2024. These fees will be 50% higher than those on Gelato Functions.\n\n\nTask Expiries\nAs part of the migration we are going to introduce task expiries from 1st December 2023 - any Legacy Automate tasks that meet the following conditions will be automatically cancelled.\n\n\nTestnets\n\n\nTasks expire after 30 days without any execution\n\n\nMainnets\n\n\nTasks expire after 120 days without any execution\n\n\nIf you have any concerns about these limits please do not hesitate to reach out to us.\n\n\nNaming Updates\nWe have updated what some things are called in Functions, but they are directly equivalent. The most notable one is that Resolvers are now called Solidity Functions - the smart contract code that determines if your target contract can be executed and with what payload.\nThe flow for creating a new task has been changed to follow more of an “if this then that” pattern and allows you to also use Typescript functions that tap into off-chain APIs to also determine when target contracts should be executed and with what payloads.\n\n\nHow do I migrate a task from Legacy Automate to Functions?\nThe exact steps you need to go through will depend on the precise characteristics of your existing tasks. Here is some general guidance - if you have any questions or require further support please contact us for assistance.\n1. Smart contract changes (optional)\nIf you are inheriting AutomateReady or OpsReady in your target contracts, upgrade them to use the new version of AutomateReady​\nIf you are whitelisting Gelato as an restricted msg.sender, update your whitelisting to use your new dedicated msg.sender:\nCheck your dedicated msg.sender address on each network here: https://app.gelato.network/settings​\n🔐\nSecurity Considerations\n2. Create your new tasks on app.gelato.network\nConnect to app.gelato.network to create your new tasks\nIf you were using “Resolver”, they are now called “Solidity functions”\nif you were using \"Predefined Inputs\", they are now called \"Automated Transactions\"\n3. Deposit into 1Balance\nDeposit $USDC into your 1Balance to pay for your transactions across all networks \nSet up low balance e-mail alert\n1Balance Alerts\nGelato Network\nYour tasks are now up and running on the new Gelato Functions \n✅\n​\n4. Cancel old tasks & withdraw remaining balance\nConnect to Automate Legacy app and check the modal listing all your current active tasks\nManually \"Pause\" all your old tasks\nWithdraw your assets on each network where you still hold any balance on Gelato TaskTreasury\nAdvanced user migration\nCreating tasks via Smart Contract\nUpgrade your Smart Contracts to use the latest version AutomateTaskCreator​\nIf you were relying on Time Module, it has been replaced by Trigger Module, which allows similar configurations\nfunction _timeTriggerModuleArg(uint128 _start, uint128 _interval)\nNote that it’s now required to use the Proxy Module on all your task creations, to enforce stricter security\nCreating tasks via SDK\nMake sure to upgrade to use the latest version of the automate-sdk:\nyarn add @gelatonetwork/automate-sdk\nYou can create task using the same createTask method\nif you were using startTime & interval, these options are now available inside the trigger configuration:\ntrigger: {\n  type: TriggerType.TIME; // time interval trigger\n  interval: number; // task interval in ms\n  start: number; // task start timestamp, task will start immediately if undefined or 0\n}\nPrevious\nContract Addresses\nNext - Integrations\nSafe\nLast modified 1mo ago\nON THIS PAGE\nGelato Functions replacing Automate\nWhen should I migrate?\nLegacy Automate: Key Changes\nCost changes\nTask Expiries\nNaming Updates\nHow do I migrate a task from Legacy Automate to Functions?\nAdvanced user migration"
  },
  {
    "title": "Code Repositories - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/code-repositories",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nCode Repositories\nDeprecation Notice: Gelato Functions is set to replace Automate, providing enhanced automation capabilities, access to off-chain data, unified payments across networks, and a performance boost. Migrate your tasks to Gelato Functions before Legacy Automate's end of life on June 30th, 2024 for uninterrupted service.\nAutomate Smart Contracts:\nGitHub - gelatodigital/automate: Automate arbitrary smart contracts with Gelato Automate\nGitHub\nAutomate SDK:\nGitHub - gelatodigital/automate-sdk: Gelato Automate SDK\nGitHub\nPrevious\nPetting Aavegotchis\nNext\nContract Addresses\nLast modified 2mo ago\nON THIS PAGE\nAutomate Smart Contracts:\nAutomate SDK:"
  },
  {
    "title": "Monitoring Automate Tasks - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/monitoring-automate-tasks",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nMonitoring Automate Tasks\nLearn how to monitor your Web3 Function Task\nDeprecation Notice: Gelato Functions is set to replace Automate, providing enhanced automation capabilities, access to off-chain data, unified payments across networks, and a performance boost. Migrate your tasks to Gelato Functions before Legacy Automate's end of life on June 30th, 2024 for uninterrupted service.\nBesides the task logs available in the UI, Gelato Web3 Functions offer a more detailed and granular monitoring system providing status and logs APIs.\nTask Status URL\nProvided the ChainId and taskId,  this API will return the current Task status\nhttps://api.gelato.digital/tasks/automate/networks/{chainId}/tasks/{taskId}/status\nFor example, if your chainId, taskId are:\nchainId: 137\ntaskId: 0x1d029e6ac412e7b4544bb07a8f12ffc33c668d5ddfa3d479def13d548cd72c4b\nThen the URL to go to is:\nhttps://api.gelato.digital/tasks/automate/networks/137/tasks/0x1d029e6ac412e7b4544bb07a8f12ffc33c668d5ddfa3d479def13d548cd72c4b/status\nFor this taskId, here is the returned task information:\n{\n    \"task {     \n        \"chainId\":137,\n        \"taskId\":\n        \"0x1d029e6ac412e7b4544bb07a8f12ffc33c668d5ddfa3d479def13d548cd72c4b\",\n        \"taskState\":\"CheckPending\",\n        \"creationDate\":\"2022-10-27T09:22:01.434Z\",\n        \"lastCheckDate\":\"2023-06-15T06:03:05.501Z\",\n        \"lastCheckMessage\":\"!canExec\"\n        }\n}\nThe first thing to look at is the taskState key:\nTask states:\nFor the taskState key, these are the possible values:\nCheckPending: the task is pending simulation.\nExecPending: the task is executable and is awaiting inclusion into the blockchain.\nWaitingForConfirmation: the task was included into the blockchain but is still awaiting the required amount of blocks confirmations.\nExecSuccess: the task has been successfully executed.\nCancelled: the task has been canceled by the owner\nExecReverted: the task transaction has been reverted.\nTask  Logs URL\nProvided the ChainId and taskId,  this API will return the logs in the last 24 hours, the query param limit is optional\nhttps://api.gelato.digital/tasks/automate/networks/{chainId}/tasks/{taskId}/logs?limit=NrLogs\nFor example, if your chainId, taskId and NrLogs are:\nchainId: 137\ntaskId: 0x1d029e6ac412e7b4544bb07a8f12ffc33c668d5ddfa3d479def13d548cd72c4b\nNrLogs:2\nThen the URL to go to is:\nhttps://api.gelato.digital/tasks/automate/networks/137/tasks/0x1d029e6ac412e7b4544bb07a8f12ffc33c668d5ddfa3d479def13d548cd72c4b/logs?limit=2\nFor this taskId, here is the returned task information:\n{\n    \"logs\":[\n           {\n            \"date\":\"2023-06-15T06:05:38.975Z\",\n            \"state\":\"CheckPending\",\n            \"type\":\"ResolverCheck\",\n            \"message\":\"!canExec\"\n           },\n           {\n            \"date\":\"2023-06-15T06:05:24.349Z\",\n            \"state\":\"CheckPending\",\n            \"type\":\"ResolverCheck\",\n            \"message\":\"!canExec\"\n           }\n        ]\n}\nPrevious\nMulti contract execution\nNext\nTemplate real-world examples\nLast modified 2mo ago\nON THIS PAGE\nTask Status URL\nTask Logs URL"
  },
  {
    "title": "Tutorials - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/guides/tutorials",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nTutorials\nWhat tasks can be automated?\nDefining function inputs\nCustom logic triggers\nDedicated msg.sender\nSingle Execution Task\nMulti contract execution\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nTutorials\nBasic Example\nFor this basic example we'll be executing a task to a regular schedule.\nInteractive Example\nStep-by-step Example\nIf you prefer a more interactive experience, please follow the Tutorial on the official Gelato Automate website. In this tutorial, you will get to mint a Gelato ice cream NFT which you can \"lick\", but only every 5 minutes, otherwise you get \"brainfreeze\". We recommend you do the Tutorial on Polygon or Goerli. \nTo accomplish this, you can create a task to automate this licking using Gelato in order to not having to do it manually yourself. \n\n\nLook out for this graphic to get started:\n\n\n​\nIn-depth Tutorials\nMany use cases involve writing a resolver to enable Gelato to constantly evaluate whether the conditions for your task to be executed have been met. \nIn this excellent tutorial, you learn a real-world use case - automating a NFT rental marketplace - using Gelato Automate and Truffle:\nWeb3 Unleashed: How to Automate Your Smart Contracts - Truffle Suite\nPrevious\nGuides\nNext\nWhat tasks can be automated?\nLast modified 1mo ago\nON THIS PAGE\nBasic Example\nIn-depth Tutorials"
  },
  {
    "title": "Template real-world examples - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/template-real-world-examples",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nYield vault harvesting\nRewards Payout\nPetting Aavegotchis\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nTemplate real-world examples\nDeprecation Notice: Gelato Functions is set to replace Automate, providing enhanced automation capabilities, access to off-chain data, unified payments across networks, and a performance boost. Migrate your tasks to Gelato Functions before Legacy Automate's end of life on June 30th, 2024 for uninterrupted service.\nIn this section we provide some useful real-world examples that you can use to help you get started. Please click through below.\nPrevious\nMonitoring Automate Tasks\nNext\nYield vault harvesting\nLast modified 2mo ago"
  },
  {
    "title": "Methods for submitting your task - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/methods-for-submitting-your-task",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGelato Automate UI\nGelato Automate SDK\nSmart Contract\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nMethods for submitting your task\nDeprecation Notice: Gelato Functions is set to replace Automate, providing enhanced automation capabilities, access to off-chain data, unified payments across networks, and a performance boost. Migrate your tasks to Gelato Functions before Legacy Automate's end of life on June 30th, 2024 for uninterrupted service.\nYou can submit your tasks via any of the following routes:\n1.\n​Gelato Automate UI​\n2.\n​Gelato Automate SDK​\n3.\n​Smart Contract​\nPrevious\nExecution & Balance Alerts\nNext\nGelato Automate UI\nLast modified 2mo ago"
  },
  {
    "title": "Guides - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/guides",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nTutorials\nWhat tasks can be automated?\nDefining function inputs\nCustom logic triggers\nDedicated msg.sender\nSingle Execution Task\nMulti contract execution\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nGuides\nDeprecation Notice: Gelato Functions is set to replace Automate, providing enhanced automation capabilities, access to off-chain data, unified payments across networks, and a performance boost. Migrate your tasks to Gelato Functions before Legacy Automate's end of life on June 30th, 2024 for uninterrupted service.\nPrevious\nSmart Contract\nNext\nTutorials\nLast modified 2mo ago"
  },
  {
    "title": "Execution & Balance Alerts - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/execution-and-balance-alerts",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nExecution & Balance Alerts\nDeprecation Notice: Gelato Functions is set to replace Automate, providing enhanced automation capabilities, access to off-chain data, unified payments across networks, and a performance boost. Migrate your tasks to Gelato Functions before Legacy Automate's end of life on June 30th, 2024 for uninterrupted service.\nAutomate provides an alerting service to enable you to get notified about your task executions, problems or when your balance is getting low. Alerting currently supports notifications in Telegram and Discord, with other channels on the way.\nTypes of notifications\nType\nDescription\nBalance\nIf your task uses Gelato Balance you need to ensure that you always have enough funds deposited, otherwise your executions will stop executing until you top-up. \n\nSet a balance alert to be notified when your funds are running low - you can use our default levels or set your own threshold.\nExecution Success\nGet notified every time your task executes a transaction successfully\nExecution Revert\nAlerts you if your task executes a transaction but it reverts\nSimulation Fail\nAlerts you when Automate has identified that your task should be executed but it is failing in simulation and would revert on-chain. These alerts are most suitable for scheduled or resolver tasks. \nSetting up Telegram Notifications\nYou can visit your notifications area to follow the steps listed below.\n1.\nAdd GelatoWatcherBot to your Telegram - if you have Telegram installed you can just click on the link to do this.  \n2.\nEnter the command /start\n3.\nThe bot will show you the main alerts that you can request by entering the command.\nTelegram bot will introduce to the main commands it supports\nWhen you enter each command the bot will step you through the inputs required to finish setting up the alert. \nYou can view the full list of commands at any time by entering /help\nTelegram Bot Commands\nCommand\nUsage\n/balance\nAlerts when your Gelato Balance drops below the minimum balance threshold. The default thresholds are listed here. \n​\nThe bot will prompt you for the wallet address that you use to create and manage your tasks. \n​\nTo provide multiple addresses enter each one as a new message to the bot.\n​\nIf you use the same wallet address across multiple networks, you will be alerted when any of these drop below the default thresholds.\n\nIf you would like to set your own threshold use the /balance_threshold command.\n/balance_threshold\nAlerts you when your Gelato Balance drops below the threshold you set on a specific network.\n\nAfter entering the /balance_threshold command the bot will prompt you to specify the chain IDs and your threshold level. Chain IDs are listed here. \n\n\nFor example to be alerted when your Gelato Balance drops below 0.15 ETH on mainnet you would enter 1,0.15\n/list_threshold\nList all custom and default balance thresholds of each network\n/stop_balance\nSwitch off all low balance alerts\n/simulation_fail\nNotifies you when your task is due to be executed but when Gelato simulates the transaction it determines that it will revert when executed on-chain. You will probably need to debug an issue with your target contract.\n\nThe bot will ask you to send the task id for your task in a new message. \n/stop_simulation_fail\nSwitch off all simulation failure notifications\n/exec_success\nNotifies each times your task executes a transaction. \n/stop_exec_success\nSwitch of all execution success notifications\n/exec_revert\nAlerts you to any on-chain reverts when Gelato has executed a transaction for your task.\n/stop_exec_revert\nSwitch of all revert notifications\nDiscord DM Notifications\nIn this mode you receive your alerts as DM's to your Discord handle. To activate:\n1.\nJoin our Gelato Discord server​\n2.\nChoose from the list of commands below\nIf you would prefer to receive alerts in a specific channel please see how to get Discord notifications in your server.\nCommand\nUsage\n/balance-dmaddress\nAlerts when your Gelato Balance drops below the default threshold for the specified wallet address. The default thresholds are listed below. \n​\nTo provide multiple addresses enter a new command to the bot for each address.\n​\nIf you use the same wallet address across multiple networks, you will be alerted when any of these drop below the default thresholds.\n\nTo set your own threshold use the /balance-threshold-dm command.\n/balance-threshold-dm chain_id threshold\nAlerts you when your Gelato Balance drops below the threshold you set on a specific network.\n\nUse the /balance-dm command to set the address(es) that you would like to monitor. \n\nChain IDs are listed here. \n\n\nFor example to be alerted when your Gelato Balance drops below 0.15 ETH on mainnet you would enter 1 0.15\n/list-threshold-dm\nList all custom and default balance thresholds of each network\n/stop-balance-dm\nSwitch off all low balance alerts\n/simulation-fail-dmtask_id\nNotifies you when your task with the specified task_id is due to be executed but when Gelato simulates the transaction it determines that it will revert when executed on-chain. You will probably need to debug an issue with your target contract.\n/stop-simulation-fail-dm\nSwitch off all simulation failure notifications\n/exec-success-dm task_id\nNotifies each times your task executes a transaction. \n/stop-exec-success-dm\nSwitch of all execution success notifications\n/exec-revert-dm task_id\nAlerts you to any on-chain reverts when Gelato has executed a transaction for your task.\n/stop-exec-revert-dm\nSwitch of all revert notifications\nDiscord notifications in your own server\n1.\nAdd our Gelato Bot to your server using this invite link (you need to be admin of the server)\n2.\nIf you want to receive notifications in a private channel, make sure to add Gelato Bot as a member in the channel where you want to receive the notification.\n3.\nEnter the following commands in the channel you want to receive alerts.\nCommand\nUsage\n/balance-channeladdress\nAlerts when your Gelato Balance drops below the default threshold for the specified wallet address. The default thresholds are listed below. \n​\nTo provide multiple addresses enter a new command to the bot for each address.\n​\nIf you use the same wallet address across multiple networks, you will be alerted when any of these drop below the default thresholds.\n\nTo set your own threshold use the /balance-threshold-dm command.\n/balance-threshold-channel chain_id threshold\nAlerts you when your Gelato Balance drops below the threshold you set on a specific network.\n\nUse the /balance-dm command to set the address(es) that you would like to monitor. \n\nChain IDs are listed here. \n\n\nFor example to be alerted when your Gelato Balance drops below 0.15 ETH on mainnet you would enter 1 0.15\n/list-threshold-channel\nList all custom and default balance thresholds of each network\n/stop-balance-channel\nSwitch off all low balance alerts\n/simulation-fail-channeltask_id\nNotifies you when your task with the specified task_id is due to be executed but when Gelato simulates the transaction it determines that it will revert when executed on-chain. You will probably need to debug an issue with your target contract.\n/stop-simulation-fail-channel\nSwitch off all simulation failure notifications\n/exec-success-channel task_id\nNotifies each times your task executes a transaction. \n/stop-exec-success-channel\nSwitch of all execution success notifications\n/exec-revert-channel task_id\nAlerts you to any on-chain reverts when Gelato has executed a transaction for your task.\n/stop-exec-revert-channel\nSwitch of all revert notifications\nDefault Thresholds\nUnless overridden these are the default levels that are used for each network.\nNetwork\nChain ID\nDefault Threshold\nEthereum\n1\n0.05 ETH\nPolygon\n137\n20 MATIC\nFantom\n250\n20 FTM\nArbitrum\n42161\n0.05 ETH\nAvalanche\n43114\n0.5 AVAX\nBNB Chain\n56\n0.05 BNB\nGnosis Chain\n100\n5 XDAI\nOptimism\n10\n0.05 ETH\nIf you need more notifications or new communication channels, your feedback and suggestions are always welcome. \nPrevious\nPaying for your transactions\nNext\nMethods for submitting your task\nLast modified 2mo ago\nON THIS PAGE\nTypes of notifications\nSetting up Telegram Notifications\nTelegram Bot Commands\nDiscord DM Notifications\nDiscord notifications in your own server\nDefault Thresholds"
  },
  {
    "title": "Paying for your transactions - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/paying-for-your-transactions",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nPaying for your transactions\nDeprecation Notice: Gelato Functions is set to replace Automate, providing enhanced automation capabilities, access to off-chain data, unified payments across networks, and a performance boost. Migrate your tasks to Gelato Functions before Legacy Automate's end of life on June 30th, 2024 for uninterrupted service.\nWhen Gelato executes your transaction it needs to pay the transaction fees. The fees can be paid in one of two ways:\n1.\nFrom Gelato Balance\n2.\nTransaction pays for itself\nGelato currently accepts payment in the native network token or its wrapped version for each network that Automate supports. For example, on Ethereum you can pay either in ETH or WETH and on Polygon either in MATiC or WMATIC - and so on for all the other networks we support. \nGelato Balance\nThis is the easiest option. You simply deposit some tokens into Gelato for each of the network(s) on which you want to execute transactions. Each time an execution occurs, Gelato will deduct the costs from your Gelato Balance to cover the gas costs. In the future we will introduce a small Gelato fee.  \nIf your Gelato Balance is too low to cover the costs of your transaction it will not execute until you top-up your balance. We provide a notification service for you to receive alerts when your balance is running low.\nDeposit funds via UI\nYou can deposit funds into your Gelato Balance on the fund's page.\nDeposit funds via smart contract\nIf your smart contract will be the one creating tasks, it would need its own Gelato balance to pay for the task executions. \nIf you would like to have your smart contract deposit funds at any point of time into it's Gelato balance, inherit AutomateTaskCreator like so. Learn more about \nAutomateTaskCreator functions\n \ncontract Counter is AutomateTaskCreator {\n    \n    constructor(address _automate, address _fundsOwner) AutomateTaskCreator(_automate, _fundsOwner) {}\n​\n    function depositForCounter() external payable {\n        _depositFunds(msg.value, ETH);\n    }\n}\n​\nAutomateTaskCreator exposes withdrawFunds function to allow fundsOwner to withdraw from the contract's Gelato balance.\nTransaction pays for itself\nYou can also choose not to pre-deposit funds into your Gelato balance and have your function pay the fee during executions.\nThis can be done by inheriting AutomateReady.\ncontract CounterWT is AutomateReady {\n    uint256 public count;\n    uint256 public lastExecuted;\n​\n    constructor(address _automate, address _taskCreator)\n        AutomateReady(_automate, _taskCreator)\n    {}\n​\n    receive() external payable {}\n​\n    function increaseCount(uint256 amount) external onlyDedicatedMsgSender {\n        count += amount;\n        lastExecuted = block.timestamp;\n​\n        (uint256 fee, address feeToken) = _getFeeDetails();\n​\n        _transfer(fee, feeToken);\n    }\n}\n​\nIn the increaseCount function, we use _transfer inherited from AutomateReady to pay Gelato.\n_transfer has two parameters, fee and feeToken which has to be queried from the Automate contract by using getFeeDetails()\nPrevious\nSupported Networks\nNext\nExecution & Balance Alerts\nLast modified 1mo ago\nON THIS PAGE\nGelato Balance\nTransaction pays for itself"
  },
  {
    "title": "Quick Start - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/vrf/quick-start",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\n📙\nUnderstanding VRF\n❔\nHow does Gelato VRF Work?\n🔓\nSecurity Considerations\n📄\nTemplate\n🚀\nQuick Start\n🚢\nDeploying your VRF Instance\n💡\nMigrating from Chainlink VRF\n💰\nPricing & Rate Limits\n✅\nSupported Networks\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🚀\nQuick Start\nIn order to get your VRF up and running you will need to first make your contract VRF Compatible.\nStep 1: Set Up Your Development Environment\nEnsure you have either Foundry or Hardhat set up in your development environment.\nStep 2: Install the Gelato VRF Contracts\nDepending on your environment, use the following commands to import the Gelato VRF contracts:\nFor Hardhat users:  \nClone the repo here​\nInstall dependencies yarn install\nFill in .env with variables in .env.example\nFor Foundry users: forge install gelatodigital/vrf-contracts --no-commit\nStep 3: Inherit GelatoVRFConsumerBase Contract\nThe recommended approach to integrate Gelato VRF is by inheriting from the GelatoVRFConsumerBase smart contract. Here's a simple example to help you set it up:\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n​\nimport {GelatoVRFConsumerBase} from \"./GelatoVRFConsumerBase.sol\";\n​\ncontract YourContract is GelatoVRFConsumerBase {\n    // Your contract's code goes here\n}\nUnderstanding 1Balance\nBefore we dive into requesting randomness, it's crucial to understand the role of 1Balance in using Gelato VRF. The Gelato VRF services necessitate that your Gelato balance is sufficiently funded. This balance caters to Gas fees and rewards Gelato Nodes for their computational tasks. For details about costs and funding your account, do visit our 1balance documentation.\nNote: It's important to remember that the current 1Balance system does not support withdrawals after depositing funds. Ensure to deposit only the amount you plan to utilize for Gelato VRF operations.\nStep 4:  Request Randomness\nTo request randomness, call the _requestRandomness() function. You should protect the call since it will take from your 1Balance. The data argument will be passed back to you by the W3F.\n    function requestRandomness(bytes memory data) external {\n        require(msg.sender == ...);\n        uint64 requestId = _requestRandomness(data);\n    }\nStep 5:  Implement the Callback function\nFinally, implement the callback function.\n    function _fulfillRandomness(\n        bytes32 randomness,\n        uint64 requestId,\n        bytes memory data,\n    ) internal override {\n    }\n}\nStep 6: Pass dedicated msg.sender\nWhen you're ready to deploy your Gelato VRF-compatible contract, an important step is to include the dedicated msg.sender as a constructor parameter. This ensures that your contract is set up to work with the correct operator for fulfilling the randomness requests.. It's crucial for ensuring that only authorized requests are processed.\nBefore deploying, visit the Gelato VRF UI. There, you will find the specific dedicated msg.sender address assigned for your deployer address. This address is crucial for the security and proper functioning of your VRF requests. Learn more about it at \nDedicated msg.sender\n​\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n​\nimport {GelatoVRFConsumerBase} from \"./GelatoVRFConsumerBase.sol\";\n​\ncontract YourContract is GelatoVRFConsumerBase {\n    constructor(address operator)\n        GelatoVRFConsumerBase(operator) {\n        // Additional initializations\n    }\n​\n    // The rest of your contract code\n}\nand once you have your contract ready & deployed, grab the address and Deploy your VRF instance.\nPrevious\nTemplate\nNext\nDeploying your VRF Instance\nLast modified 1mo ago\nON THIS PAGE\nStep 1: Set Up Your Development Environment\nStep 2: Install the Gelato VRF Contracts\nStep 3: Inherit GelatoVRFConsumerBase Contract\nStep 4: Request Randomness\nStep 5: Implement the Callback function\nStep 6: Pass dedicated msg.sender"
  },
  {
    "title": "Supported Networks - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/vrf/supported-networks",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\n📙\nUnderstanding VRF\n❔\nHow does Gelato VRF Work?\n🔓\nSecurity Considerations\n📄\nTemplate\n🚀\nQuick Start\n💡\nMigrating from Chainlink VRF\n💰\nPricing & Rate Limits\n✅\nSupported Networks\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n✅\nSupported Networks\nPlease note that our support for the Goerli, Optimism Goerli, and Arbitrum Goerli test networks will be discontinued after December 31, 2023. We recommend users to transition their operations to Sepolia, Optimism Sepolia, or Arbitrum Sepolia to ensure uninterrupted service and support.\nThe following networks are supported:\nName\nDeployment\nEthereum\nMainnet\nGoerli\nSepolia\nPolygon\nMainnet\nMumbai\nFantom\nMainnet\nAvalanche\nMainnet\nBinance Smart Chain\nMainnet\nOptimism\nMainnet\nGoerli\nArbitrum\nMainnet\nGoerli\nGnosis\nMainnet\nTestnet\nZkSync\nMainnet\nGoerli\nPolygonzk\nMainnet\nBase\nMainnet\nGoerli\nLinea\nMainnet\nAstar\nzKatana\nIf you don't see a network that you'd like supported, feel free to reach out to us.\nPrevious\nPricing & Rate Limits\nNext - Services\nAutomate (Legacy)\nLast modified 1mo ago"
  },
  {
    "title": "Template - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/vrf/template",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\n📙\nUnderstanding VRF\n❔\nHow does Gelato VRF Work?\n🔓\nSecurity Considerations\n📄\nTemplate\n🚀\nQuick Start\n💡\nMigrating from Chainlink VRF\n💰\nPricing & Rate Limits\n✅\nSupported Networks\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n📄\nTemplate\nHardhat Template\nGitHub - gelatodigital/vrf-nft-hardhat\nGitHub\nFoundry Template\nhttps://github.com/gelatodigital/vrf-nft\ngithub.com\n​\nPrevious\nSecurity Considerations\nNext\nQuick Start\nLast modified 1mo ago\nON THIS PAGE\nHardhat Template\nFoundry Template"
  },
  {
    "title": "Pricing & Rate Limits - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/vrf/pricing-and-rate-limits",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\n📙\nUnderstanding VRF\n❔\nHow does Gelato VRF Work?\n🔓\nSecurity Considerations\n📄\nTemplate\n🚀\nQuick Start\n💡\nMigrating from Chainlink VRF\n💰\nPricing & Rate Limits\n✅\nSupported Networks\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n💰\nPricing & Rate Limits\nOverview\nIn order for the network to be sustainable & decentralized, Gelato Nodes charge fees for running off-chain computation and executing transactions.\nOur default method is to pay for all your Web3 Function costs across all networks from a single balance using  Gelato 1Balance. \nTransaction Charges\nEach transaction that Gelato Nodes execute require a small fee to incentivize Nodes to adhere to the protocol and get your transactions included into your desired blockchain in a fast and secure fashion. \nTo achieve this, Nodes charge a fee as a percentage of total gas cost for the executed transaction. This varies across networks - Nodes charge higher premiums on cheaper networks and vice versa.\nNetwork\nPercentage Premium (%)\nEthereum\n20\nPolygon\n70\nBNB\n30\nAvalanche\n40\nFantom\n50\nArbitrum\n50\nOptimism\n50\nZkSync Era\n50\nGnosis\n100\nLinea\n50\nBase\n50\nPolygon zkEvm\n50\nTable 1 - Fee premiums as a percentage of total gas cost per network. Testnet transactions are subsidized by Gelato.\nThese transaction premiums can be customised for users. Please reach out to us here to discuss your needs.\nRequest Limits\nVRF requests are using Gelato Web3 functions under the hood, which subsidize the first 10.000 requests per months. If you target an higher number of requests, please check Web3 functions subscriptions plans to upgrade to an higher tier.\nPrevious\nMigrating from Chainlink VRF\nNext\nSupported Networks\nLast modified 1mo ago\nON THIS PAGE\nOverview\nTransaction Charges\nRequest Limits"
  },
  {
    "title": "Migrating from Chainlink VRF - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/vrf/migrating-from-chainlink-vrf",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\n📙\nUnderstanding VRF\n❔\nHow does Gelato VRF Work?\n🔓\nSecurity Considerations\n📄\nTemplate\n🚀\nQuick Start\n💡\nMigrating from Chainlink VRF\n💰\nPricing & Rate Limits\n✅\nSupported Networks\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n💡\nMigrating from Chainlink VRF\nAlready using Chainlink VRF? Here's how you can quickly and easily migrate to GelatoVRF.\n1. Understand the Implications\nWhile this migration option is available, be aware that it can lead to higher gas costs and added development intricacies. We advise this route only if:\nYou've already deployed a Chainlink VRF Consumer.\nYour Chainlink VRF Consumer has the capability to update its Coordinator address.\nOtherwise, for new integrations, we recommend directly implementing the Gelato VRF.\nInitiate Migration\nIf you're set on migrating an existing Chainlink VRF Consumer:\nBegin by creating your VRF task. In the \"VRF Type\" selection window, opt for \"VRF Compatibility\".\nChoose the blockchain network for deployment.\nYou will then be asked to deploy your Adapter contract:\nOnce deployed, the app will show you the address to which the adapter contract was deployed. You now need to replace the old Coordinator address in your contract by this address.\nFinally, select the Request Contract Gelato nodes should respond to.\nPrevious\nDeploying your VRF Instance\nNext\nPricing & Rate Limits\nLast modified 1mo ago\nON THIS PAGE\n1. Understand the Implications\nInitiate Migration"
  },
  {
    "title": "Understanding VRF - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/vrf/understanding-vrf",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\n📙\nUnderstanding VRF\n❔\nHow does Gelato VRF Work?\n🔓\nSecurity Considerations\n📄\nTemplate\n🚀\nQuick Start\n💡\nMigrating from Chainlink VRF\n💰\nPricing & Rate Limits\n✅\nSupported Networks\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n📙\nUnderstanding VRF\nGrasping the essence of Gelato VRF and its pivotal role in blockchain randomness.\nAfter reading this page:\nYou'll grasp the importance and challenges of generating randomness on the blockchain.\nYou'll learn how Gelato VRF works and why it's trustworthy.\nWhat is Verifiable Random Function (VRF)\nA VRF or Verifiable Random Function is a unique blend of cryptographic techniques that generates pseudorandom numbers in a publicly verifiable manner. Think of VRF as a way to generate random numbers where:\nThe entity possessing a secret key can compute the random number and also provide a proof of its correctness.\nAnyone with the public key can verify that the random number was indeed computed correctly, ensuring the integrity of the result.\nIn simple terms, VRFs are like cryptographic hash functions but with an added layer of public verification. They're an essential tool in systems where the trustworthiness of random outputs is highly important.\nGelato VRF and Trustworthy Randomness\nGelato VRF offers real randomness for blockchain applications by leveraging Drand, a trusted decentralized source for random numbers. With Gelato VRF, developers get random values that are both genuine and can be checked for authenticity.\nApplications of Gelato VRF:\nThe potential applications of a reliable and transparent random number generator on the blockchain are vast. Here are just a few use cases:\nGaming and Gambling: Determine fair outcomes for online games or decentralized gambling applications.\nDecentralized Finance (DeFi): Use in protocols where random selections, like lottery systems, are required.\nNFT Generation: Randomly generate traits or characteristics for unique digital assets.\nProtocol Decision Making: In protocols where decisions need to be randomized, such as selecting validators or jurors.\nServices - Previous\nVRF\nNext\nHow does Gelato VRF Work?\nLast modified 1mo ago\nON THIS PAGE\nWhat is Verifiable Random Function (VRF)\nGelato VRF and Trustworthy Randomness\nApplications of Gelato VRF:"
  },
  {
    "title": "How does Gelato VRF Work? - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/vrf/how-does-gelato-vrf-work",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\n📙\nUnderstanding VRF\n❔\nHow does Gelato VRF Work?\n🔓\nSecurity Considerations\n📄\nTemplate\n🚀\nQuick Start\n💡\nMigrating from Chainlink VRF\n💰\nPricing & Rate Limits\n✅\nSupported Networks\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n❔\nHow does Gelato VRF Work?\nGelato VRF (Verifiable Random Function) provides a unique system offering trustable randomness on EVM-compatible blockchains. But what's the magic behind this reliable randomness? Let's see!\nAfter reading this page:\nYou'll be able to understand the core components of Gelato VRF.\nYou'll understand how you can initiate a randomness request.\nYou'll be able to navigate the randomness delivery.\nYou'll understand how to integrate and utilize Gelato VRF.\nCore Component\nDrand: This is the heart of the randomness. Drand is a decentralized randomness beacon, ensuring the unpredictability and unbiased nature of the random numbers provided. To learn more about Drand and how it works, please refer to their documentation.\nTop level Flow\n +------------------------+\n | 1. Contract Deployment |\n +------------------------+\n          |\n          v\n +-----------------------+\n | 2. Requesting         |\n |    Randomness         |\n +-----------------------+\n          |\n          v\n +-----------------------+\n | 3. Processing the     |\n |     randomness        |\n |       event           |\n +-----------------------+\n          |\n          v\n +-----------------------+\n | 4. Randomness Delivery|\n +-----------------------+\n​\n1. Contract Deployment\nThe smart contract that developers need to interact with is located at GelatoVRFConsumerBase.sol​\nThis contract serves as an interface to the Gelato VRF system, allowing other smart contracts to request and receive random numbers.\n2. Requesting Randomness\nInside the GelatoVRFConsumer contract, there's an event named RequestedRandomness. When a randomness request is made, this event is emitted.\nThe RequestedRandomness event serves as a beacon, signaling the Gelato VRF system about the need for a random number. It contains 2 parameters:\n round explicitly signifies which Drand round is targeted to fulfill the randomness,\ndata offers versatility for developers, it can be used to attach any supplementary information or context about the randomness request.\nevent RequestedRandomness(uint256 round, bytes data);\n3. Processing the Randomness Request\nInternally, the system leverages Web3 functions to listen for the emitted RequestedRandomness event and to fetch the required random number from Drand.\n4. Delivering Randomness\nComposable Callback with Arbitary Data\nInternally, the system invokes the fulfillRandomness function in the requesting contract.\nCallback Invocation and Data Decoding\nThe random number (sourced from Drand) is passed as the randomness parameter to the function. Additionally, the data parameter can carry any supplementary data provided during the original request or by the Gelato VRF.\nPrevious\nUnderstanding VRF\nNext\nSecurity Considerations\nLast modified 1mo ago\nON THIS PAGE\nCore Component\nTop level Flow\n1. Contract Deployment\n2. Requesting Randomness\n3. Processing the Randomness Request\n4. Delivering Randomness"
  },
  {
    "title": "Security Considerations - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/vrf/security-considerations",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\n📙\nUnderstanding VRF\n❔\nHow does Gelato VRF Work?\n🔓\nSecurity Considerations\n📄\nTemplate\n🚀\nQuick Start\n💡\nMigrating from Chainlink VRF\n💰\nPricing & Rate Limits\n✅\nSupported Networks\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🔓\nSecurity Considerations\nAfter reading this page you will:\nUnderstand the importance of security measures when implementing Gelato VRF in your dApp.\nRecognize the need for state locking to prevent front-running and maintain the integrity of the randomization process.\nLearn the benefits of using RNGLib to ensure the randomness you receive is unique and secure, particularly when handling multiple requests simultaneously.\nImportant Note\nContrary to some other VRF providers, Gelato VRF is verifiable off-chain but not on-chain. This is due to the nature of the BLS signatures used by Drand network, which are not yet supported at EVM level. With the upcoming EIP-2537 release, adding BLS precompile for BLS12-381 curve, we aim to add support for on-chain randomness verification in a near future on all networks that will include this precompile.\nSecurity Precautions\nWhen integrating with GelatoVRF, it's essential to take several precautions to ensure the safety and reliability of your application. Here are key considerations:\n1. State Locking and Front-Running Prevention\nAfter you initiate a request for randomness and before the random number gets delivered, it's essential to lock the relevant application state in your consumer contract. This step minimizes the risk of front-running attacks.\nIn essence, front-running involves gaining an unfair advantage by making transactions based on foreknowledge of pending transactions. By locking the state, you add an additional layer of security against such tactics.\n2. Usage of RNGLib\nInstead of using the received randomness directly, consider integrating it with our RNGLib. This approach:\nEnables dynamic fetching of random values as required.\nOffers protection against certain bet arbitrage attacks, especially when multiple applications operate simultaneously.\nBy inheriting from GelatoVRFConsumerBase.sol, your contract will automatically benefit from enhanced security. All fulfilled randomness requests will be dynamically derived from the drand randomness using a pseudo-random number generator (RNG). This is crucial to ensure the uniqueness of values, particularly for concurrent requests, and adds another layer of protection against potential vulnerabilities.\nPrevious\nHow does Gelato VRF Work?\nNext\nTemplate\nLast modified 1mo ago\nON THIS PAGE\nSecurity Precautions\n1. State Locking and Front-Running Prevention\n2. Usage of RNGLib"
  },
  {
    "title": "Contract Addresses - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/contract-addresses",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🔗\nContract Addresses\nWeb3 Functions during the private beta uses a custom deployment of the `Automate.sol` contract as an entry point. \n\nOn the Automate smart contract users create or cancel and Gelato executes tasks. By default, Web3 Functions uses the dedicated msg.sender module, which means all transactions to the defined destination contract will be routed via your dedicated msg.sender proxy contract. \nNote: If you have an access restriction in your smart contract function and want to whitelist your personal Gelato smart contract wallet as a msg.sender, you don't need to do anything. We automatically deploy your own dedicated msg.sender for you at the first task creation  - the address to whitelist will be shown in the UI and can also be retrieved via the Automate SDK.\nAll other networks\nZkSync Era\nContract\nAddress\nAutomate\n0x2A6C106ae13B558BB9E2Ec64Bd2f1f7BEFF3A5E0\n1Balance (where you deposit funds)\n0x7506C12a824d73D9b08564d5Afc22c949434755e\nPrevious\nSupported Networks\nNext\nSubscription & Payments\nLast modified 5d ago"
  },
  {
    "title": "Subscription & Payments - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/subscription-and-payments",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n💰\nSubscription & Payments\nSubscription Plans\nWith our subscription plans, users can choose the level of service that best fits their development and operational needs. Our plans are designed to cater to everything from small-scale projects to large enterprise operations.\nGelato Units (G-units)\nWe're introducing a new way to measure your usage: Gelato Units, or G-Units. G-Units are a straightforward way to calculate how much computing power your tasks use. They replace the old method of counting each task run, allowing you to run more tasks with less resource use. If your tasks are simple and use fewer resources, you can do more of them each month. The less computing power you use, the more tasks you can run—making G-Units a fairer way to measure and pay for what you actually use.\nText\nResource Used\nGelato Units\nSolidity Function\n1 Run\n1 GU\nTypescript Function\n1 RPC Call\n1 CPU Second\n1 GU\n2 GU\nTransaction Simulation\nEach time a solidity or a typescript function returns an executable payload, we verify that the transaction is not reverting\n1 GU\nYou decide when your Function triggers; running it more often will use up more G-Units. For instance, if a task is executed with every new block on the Polygon network, it will use more G-Units than if it’s scheduled to execute just once at month's end.\nYou can keep track of your current subscription and handle all aspects of your plan with ease. To view your current plan, click here. To manage your subscriptions, click here. \nPayments\nIn order for the network to be sustainable & decentralized, Gelato Nodes charge fees for running off-chain computation and executing transactions.\nOur default method is to pay for all your Web3 Function costs across all networks from a single balance using  Gelato 1Balance.  Learn more about it by heading over the linked page:\n1Balance\nIf you exceed these limits your Web3 Function runs will be throttled. If you have any questions or would like to discuss your subscription, please reach out to us here. \nTransaction Charges\nEach transaction that Gelato Nodes execute require a small fee to incentivize Nodes to adhere to the protocol and get your transactions included into your desired blockchain in a fast and secure fashion. \nTo achieve this, Nodes charge a fee as a percentage of total gas cost for the executed transaction. This varies across networks - Nodes charge higher premiums on cheaper networks and vice versa.\nNetwork\nPercentage Premium (%)\nEthereum\n20\nPolygon\n70\nFantom\n50\nAvalanche\n40\nBNB\n30\nOptimism\n50\nArbitrum\n50\nGnosis\n100\nZkSync Era\n50\nPolygon zkEvm\n50\nBase\n50\nLinea\n50\nTable 1 - Fee premiums as a percentage of total gas cost per network. Testnet transactions are subsidized by Gelato.\nThese transaction premiums can be customised for users. Please reach out to us here to discuss your needs.\nTransaction pays for itself\nYou can also choose to have your function pay the fee during executions. It must be remembered that running Web3 Functions has computational costs. Please see here the Free Tier limits, in the case that the Web3 Functions goes above these limits, 1Balance will be also required to pay for the computational costs. \nThis can be done by inheriting AutomateReady.\ncontract CounterWT is AutomateReady {\n    uint256 public count;\n    uint256 public lastExecuted;\n​\n    constructor(address _automate, address _taskCreator)\n        AutomateReady(_automate, _taskCreator)\n    {}\n​\n    receive() external payable {}\n​\n    function increaseCount(uint256 amount) external onlyDedicatedMsgSender {\n        count += amount;\n        lastExecuted = block.timestamp;\n​\n        (uint256 fee, address feeToken) = _getFeeDetails();\n​\n        _transfer(fee, feeToken);\n    }\n}\n​\nIn the increaseCount function, we use _transfer inherited from AutomateReady to pay Gelato.\n_transfer has two parameters, fee and feeToken which has to be queried from the Automate contract by using getFeeDetails()\nTo create a task that pays for itself, head over to the task properties and enable the 'Transaction pays itself\"\n​\nPrevious\nContract Addresses\nNext - Services\nVRF\nLast modified 2d ago\nON THIS PAGE\nSubscription Plans\nGelato Units (G-units)\nPayments\nTransaction Charges\nTransaction pays for itself"
  },
  {
    "title": "Analytics & Monitoring - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/analytics-and-monitoring",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🔍\nAnalytics & Monitoring\nTask Performance Dashboard\nGelato's Web3 Function UI offers enriched monitoring and analytics capabilities, allowing you to closely track the performance and usage statistics of your Typescript and Solidity function tasks.\nUsage Insights: Get a clear picture of how much you've used from your Web3 function plan. Our intuitive metrics and forecast charts help you understand your current usage and predict future needs.\nTask Identification: Quickly figure out if a task is powered by Typescript or Solidity. This feature simplifies how you view and manage your suite of Gelato Web3 functions.\nTrend Tracking: Our updated chart design lets you track how your usage changes day-to-day, providing insights for better planning and task management.\nPlan Details: Know exactly what you're getting with your subscription. \nLogs & Status\nBesides the task logs available in the UI, Gelato Web3 Functions offer a more detailed and granular monitoring system providing status and logs APIs.\nTask Status URL\nProvided the ChainId and taskId,  this API will return the current Task status\nhttps://api.gelato.digital/tasks/web3functions/networks/{chainId}/tasks/{taskId}/status\nFor example, if your chainId, taskId are:\nchainId: 137\ntaskId: 0xdeaeee394c952d8b23c86eacc704adf7b605d89d992cec9a5fc86e4a517f053b\nThen the URL to go to is:\nhttps://api.gelato.digital/tasks/web3functions/networks/137/tasks/0xdeaeee394c952d8b23c86eacc704adf7b605d89d992cec9a5fc86e4a517f053b/status\nFor this taskId, here is the returned task information:\n{\n    \"task\":{\n    \"chainId\":137,               \n    \"taskId\":\n\"0xdeaeee394c952d8b23c86eacc704adf7b605d89d992cec9a5fc86e4a517f053b\",\n    \"taskState\":\"CheckPending\",\n    \"creationDate\":\"2023-06-01T20:10:39.985Z\",\n    \"lastCheckDate\":\"2023-06-09T06:22:44.966Z\",\n    \"lastCheckMessage\":\"Fail to run Web3Function: Web3Function exited with code=1\",\n    \"lastExecDate\":\"2023-06-09T08:15:11.883Z\",\n    \"lastExecTransactionHash\":\n\"0xc2e57f5b56bf24ae77eca31fbe76ecf16cd30cb0fc5592207bb567addff62402\"\n          }\n }\nThe first thing to look at is the taskState key:\nTask states:\nFor the taskState key, these are the possible values:\nCheckPending: the task is pending simulation.\nExecPending: the task is executable and is awaiting inclusion into the blockchain.\nWaitingForConfirmation: the task was included into the blockchain but is still awaiting the required amount of blocks confirmations.\nExecSuccess: the task has been successfully executed.\nCancelled: the task has been canceled by the owner\nExecReverted: the task transaction has been reverted.\nTask  Logs URL\nProvided the ChainId and taskId,  this API will return the logs in the last 24 hours, the query param limit is optional\nhttps://api.gelato.digital/tasks/web3functions/networks/{chainId}/tasks/{taskId}/logs?limit=NrLogs\nFor example, if your chainId, taskId and NrLogs are:\nchainId: 137\ntaskId: 0xdeaeee394c952d8b23c86eacc704adf7b605d89d992cec9a5fc86e4a517f053b\nNrLogs:2\nThen the URL to go to is:\nhttps://api.gelato.digital/tasks/web3functions/networks/137/tasks/0xdeaeee394c952d8b23c86eacc704adf7b605d89d992cec9a5fc86e4a517f053b/logs?limit=2\nFor this taskId, here is the returned task information:\n{\n    {\"logs\":\n      [\n        {\"date\":\"2023-06-09T08:43:52.404Z\",\n        \"state\":\"WaitingForConfirmation\",\n        \"type\":\"WaitingForConfirmation\",\n        \"message\":\"txHash: 0x788726ed95f2f916a47cae0c6cdfbea91e1c8e3756f91e0efc08fa501daed8f0\"\n        },\n        {\"date\":\"2023-06-09T08:43:51.835Z\",\n        \"state\":\"ExecPending\",\n        \"type\":\"ExecPendingCheck\",\n        \"message\":\"Task submitted for execution\",\n        \"web3FunctionLogs\":[\"Text generated: \",\"Chaffinches are small, colourful birds which feed on seeds and insects. They have buff-coloured breasts streaked with brown markings, bright pinkish-red faces and wings marked with white bars. In summer they breed in woodlands; in winter many move south to warmer areas.\",\"Text generated: \",\"Chameleons are lizards known for their ability to change color, excellent vision and long, sticky tongues used to catch prey.\"]\n        }\n    ]\n}\nAlerts\nWeb3 Functions provides an alerting service to enable you to get notified about your task executions, problems or when your balance is getting low. Alerting currently supports notifications in Telegram and Discord, with other channels on the way.\nTypes of notifications\nType\nDescription\nBalance\nIf your task uses Gelato Balance you need to ensure that you always have enough funds deposited, otherwise your executions will stop executing until you top-up. \n\nSet a balance alert to be notified when your funds are running low - you can use our default levels or set your own threshold.\nSetting up Telegram Notifications\nYou can visit your notifications area to follow the steps listed below.\n1.\nAdd GelatoWatcherBot to your Telegram - if you have Telegram installed you can just click on the link to do this.  \n2.\nEnter the command /start\n3.\nThe bot will show you the main alerts that you can request by entering the command.\nWhen you enter each command the bot will step you through the inputs required to finish setting up the alert. \nYou can view the full list of commands at any time by entering /help\nTelegram Bot Commands\nCommand\nUsage\n/balance\nAlerts when your Gelato Balance drops below the minimum balance threshold. The default thresholds are listed here. \n​\nThe bot will prompt you for the wallet address that you use to create and manage your tasks. \n​\nTo provide multiple addresses enter each one as a new message to the bot.\n​\nIf you use the same wallet address across multiple networks, you will be alerted when any of these drop below the default thresholds.\n\nIf you would like to set your own threshold use the /balance_threshold command.\n/balance_threshold\nAlerts you when your Gelato Balance drops below the threshold you set on a specific network.\n\nAfter entering the /balance_threshold command the bot will prompt you to specify the chain IDs and your threshold level. Chain IDs are listed here. \n\n\nFor example to be alerted when your Gelato Balance drops below 0.15 ETH on mainnet you would enter 1,0.15\n/list_threshold\nList all custom and default balance thresholds of each network\nDiscord DM Notifications\nIn this mode you receive your alerts as DM's to your Discord handle. To activate:\n1.\nJoin our Gelato Discord server​\n2.\nChoose from the list of commands below\nIf you would prefer to receive alerts in a specific channel please see how to get Discord notifications in your server.\nCommand\nUsage\n/balance-dmaddress\nAlerts when your Gelato Balance drops below the default threshold for the specified wallet address. The default thresholds are listed below. \n​\nTo provide multiple addresses enter a new command to the bot for each address.\n​\nIf you use the same wallet address across multiple networks, you will be alerted when any of these drop below the default thresholds.\n\nTo set your own threshold use the /balance-threshold-dm command.\n/balance-threshold-dm chain_id threshold\nAlerts you when your Gelato Balance drops below the threshold you set on a specific network.\n\nUse the /balance-dm command to set the address(es) that you would like to monitor. \n\nChain IDs are listed here. \n\n\nFor example to be alerted when your Gelato Balance drops below 0.15 ETH on mainnet you would enter 1 0.15\n/list-threshold-dm\nList all custom and default balance thresholds of each network\nDiscord notifications in your own server\n1.\nAdd our Gelato Bot to your server using this invite link (you need to be admin of the server)\n2.\nIf you want to receive notifications in a private channel, make sure to add Gelato Bot as a member in the channel where you want to receive the notification.\n3.\nEnter the following commands in the channel you want to receive alerts.\nCommand\nUsage\n/balance-channeladdress\nAlerts when your Gelato Balance drops below the default threshold for the specified wallet address. The default thresholds are listed below. \n​\nTo provide multiple addresses enter a new command to the bot for each address.\n​\nIf you use the same wallet address across multiple networks, you will be alerted when any of these drop below the default thresholds.\n\nTo set your own threshold use the /balance-threshold-dm command.\n/balance-threshold-channel chain_id threshold\nAlerts you when your Gelato Balance drops below the threshold you set on a specific network.\n\nUse the /balance-dm command to set the address(es) that you would like to monitor. \n\nChain IDs are listed here. \n\n\nFor example to be alerted when your Gelato Balance drops below 0.15 ETH on mainnet you would enter 1 0.15\n/list-threshold-channel\nList all custom and default balance thresholds of each network\n/stop-balance-channel\nSwitch off all low balance alerts\nDefault Thresholds\nUnless overridden these are the default levels that are used for each network.\nNetwork\nChain ID\nDefault Threshold\nEthereum\n1\n0.05 ETH\nPolygon\n137\n20 MATIC\nFantom\n250\n20 FTM\nAvalanche\n43114\n0.5 AVAX\nBNB Chain\n56\n0.05 BNB\nOptimism\n10\n0.05 ETH\nArbitrum\n42161\n0.05 ETH\nGnosis\n100\n5 XDAI\nzkSync Era\n324\n​\nPolygon zkEVM\n1101\n​\nBase\n8453\n​\nLinea\n59144\n​\nIf you need more notifications or new communication channels, your feedback and suggestions are always welcome. \nPrevious\nInitiate an Automated Transaction\nNext\nSupported Networks\nLast modified 1mo ago\nON THIS PAGE\nTask Performance Dashboard\nLogs & Status\nTask Status URL\nTask Logs URL\nAlerts\nTypes of notifications\nDiscord DM Notifications\nDiscord notifications in your own server\nDefault Thresholds"
  },
  {
    "title": "Supported Networks - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/supported-networks",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n✅\nSupported Networks\nPlease note that our support for the Goerli, Optimism Goerli, and Arbitrum Goerli test networks will be discontinued after December 31, 2023. We recommend users to transition their operations to Sepolia, Optimism Sepolia, or Arbitrum Sepolia to ensure uninterrupted service and support.\nThe following networks are supported:\nName\nDeployment\nEthereum\nMainnet\nTestnet\nPolygon\nMainnet\nTestnet\nFantom\nMainnet\nAvalanche\nMainnet\nBinance Smart Chain\nMainnet\nOptimism\nMainnet\nTestnet\nArbitrum\nMainnet\nTestnet\nGnosis\nMainnet\nTestnet\nzkSync Era\nMainnet\nTestnet\nPolygon zkEVM\nMainnet\nBase\nMainnet\nTestnet\nLinea\nMainnet\nAstar\nTestnet\nGelato OP\nTestnet\nTangible Unreal\nTestnet\nIf you don't see a network that you'd like supported, feel free to reach out to us.\nPrevious\nAnalytics & Monitoring\nNext\nContract Addresses\nLast modified 5d ago"
  },
  {
    "title": "Template & Use Cases - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/template-and-use-cases",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n📝\nTemplate & Use Cases\nTemplate\nTypescript Function \nHardhat Template\nGitHub - gelatodigital/web3-functions-hardhat-template: A template to get started using Gelato Web3 Functions in your hardhat dev environment.\nGitHub\nVanilla Template\nGitHub - gelatodigital/web3-functions-template: Gelato Web3 Functions template & examples\nGitHub\nSolidity Function\nHardhat Template\nGitHub - gelatodigital/automate-unit-testing: The purpose of this repo is to showcase unit tests examples of using Gelato Automate in a Hardhat enviroment.\nGitHub\nFoundry Template\nGitHub - gelatodigital/gelato-automate-foundry-template: Gelato Automate examples on Foundry\nGitHub\nUse Cases Repo\nGithub repo listing the existing use-cases and PoCs to speed run your learning.\nGitHub - gelatodigital/w3f-use-cases-demos: Repository with all W3F use cases and PoC\nGitHub\nQuick Links Use Cases\n​BProtocol Liquidation​\n​Pyth Oracle PoC​\n​RedStone Oracle PoC​\n​Contract dynamically creating Web3 Functions​\n​Shared Storage between Tasks​\n​Automatic Bribing​\n​Lens GPT​\n​Gelato Nft Bot​\n​Enzyme Vault​\n​Airdrop Claiming​\n​Automated Topup​\n​Aggregate Fee Swapper​\n​Gasless CCTP​\nPrevious\nSecurity Considerations\nNext\nQuick Start\nLast modified 2mo ago\nON THIS PAGE\nTemplate\nTypescript Function\nSolidity Function\nUse Cases Repo\nQuick Links Use Cases"
  },
  {
    "title": "Quick Start - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/quick-start",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n➡\nWriting Typescript Functions\n➡\nTest, Deploy & Run Typescript functions\n➡\nWriting Solidity Functions\n➡\nTest, Deploy & Run Solidity Functions\n➡\nInitiate an Automated Transaction\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🚀\nQuick Start\nWelcome to the Quick Start guide for Web3 Functions! Whether you're familiarizing yourself with Typescript Functions, diving deep into Solidity Functions, or aiming to set up simple Transactions, this guide is tailor-made for you.\nIn this Quick Start, you'll:\nUnderstand and navigate the Typescript Function process from writing to deployment.\nMaster the art of crafting a Solidity Function.\nGet acquainted with the simplicity of Transactions, where no additional coding is required; just pick your contract and function.\nGenerate tasks for your Typescript Function, Solidity Function or Transaction seamlessly.\nDive in, and let's get started with Web3's Functions functionalities!\nPrevious\nTemplate & Use Cases\nNext\nWriting Typescript Functions\nLast modified 2mo ago"
  },
  {
    "title": "Security Considerations - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/security-considerations",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🔐\nSecurity Considerations\nDedicated msg.sender\nFor security reasons, during task creation, you will see an address which will be the msg.sender for your task executions.\nIf you are the owner of the target contract in question, it's recommended to implement a msg.sender restriction within your smart contract. This involves whitelisting a dedicated msg.sender address. Such a measure ensures that only tasks you have created can call your function, significantly elevating the security posture of your operations. For a hands-on guide and to manage your dedicated msg.sender settings, please connect to the app and visit your own Settings page.\nRemember that your dedicated msg.sender can vary across different blockchain networks. You can view the dedicated msg.sender for each network through the provided settings link.\nmsg.sender restrictions should be added to the function that Gelato will call during execution, not the checker function. Learn more about it here: \n1.-understand-the-role-of-a-checker\n​\nYou can have this restriction by inheriting AutomateReady​\nAutomateReady exposes a modifier onlyDedicatedMsgSender which restricts msg.sender to only task executions created by taskCreator defined in the constructor.\n    modifier onlyDedicatedMsgSender() {\n        require(msg.sender == dedicatedMsgSender, \"Only dedicated msg.sender\");\n        _;\n    }\nIf you would like to have additional callers for your function. You can implement a whitelist like so.\n    mapping(address => bool) public whitelisted;\n​\n    modifier onlyWhitelisted() {\n        require(\n            whitelisted[msg.sender] || msg.sender == dedicatedMsgSender,\n            \"Only whitelisted\"\n        );\n        _;\n    }\n​\nPrevious\nUsing the Automate SDK\nNext\nTemplate & Use Cases\nLast modified 1mo ago"
  },
  {
    "title": "Understanding Web3 Functions - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions/understanding-web3-functions",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n1⃣\nTrigger Types\n2⃣\nTypescript Function\n3⃣\nSolidity Function\n4⃣\nAutomated Transactions\n5⃣\nCreate a Web3 Function Task\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n📙\nUnderstanding Web3 Functions\nDetermining your Needs\nOff-chain Data or Computation?\nSometimes, automation tasks require data that isn't readily available on the blockchain, or they might need computations that are better performed off-chain. In such cases, Typescript Functions should be the choice.\nAll Checks On-chain?\nIf all the conditions necessary for your automation task can be directly verified on the blockchain, you have the option to select between Typescript Functions, Solidity Functions & Automated Transactions\nImplementation path\nStep\nDescription\n1.\nHow you want to trigger your run?\nStart by deciding on the type of trigger you want to use. (Time, event, or every block)\n2.\nWhat to run?\nTypescript Function\nSolidity Function\nTransaction\n3.\nTask Creation\nCreate a Web3 Function task to allow the execution of typescript, solidity or transaction\n3.\nFinalize & Monitor\nOnce you've defined your function ensure you monitor its execution to confirm that it works as expected. Make any necessary adjustments.\n​\nCore Features of Web3 Functions\nMain features of Web3 Functions include Typescript Functions, Solidity Functions & Automated Transactions\nBefore jumping into the core features of the Web3 Functions, it is highly recommended that you first learn how you'd like to trigger your run. To learn more:\n1⃣\nTrigger Types\nLearn more about each of the 3 actions that your trigger can run:\n2⃣\nTypescript Function\n3⃣\nSolidity Function\n4⃣\nAutomated Transactions\nPre-Requisite of Target Smart Contract\nSmart contract functions in the target contract that can be automated should follow these properties:\nThey need to be functions that are usually called by the development team or external keepers, not \"user facing\" functions called by users directly\nThey need to be either public or external\nThey do not have access restrictions like an onlyOwner modifier, unless the user's dedicated msg.sender address is whitelisted through the proxy module.\nThey do not require msg.sender to be tx.origin\nServices - Previous\nWeb3 Functions\nNext\nTrigger Types\nLast modified 2mo ago\nON THIS PAGE\nDetermining your Needs\nOff-chain Data or Computation?\nAll Checks On-chain?\nImplementation path\nCore Features of Web3 Functions\nPre-Requisite of Target Smart Contract"
  },
  {
    "title": "callWithSyncFee - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/non-erc-2771/callwithsyncfee",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n3⃣\nsponsoredCall\n2⃣\ncallWithSyncFee\n🍧\nRelay Context Contracts\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n2⃣\ncallWithSyncFee\nPermissionless transactions with on-chain payments\nAfter reading this page: \nYou'll know how to use the callWithSyncFee SDK method, using the syncFee payment method.\nYou'll see some code which will help you send a relay request within minutes.\nYou'll learn how to pay for transactions using the provided values for fee, feeToken and feeCollector.\nPlease proceed to our Security Considerations page and read it thoroughly before advancing with your implementation. It is crucial to understand all potential security risks and measures to mitigate them.\nOverview\nThe callWithSyncFee method uses the syncFee payment method. \nPaying for Transactions\nWhen using callWithSyncFee relay method the target contract assumes responsibility for transferring the fee to Gelato's fee collector during transaction execution. For this, the target contract needs to know:\nfee: the transfer amount\nfeeToken: the token to be transferred\nfeeCollector: the destination address for the fee\nFortunately, Gelato provides some useful tools within the Relay Context Contracts:\n1.\nBy inheriting the GelatoRelayContext  contract in your target contract, you have the ability to transfer the fee through one of two straightforward methods: _transferRelayFee() or _transferRelayFeeCapped(uint256 maxFee). In either case, the inherited contract takes care of decoding the fee, feeToken, and feeCollector behind the scenes.\nThe Gelato Relay backend simplifies the process by automatically calculating the fee for you, using Gelato's Fee Oracle to perform the calculations in the background.\n2.\nAlternatively, you may choose to inherit the GelatoRelayFeeCollector contract. With this approach, Gelato only decodes the feeCollector. You must provide the fee and feeToken on-chain, either by hardcoding them (which is not recommended) or embedding them within the payload to be executed. The suggested way to handle this is to calculate the fee with Gelato's Fee Oracle.\nSetting maxFee for Your Transaction\nSetting a maximum fee, or maxFee, for your transactions is strongly advised. This practice enables you to ensure that transaction costs remain below a specific limit. The method _transferRelayFeeCapped(uint256 maxFee) in the GelatoRelayContext contract provides a convenient way to set the maxFee easily.\nIf you are utilizing the GelatoRelayFeeCollector contract, the recommended way to pass the maxFee is by calculating the fee with Gelato's Fee Oracle, which is accessible in the relay-sdk. The getEstimatedFee() method is provided to facilitate this calculation.\nSDK method: callWithSyncFee\nconst callWithSyncFee = async (\n  request: CallWithSyncFeeRequest,\n  options?: RelayRequestOptions,\n  apiKey?: string\n): Promise<RelayResponse>\nArguments:\nrequest: this is the request body used to send a request.\noptions: RelayRequestOptions is an optional object.\napiKey: this is an optional API key that links your request to your Gelato Relay account. As this pertains to the syncFee payment method, transaction costs won't be deducted from your 1Balance account. By using the API key, you can benefit from increased rate limits of your Gelato Relay account.\nReturn Object: RelayResponse\ntype RelayResponse = {\n  taskId: string;\n};\ntaskId: your unique relay task ID which can be used for tracking your request.\nOptional Parameters \nSee Optional Parameters. \nSending a Request\nRequest Body\nconst request = {\n  chainId: BigNumberish;\n  target: string;\n  data: BytesLike;\n  isRelayContext?: boolean;\n  feeToken: string;\n};\nchainId: the chain ID of the chain where the target smart contract is deployed.\ntarget: the address of the target smart contract.\ndata: encoded payload data (usually a function selector plus the required arguments) used to call the required target address.\nisRelayContext: an optional boolean (default: true) denoting what data you would prefer appended to the end of the calldata.\nIf set to true (default), Gelato Relay will append the feeCollector address, the feeToken address, and the uint256 fee to the calldata. This requires the target contract to inherit the GelatoRelayContext contract.\nIf set to false, Gelato Relay will only append the feeCollector address to the calldata. In this case the contract to be inherit by the target contract is the GelatoRelayFeeCollector.\nfeeToken: the address of the token that is to be used for payment. Please visit SyncFee Payment Tokens for the full list of supported payment tokens per network.\nExample Code GelatoRelayContext\n1. Deploy a GelatoRelayContext compatible contract\n1\n// SPDX-License-Identifier: MIT\n2\npragma solidity 0.8.17;\n3\n​\n4\nimport {\n5\n    GelatoRelayContext\n6\n} from \"@gelatonetwork/relay-context/contracts/GelatoRelayContext.sol\";\n7\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n8\n​\n9\n// Inheriting GelatoRelayContext gives access to:\n10\n// 1. _getFeeCollector(): returns the address of Gelato's feeCollector\n11\n// 2. _getFeeToken(): returns the address of the fee token\n12\n// 3. _getFee(): returns the fee to pay\n13\n// 4. _transferRelayFee(): transfers the required fee to Gelato's feeCollector.abi\n14\n// 5. _transferRelayFeeCapped(uint256 maxFee): transfers the fee to Gelato\n15\n//    only if fee < maxFee\n16\n// 6. _getMsgData(): returns the original msg.data without appended information\n17\n// 7. onlyGelatoRelay modifier: allows only Gelato Relay's smart contract\n18\n//    to call the function\n19\ncontract CounterRelayContext is GelatoRelayContext {\n20\n    using Address for address payable;\n21\n​\n22\n    uint256 public counter;\n23\n​\n24\n    event IncrementCounter(uint256 newCounterValue);\n25\n​\n26\n    // `increment` is the target function to call.\n27\n    // This function increments a counter variable by 1\n28\n    // IMPORTANT: with `callWithSyncFee` you need to implement \n29\n    // your own smart contract security measures, as this \n30\n    // function can be called by any third party and not only by \n31\n    // Gelato Relay. If not done properly, funds kept in this\n32\n    // smart contract can be stolen.\n33\n    function increment() external onlyGelatoRelay {\n34\n        // Remember to autheticate your call since you are not using ERC-2771\n35\n        // _yourAuthenticationLogic()\n36\n​\n37\n        // Payment to Gelato\n38\n        // NOTE: be very careful here!\n39\n        // if you do not use the onlyGelatoRelay modifier,\n40\n        // anyone could encode themselves as the fee collector\n41\n        // in the low-level data and drain tokens from this contract.\n42\n        _transferRelayFee();\n43\n​\n44\n        counter++;\n45\n​\n46\n        emit IncrementCounter(counter);\n47\n    }\n48\n​\n49\n    // `incrementFeeCapped` is the target function to call.\n50\n    // This function uses `_transferRelayFeeCapped` method to ensure \n51\n    // better control of gas fees. If gas fees are above the maxFee value \n52\n    // the transaction will not be executed.\n53\n    // This function increments a counter variable by 1\n54\n    // IMPORTANT: with `callWithSyncFee` you need to implement \n55\n    // your own smart contract security measures, as this \n56\n    // function can be called by any third party and not only by \n57\n    // Gelato Relay. If not done properly, funds kept in this\n58\n    // smart contract can be stolen.\n59\n    function incrementFeeCapped(uint256 maxFee) external onlyGelatoRelay {\n60\n        // Remember to autheticate your call since you are not using ERC-2771\n61\n        // _yourAuthenticationLogic()\n62\n​\n63\n        // Payment to Gelato\n64\n        // NOTE: be very careful here!\n65\n        // if you do not use the onlyGelatoRelay modifier,\n66\n        // anyone could encode themselves as the fee collector\n67\n        // in the low-level data and drain tokens from this contract.\n68\n       \n69\n          _transferRelayFeeCapped(maxFee);\n70\n​\n71\n        counter++;\n72\n​\n73\n        emit IncrementCounter(counter);\n74\n    }\n75\n}\n2. Import GelatoRelaySDK into your front-end .js project\n1\nimport { GelatoRelay, CallWithSyncFeeRequest } from \"@gelatonetwork/relay-sdk\";\n2\nconst relay = new GelatoRelay();\n3. Send the payload to Gelato\n1\n// set up target address and function signature abi\n2\nconst counter = \"<your counter contract address>\"; \n3\nconst abi = [\"function increment()\"];\n4\n​\n5\n// generate payload using front-end provider such as MetaMask\n6\nconst provider = new ethers.BrowserProvider(window.ethereum);\n7\nconst signer = provider.getSigner();\n8\n​\n9\n// address of the token to pay fees\n10\nconst feeToken = \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\";\n11\n​\n12\n// instantiate the target contract object\n13\nconst contract = new ethers.Contract(counterAddress, abi, signer);\n14\n​\n15\n// example callig the increment() method\n16\nconst { data } = await contract.populateTransaction.increment();\n17\n​\n18\n// populate the relay SDK request body\n19\nconst request: CallWithSyncFeeRequest = {\n20\n  chainId: (await provider.getNetwork()).chainId,\n21\n  target: counter,\n22\n  data: data,\n23\n  feeToken: feeToken,\n24\n  isRelayContext: true,\n25\n};\n26\n  \n27\n// send relayRequest to Gelato Relay API\n28\nconst relayResponse = await relay.callWithSyncFee(request);\n29\n​\n30\n// -----------------------------------------------------------------\n31\n// the following is an alternative example using Gelato Fee Oracle, \n32\n// setting maxFee, and calling the incrementFeeCapped(maxFee) method\n33\n​\n34\n// retrieve the estimate fee from the Gelato \n35\n​\n36\nconst fee = await relay.getEstimatedFee(\n37\n  (await provider.getNetwork()).chainId,\n38\n  feeToken,\n39\n  gasLimit,\n40\n  false,\n41\n)\n42\n​\n43\nconst maxFee = fee * 2 // you can use 2x or 3x to set your maxFee\n44\n​\n45\n// example calling the incrementFeeCapped(maxFee) method\n46\nconst { dataMaxFee } = await contract.incrementFeeCapped.populateTransaction(maxFee);\n47\n​\n48\n// populate the relay SDK request body\n49\nconst requestMaxFee: CallWithSyncFeeRequest = {\n50\n  chainId: (await provider.getNetwork()).chainId,\n51\n  target: counter,\n52\n  data: dataMaxFee,\n53\n  feeToken: feeToken,\n54\n  isRelayContext: true,\n55\n};\n56\n  \n57\n// send relayRequest to Gelato Relay API\n58\nconst relayResponse = await relay.callWithSyncFee(requestMaxFee);\nPrevious\nsponsoredCall\nNext\nRelay Context Contracts\nLast modified 10d ago\nON THIS PAGE\nOverview\nPaying for Transactions\nSetting maxFee for Your Transaction\nSDK method: callWithSyncFee\nSending a Request\nRequest Body\nExample Code GelatoRelayContext\n1. Deploy a GelatoRelayContext compatible contract\n2. Import GelatoRelaySDK into your front-end .js project\n3. Send the payload to Gelato"
  },
  {
    "title": "eth_chainId - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/account-abstraction/bundler-api-endpoints/eth_chainid",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\neth_sendUserOperation\neth_estimateUserOperationGas\neth_getUserOperationByHash\neth_getUserOperationReceipt\neth_supportedEntryPoints\neth_maxPriorityFeePerGas\neth_chainId\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\neth_chainId\nPlease refer to 1Balance & Relay to create a sponsorApiKey.\nPOST\nhttps://api.gelato.digital\n/bundlers/{chainId}/rpc\neth_chainId\n\nReturns the chainId of the network the bundler is serving.\n\nParameters\nPath\nchainId*\nnumber\nTarget network chain identifier.\nQuery\nsponsorApiKey*\nstring\n1Balance API key which covers transaction costs.\nBody\nExample\nSchema\n{​\n  \"id\": 0,​\n  \"jsonrpc\": \"2.0\",​\n  \"method\": \"eth_chainId\"​\n​}\nResponses\n200: OK\nSuccessful response\n400: Bad Request\nValidation error\nPrevious\neth_maxPriorityFeePerGas\nNext - Services\nRelay\nLast modified 1mo ago"
  },
  {
    "title": "sponsoredCall - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/non-erc-2771/sponsoredcall",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n3⃣\nsponsoredCall\n2⃣\ncallWithSyncFee\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n3⃣\nsponsoredCall\nPermissionless sponsored transactions\nAfter reading this page: \nYou'll know how to use theSponsoredCallSDK method. This uses the 1Balance payment method, allowing you to sponsor some/all of your user's gas costs.\nYou'll see some code which will help you send a relay request within minutes.\nPlease proceed to our Security Considerations page and read it thoroughly before advancing with your implementation. It is crucial to understand all potential security risks and measures to mitigate them.\nOverview\nsponsoredCall method utilises authentication via a sponsor API key to sponsor gasless transactions  for your users securely. The payment method is Gelato 1Balance.\nSDK method: sponsoredCall\nconst sponsoredCall = async (\n  request: SponsoredCallRequest,\n  sponsorApiKey: string,\n  options?: RelayRequestOptions\n): Promise<RelayResponse>\nArguments:\nrequest: this is the request body used to send a request.\nsponsorApiKey : an API key used to authenticate your sponsorship. \noptions: RelayRequestOptions is an optional request object.\nReturn Object: RelayResponse\ntype RelayResponse = {\n  taskId: string;\n};\ntaskId: your unique relay task ID which can be used for tracking your request.\nOptional Parameters \nSee Optional Parameters.\nUsing Safe smart contract wallets for sponsoredCall\nIf you need to dispatch transactions from Safe smart contract wallets using Gelato Relay via sponsoredCall, you can opt to activate Safe-enabled transactions in your Relay Dapp configuration.\nAllow sponsored transactions from Safes\nUsually when submitting Gelato Relay transactions that originate from Safe smart contract wallets, the Safe wallet address is specified in the target field of the Relay API request, whereas both the actual target contract address and its calldata are encoded into the execTransaction payload. By activating Safe-enabled transactions - accomplished by checking the \"Allow sponsored transactions from Safes\" box - Gelato Relay will validate your Safe smart contract and decode the target contract address and function selector from the execTransaction calldata. It will then apply your pre-configured Relay Dapp rules to these values, rather than to the values given in the Relay request.\nIf your intention is to deploy Safe smart contract wallets prior to their usage, be sure to whitelist the multicall contract address in your Relay Dapp. This contract is typically invoked when you deploy a Safe smart contract wallet before it can be used for the first time.\nSending a Request\nRequest Body\nconst request = {\n  chainId: BigNumberish;\n  target: string;\n  data: BytesLike;\n};\nchainId: the chain ID of the chain where the target smart contract is deployed.\ntarget: the address of the target smart contract.\ndata: encoded payload data (usually a function selector plus the required arguments) used to call the required target address.\nExample Code\nSince sponsoredCall assumes you have your own security logic built in (i.e. replay and re-entrancy protection), you can go ahead and generate the payload for your function call and populate a request object.\n1. Import GelatoRelaySDK into your front-end .js project\n1\nimport { GelatoRelay, SponsoredCallRequest } from \"@gelatonetwork/relay-sdk\";\n2\nconst relay = new GelatoRelay();\n2. Deploy a smart contract\nThis is an example using Gelato's SimpleCounter.sol which is deployed on Goerli and Polygon.\npragma solidity 0.8.17;\n​\ncontract SimpleCounter {\n    uint256 public counter;\n​\n    event IncrementCounter(uint256 newCounterValue, address msgSender);\n​\n    // `increment` is the target function to call.\n    // This function increments a counter variable by 1\n    // IMPORTANT: with `sponsoredCall` you need to implement \n    // your own smart contract security measures, as this \n    // function can be called by any third party and not only by \n    // Gelato Relay. If not done properly, funds kept in this\n    // smart contract can be stolen.\n    function increment() external {\n        counter++;\n        emit IncrementCounter(counter, msg.sender);\n    }\n}\n3. Generate a payload for your target contract\n// set up target address and function signature abi\nconst counter = \"0x763D37aB388C5cdd2Fb0849d6275802F959fbF30\"; \nconst abi = [\"function increment()\"];\n​\n// generate payload using front-end provider such as MetaMask\nconst provider = new ethers.BrowserProvider(window.ethereum);\nconst signer = provider.getSigner();\n​\nconst contract = new ethers.Contract(counterAddress, abi, signer);\nconst { data } = await contract.increment.populateTransaction();\n4. Send the payload to Gelato\n1\n// Populate a relay request\n2\nconst request: SponsoredCallRequest = {\n3\n  chainId: (await provider.getNetwork()).chainId,\n4\n  target: counter,\n5\n  data: data,\n6\n};\n7\n​\n8\n// Without a specific API key, the relay request will fail! \n9\n// Go to https://relay.gelato.network to get a testnet API key with 1Balance.\n10\n// Send the relay request using Gelato Relay!\n11\nconst relayResponse = await relay.sponsoredCall(request, apiKey);\nPrevious\nNon-ERC-2771\nNext\ncallWithSyncFee\nLast modified 3mo ago\nON THIS PAGE\nOverview\nUsing Safe smart contract wallets for sponsoredCall\nSending a Request\nRequest Body\nExample Code\n1. Import GelatoRelaySDK into your front-end .js project\n2. Deploy a smart contract\n3. Generate a payload for your target contract\n4. Send the payload to Gelato"
  },
  {
    "title": "callWithSyncFeeERC2771 - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/erc-2771-recommended/callwithsyncfeeerc2771",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n1⃣\nsponsoredCallERC2771\n2⃣\ncallWithSyncFeeERC2771\n🍧\nRelay Context Contracts ERC2771\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n2⃣\ncallWithSyncFeeERC2771\nTransactions with on-chain payments and ERC2771 authentication support\nIf you plan to use ERC-2771 with a multicall method or any other method using delegateCall()Please read carefully the section Avoid ERC-2771-risks​\nIf you are using @gelatonetwork/relay-sdk v3 or contracts from the package @gelatonetwork/relay-context v2 please follow this migration guide to migrate to the new versions.\nAfter reading this page: \nYou'll know how to use the callWithSyncFeeERC2771 SDK method, using the syncFee payment method.\nYou'll see some code which will help you send a relay request within minutes.\nYou'll learn how to pay for transactions using the provided values for fee, feeToken and feeCollector.\nPlease proceed to our Security Considerations page and read it thoroughly before advancing with your implementation. It is crucial to understand all potential security risks and measures to mitigate them.\nOverview\nThe callWithSyncFeeERC2771 method uses the syncFee payment method with ERC-2771 support. \nPaying for Transactions\nWhen using callWithSyncFeeERC2771 relay method the target contract assumes responsibility for transferring the fee to Gelato's fee collector during transaction execution. For this, the target contract needs to know:\nfee: the transfer amount\nfeeToken: the token to be transferred\nfeeCollector: the destination address for the fee\nFortunately, Gelato provides some useful tools within the Relay Context Contracts:\n1.\nBy inheriting the GelatoRelayContextERC2771 contract in your target contract, you have the ability to transfer the fee through one of two straightforward methods: _transferRelayFee() or _transferRelayFeeCapped(uint256 maxFee). In either case, the inherited contract takes care of decoding the fee, feeToken, and feeCollector behind the scenes.\nThe Gelato Relay backend simplifies the process by automatically calculating the fee for you, using Gelato's Fee Oracle to perform the calculations in the background.\n2.\nAlternatively, you may choose to inherit the GelatoRelayFeeCollectorERC2771 contract. With this approach, Gelato decodes only the feeCollector. You must provide the fee and feeToken on-chain, either by hardcoding them (which is not recommended) or embedding them within the payload to be executed. The suggested way to handle this is to calculate the fee with Gelato's Fee Oracle.\nThis modular design ensures a smooth integration with Gelato's fee handling mechanisms, providing a flexible and user-friendly approach to managing transaction fees within your dApps.\nSetting maxFee for Your Transaction\nSetting a maximum fee, or maxFee, for your transactions is strongly advised. This practice enables you to ensure that transaction costs remain below a specific limit. The method _transferRelayFeeCapped(uint256 maxFee) in the GelatoRelayContextERC2771 contract provides a convenient way to set the maxFee easily.\nIf you are utilizing the GelatoRelayFeeCollectorERC2771 contract, the recommended way to pass the maxFee is by calculating the fee with Gelato's Fee Oracle, which is accessible in the Relay SDK. The getEstimatedFee() method is provided to facilitate this calculation.\nSDK Methods\n callWithSyncFeeERC2771\nThis method initiates the signing of ERC2771 requests with the provided BrowserProvider or Wallet. Once the signature is obtained, the request is forwarded to Gelato.\nconst callWithSyncFeeERC2771 = async (\n  request: CallWithSyncFeeERC2771Request | CallWithSyncFeeConcurrentERC2771Request,\n  signerOrProvider: ethers.BrowserProvider | ethers.Signer,\n  options?: RelayRequestOptions,\n  apiKey?: string\n): Promise<RelayResponse>\nArguments\nrequest: The body of the request intended for sending.\nsignerOrProvider: a valid provider connected to RPC or a signer.\noptions: an object for specifying optional parameters.\napiKey: an optional API key that links your request to your Gelato Relay account. As this call pertains to the syncFee payment method, transaction costs won't be deducted from your 1Balance account. By using the API key, you can benefit from increased rate limits of your Gelato Relay account.\nResponse\ntype RelayResponse = {\n  taskId: string;\n};\ntaskId: a unique task ID which can be used for tracking your request.\ngetSignatureDataERC2771\nThis method starts the signing process for ERC2771 requests using the given BrowserProvider or Signer. After capturing the signature, it returns both the signature and the message. This collected data can then be used with the callWithSyncFeeERC2771WithSignature method to send the request to Gelato.\ngetSignatureDataERC2771 = (\n  request: CallWithERC2771Request | CallWithConcurrentERC2771Request,\n  signerOrProvider: ethers.BrowserProvider | ethers.Signer,\n  type: ERC2771Type\n): Promise<SignatureData>\nArguments\nrequest: The body of the request intended for sending.\nsignerOrProvider: a valid provider connected to RPC or a signer.\ntype: CallWithSyncFee for a sequential flow or ConcurrentCallWithSyncFee for a concurrent flow. \nResponse\ntype SignatureData = ConcurrentSignatureData \n| SequentialSignatureData;\n​\ntype ConcurrentSignatureData = {\n  struct: CallWithConcurrentERC2771Struct;\n  signature: string;\n};\n​\ntype SequentialSignatureData = {\n  struct: CallWithERC2771Struct;\n  signature: string;\n};\nstruct: EIP-712 message data.\nsignature: EIP-712 signature.\ngetDataToSignERC2771\nThis method provides the message data intended for external signing along with the EIP-712 typed data. After obtaining the signature, the request can be dispatched using the callWithSyncFeeERC2771WithSignature method.\ngetDataToSignERC2771 = (\n  request: CallWithERC2771Request | CallWithConcurrentERC2771Request,\n  type: ERC2771Type,\n  signerOrProvider?: ethers.BrowserProvider | ethers.Signer,\n): Promise<PayloadToSign>\nArguments\nrequest: The body of the request intended for sending.\ntype: CallWithSyncFee for a sequential flow or ConcurrentCallWithSyncFee for a concurrent flow. \nsignerOrProvider (optional): A provider needed in a sequential flow to obtain the nonce from the smart contract. If you're providing the nonce within your request or if you're using the concurrent flow, this parameter isn't necessary.\nResponse\ntype PayloadToSign = ConcurrentPayloadToSign | SequentialPayloadToSign;\n​\ntype ConcurrentPayloadToSign = {\n  struct: CallWithConcurrentERC2771Struct;\n  typedData: CallWithSyncFeeConcurrentERC2771PayloadToSign;\n};\n​\ntype SequentialPayloadToSign = {\n  struct: CallWithERC2771Struct;\n  typedData: CallWithSyncFeeERC2771PayloadToSign;\n};\nstruct: EIP-712 message data.\ntypedData: EIP-712 typed data.\ncallWithSyncFeeERC2771WithSignature\nThis method sends pre-signed requests to Gelato.\nconst callWithSyncFeeERC2771WithSignature = async (\n    struct: CallWithERC2771Struct | CallWithConcurrentERC2771Struct;\n    syncFeeParams: BaseCallWithSyncFeeParams;\n    signature: string;\n    options?: RelayRequestOptions;\n    apiKey?: string\n): Promise<RelayResponse>\nArguments\nstruct: EIP-712 message data returned from the signing methods.\nsyncFeeParams: the feetoken and isRelayContext params.\nsignature: EIP-712 signature returned after signing the request.\noptions: an object for specifying optional parameters.\napiKey: an optional API key that links your request to your Gelato Relay account. As this call pertains to the syncFee payment method, transaction costs won't be deducted from your 1Balance account. By using the API key, you can benefit from increased rate limits of your Gelato Relay account.\nResponse\ntype RelayResponse = {\n  taskId: string;\n};\ntaskId: a unique task ID which can be used for tracking your request.\nOptional Parameters \nSee Optional Parameters. \nSending a Request\nAs of today, we support two distinct ways of sending callWithSyncFeeERC2771 requests:\n1.\nSequentially: This approach ensures that each request is ordered and validated against the nonce stored on-chain. You have two options in this method:\nFetch the current nonce value from the smart contract yourself and include it with your request.\nAllow the relay-sdk to fetch the nonce value for you when handling your relay request.\n2.\nConcurrently: This method enables you to send multiple transactions simultaneously. Replay protection is achieved using a hash-based salt mechanism. Again, you have two options:\nProvide your own salt value.\nAllow the relay-sdk to generate a unique salt value for you when processing your relay request.\nBy default callWithSyncFeeERC2771 requests are using the sequential method.\nConcurrent ERC2771 support has been introduced in the relay-sdk version 5.1.0. Please make sure that your package is up-to-date to start using it.\nRequest Body\ntype SequentialERC2771Request = {\n  chainId: BigNumberish;\n  target: string;\n  data: BytesLike;\n  user: string;\n  userDeadline?: BigNumberish;\n  feeToken: string;\n  isRelayContext?: boolean;\n  isConcurrent?: false;\n  userNonce?: BigNumberish;\n};\ntype ConcurrentERC2771Request = {\n  chainId: BigNumberish;\n  target: string;\n  data: BytesLike;\n  user: string;\n  userDeadline?: BigNumberish;\n  feeToken: string;\n  isRelayContext?: boolean;\n  isConcurrent: true;\n  userSalt?: string;\n};\nCommon Parameters\nchainId: the chain ID of the chain where the target smart contract is deployed.\ntarget: the address of the target smart contract.\ndata: encoded payload data (usually a function selector plus the required arguments) used to call the required target address.\nuser: the address of the user's EOA.\nuserDeadline: optional, the amount of time in seconds that a user is willing for the relay call to be active in the relay backend before it is dismissed.\nThis way the user knows that if the transaction is not sent within a certain timeframe, it will expire. Without this, an adversary could pick up the transaction in the mempool and send it later. This could transfer money, or change state at a point in time which would be highly undesirable to the user.\nfeeToken: the address of the token that is to be used for payment. Please visit SyncFee Payment Tokens for the full list of supported payment tokens per network.\nisRelayContext: an optional boolean (default: true) denoting what data you would prefer appended to the end of the calldata.\nIf set to true (default), Gelato Relay will append the feeCollector address, the feeToken address, and the uint256 fee to the calldata. In this case your target contract should inherit from the GelatoRelayContextERC2771 contract.\nIf set to false, Gelato Relay will only append the feeCollector address to the calldata. In this case your target contract should inherit from the GelatoRelayFeeCollectorERC2771 contract.\nParameters For Sequential Requests:\nisConcurrent: false (default), optional, represents that the users' requests are validated based on a nonce, which enforces them to be processed sequentially.\nuserNonce: optional, this nonce, akin to Ethereum nonces, is stored in a local mapping on the relay contracts. It serves to enforce the nonce ordering of relay calls if the user requires sequential processing. If this parameter is omitted, the relay-sdk will automatically query the current value on-chain.\nParameters For Concurrent Requests:\nisConcurrent: true, indicates that the users' requests are validated based on a unique salt, allowing them to be processed concurrently. Replay protection is still ensured by permitting each salt value to be used only once.\nuserSalt: optional, this is a bytes32 hash that is used for replay protection. If the salt is not provided then relay-sdk would generate a unique value based on a random seed and a timestamp.\nExample Code (using GelatoRelayContextERC2771)\n1. Deploy a GelatoRelayContextERC2771 compatible contract\n1\n// SPDX-License-Identifier: MIT\n2\npragma solidity 0.8.17;\n3\n​\n4\nimport {\n5\n    GelatoRelayContextERC2771\n6\n} from \"@gelatonetwork/relay-context/contracts/GelatoRelayContextERC2771.sol\";\n7\n​\n8\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n9\n​\n10\n// Inheriting GelatoRelayContext gives access to:\n11\n// 1. _getFeeCollector(): returns the address of Gelato's feeCollector\n12\n// 2. _getFeeToken(): returns the address of the fee token\n13\n// 3. _getFee(): returns the fee to pay\n14\n// 4. _transferRelayFee(): transfers the required fee to Gelato's feeCollector.abi\n15\n// 5. _transferRelayFeeCapped(uint256 maxFee): transfers the fee to Gelato\n16\n//    only if fee < maxFee\n17\n// 6. function _getMsgSender(): decodes and returns the user's address from the\n18\n//    calldata, which can be used to refer to user safely instead of msg.sender\n19\n//    (which is Gelato Relay in this case).\n20\n// 7. _getMsgData(): returns the original msg.data without appended information\n21\n// 8. onlyGelatoRelay modifier: allows only Gelato Relay's smart contract\n22\n//    to call the function\n23\ncontract CounterRelayContextERC2771 is GelatoRelayContextERC2771 {\n24\n    using Address for address payable;\n25\n​\n26\n    mapping(address => uint256) public contextCounter;\n27\n​\n28\n    // emitting an event for testing purposes\n29\n    event IncrementCounter(address msgSender);\n30\n​\n31\n    // `increment` is the target function to call.\n32\n    // This function increments a counter variable which is \n33\n    // mapped to every _getMsgSender(), the address of the user.\n34\n    // This way each user off-chain has their own counter \n35\n    // variable on-chain.\n36\n    function increment() external onlyGelatoRelayERC2771 {\n37\n        // Payment to Gelato\n38\n        // NOTE: be very careful here!\n39\n        // if you do not use the onlyGelatoRelay modifier,\n40\n        // anyone could encode themselves as the fee collector\n41\n        // in the low-level data and drain tokens from this contract.\n42\n        _transferRelayFee();\n43\n​\n44\n        // Incrementing the counter mapped to the _getMsgSender()\n45\n        contextCounter[_getMsgSender()]++;\n46\n        \n47\n        emit IncrementCounter(_getMsgSender());\n48\n    }\n49\n    \n50\n    // `incrementFeeCapped` is the target function to call.\n51\n    // This function uses `_transferRelayFeeCapped` method to ensure \n52\n    // better control of gas fees. If gas fees are above the maxFee value \n53\n    // the transaction will not be executed.\n54\n    // The maxFee will be passed as an argument to the contract call.\n55\n    // This function increments a counter variable by 1\n56\n    // IMPORTANT: with `callWithSyncFee` you need to implement \n57\n    // your own smart contract security measures, as this \n58\n    // function can be called by any third party and not only by \n59\n    // Gelato Relay. If not done properly, funds kept in this\n60\n    // smart contract can be stolen.\n61\n    function incrementFeeCapped(uint256 maxFee) external  onlyGelatoRelayERC2771 {\n62\n​\n63\n        // Payment to Gelato\n64\n        // NOTE: be very careful here!\n65\n        // if you do not use the onlyGelatoRelay modifier,\n66\n        // anyone could encode themselves as the fee collector\n67\n        // in the low-level data and drain tokens from this contract.\n68\n  \n69\n        _transferRelayFeeCapped(maxFee);\n70\n​\n71\n        // Incrementing the counter mapped to the _getMsgSender()\n72\n        contextCounter[_getMsgSender()]++;\n73\n​\n74\n        emit IncrementCounter(counter);\n75\n    }\n76\n}\n77\n​\n2. Import GelatoRelaySDK into your front-end .js project\n1\nimport { GelatoRelay, CallWithSyncFeeERC2771Request } from \"@gelatonetwork/relay-sdk\";\n2\nconst relay = new GelatoRelay();\n3. Send the payload to Gelato\n1\n// target contract address\n2\nconst counter = \"<your counter contract address>\";\n3\n​\n4\n// using a human-readable ABI for generating the payload\n5\nconst abi = [\"function increment()\"];\n6\n​\n7\n// address of the token used to pay fees\n8\nconst feeToken = \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\";\n9\n​\n10\n// connect to the blockchain via a front-end provider\n11\nconst provider = new ethers.BrowserProvider(window.ethereum);\n12\nconst signer = provider.getSigner();\n13\nconst user = signer.getAddress();\n14\n​\n15\n// instantiate the target contract object\n16\nconst contract = new ethers.Contract(counter, abi, signer);\n17\n​\n18\n// example calling the increment() method\n19\nconst { data } = await contract.increment.populateTransaction();\n20\n​\n21\n// populate the relay SDK request body\n22\nconst request: CallWithSyncFeeERC2771Request = {\n23\n  chainId: (await provider.getNetwork()).chainId,\n24\n  target: counter,\n25\n  data: data,\n26\n  user: user,\n27\n  feeToken: feeToken,\n28\n  isRelayContext: true,\n29\n};\n30\n  \n31\n// send relayRequest to Gelato Relay API\n32\nconst relayResponse = await relay.callWithSyncFeeERC2771(request, provider);\n33\n​\n34\n// -----------------------------------------------------------------\n35\n// the following is an alternative example using Gelato Fee Oracle, \n36\n// setting maxFee, and calling the incrementFeeCapped(maxFee) method\n37\n​\n38\n// retrieve the estimate fee from Gelato Fee Oracle\n39\nconst fee = await relay.getEstimatedFee(\n40\n  (await provider.getNetwork()).chainId,\n41\n  feeToken,\n42\n  gasLimit,\n43\n  false,\n44\n)\n45\n​\n46\n// you can use 2x or 3x to set your maxFee\n47\nconst maxFee = fee * 2\n48\n​\n49\n// example calling the incrementFeeCapped(maxFee) method\n50\nconst { dataMaxFee } = await contract.incrementFeeCapped.populateTransaction(maxFee);\n51\n​\n52\n// populate the relay SDK request body\n53\nconst requestMaxFee: CallWithSyncFeeERC2771Request = {\n54\n  chainId:  (await provider.getNetwork()).chainId,\n55\n  target: counter,\n56\n  data: dataMaxFee,\n57\n  user: user,\n58\n  feeToken: feeToken,\n59\n  isRelayContext: true,\n60\n};\n61\n  \n62\n// send relayRequest to Gelato Relay API\n63\nconst relayResponseMAxFee = await relay.callWithSyncFeeERC2771(requestMaxFee, provider);\nPrevious\nsponsoredCallERC2771\nNext\nRelay Context Contracts ERC2771\nLast modified 10d ago\nON THIS PAGE\nOverview\nPaying for Transactions\nSetting maxFee for Your Transaction\nSDK Methods\ncallWithSyncFeeERC2771\ngetSignatureDataERC2771\ngetDataToSignERC2771\ncallWithSyncFeeERC2771WithSignature\nOptional Parameters\nSending a Request\nExample Code (using GelatoRelayContextERC2771)\n1. Deploy a GelatoRelayContextERC2771 compatible contract\n2. Import GelatoRelaySDK into your front-end .js project\n3. Send the payload to Gelato"
  },
  {
    "title": "sponsoredCallERC2771 - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/erc-2771-recommended/sponsoredcallerc2771",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n1⃣\nsponsoredCallERC2771\n2⃣\ncallWithSyncFeeERC2771\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n1⃣\nsponsoredCallERC2771\nSponsored transactions with ERC2771 authentication support\n​\nIf you plan to use ERC-2771 with a multicall method or any other method using delegateCall()Please read carefully the section Avoid ERC-2771-risks​\nIf you are using @gelatonetwork/relay-sdk v3 or contracts from the package @gelatonetwork/relay-context v2 please follow this migration guide to migrate to the new versions.\nAfter reading this page: \nYou'll know how to use the sponsoredCallERC2771 SDK method. This will give your user's a gasless UX requiring a user signature. This uses the 1Balance payment method, allowing you to sponsor some/all of your user's gas costs.\nYou'll learn about how to incorporate ERC2771Context into your contract for _msgSender() support.\nYou'll see some code which will help you send a relay request within minutes.\nOverview\n\nThe sponsoredCallERC2771 method uses both a sponsor API key and a user's signature, like that from MetaMask, to securely sponsor gasless transactions. Payments are made via the Gelato 1Balance method.\nGelato Relay SDK has various methods for handling sponsored ERC2771 transactions. The most straightforward is sponsoredCallERC2771, which handles both signing and sending in one step. If you need to separate these processes, other SDK methods are available.\nSDK Methods\nsponsoredCallERC2771\nThis method initiates the signing of ERC2771 requests with the provided BrowserProvider or Wallet. Once the signature is obtained, the request is forwarded to Gelato.\nconst sponsoredCallERC2771 = async (\n  request: CallWithERC2771Request | CallWithConcurrentERC2771Request,\n  signerOrProvider: ethers.BrowserProvider | ethers.Signer,\n  sponsorApiKey: string,\n  options?: RelayRequestOptions\n): Promise<RelayResponse>\nArguments\nrequest: The body of the request intended for sending.\nsignerOrProvider: a valid provider connected to RPC or a signer.\nsponsorApiKey: an API key used to authenticate your sponsorship. \noptions: an object for specifying optional parameters.\nResponse\ntype RelayResponse = {\n  taskId: string;\n};\ntaskId: a unique task ID which can be used for tracking your request.\ngetSignatureDataERC2771\nThis method starts the signing process for ERC2771 requests using the given BrowserProvider or Signer. After capturing the signature, it returns both the signature and the message. This collected data can then be used with the sponsoredCallERC2771WithSignature method to send the request to Gelato.\ngetSignatureDataERC2771 = (\n  request: CallWithERC2771Request | CallWithConcurrentERC2771Request,\n  signerOrProvider: ethers.BrowserProvider | ethers.Signer,\n  type: ERC2771Type\n): Promise<SignatureData>\nArguments\nrequest: this is the request body used to send a request.\nsignerOrProvider: a valid provider connected to RPC or a signer.\ntype: SponsoredCall for a sequential flow or ConcurrentSponsoredCall for a concurrent flow.\nResponse\ntype SignatureData = ConcurrentSignatureData \n| SequentialSignatureData;\n​\ntype ConcurrentSignatureData = {\n  struct: CallWithConcurrentERC2771Struct;\n  signature: string;\n};\n​\ntype SequentialSignatureData = {\n  struct: CallWithERC2771Struct;\n  signature: string;\n};\nstruct: EIP-712 message data.\nsignature: EIP-712 signature.\ngetDataToSignERC2771\nThis method provides the message data intended for external signing along with the EIP-712 typed data. After obtaining the signature, the request can be dispatched using the sponsoredCallERC2771WithSignature method.\ngetDataToSignERC2771 = (\n  request: CallWithERC2771Request | CallWithConcurrentERC2771Request,\n  type: ERC2771Type,\n  signerOrProvider?: ethers.BrowserProvider | ethers.Signer,\n): Promise<PayloadToSign>\nArguments\nrequest: The body of the request intended for sending.\ntype: SponsoredCall for a sequential flow or ConcurrentSponsoredCall for a concurrent flow.\nsignerOrProvider (optional): A provider needed in a sequential flow to obtain the nonce from the smart contract. If you're providing the nonce within your request or if you're using the concurrent flow, this parameter isn't necessary.\nResponse\ntype PayloadToSign = ConcurrentPayloadToSign | SequentialPayloadToSign;\n​\ntype ConcurrentPayloadToSign = {\n  struct: CallWithConcurrentERC2771Struct;\n  typedData: SponsoredCallConcurrentERC2771PayloadToSign \n};\n​\ntype SequentialPayloadToSign = {\n  struct: CallWithERC2771Struct;\n  typedData: SponsoredCallERC2771PayloadToSign\n};\nstruct: EIP-712 message data.\ntypedData: EIP-712 typed data.\nsponsoredCallERC2771WithSignature\nThis method sends pre-signed requests to Gelato.\nsponsoredCallERC2771WithSignature = async (\n  struct: SignatureData[\"struct\"],\n  signature: SignatureData[\"signature\"],\n  sponsorApiKey: string,\n  options?: RelayRequestOptions\n): Promise<RelayResponse>\nArguments\nstruct: EIP-712 message data returned from the signing methods.\nsignature: EIP-712 signature returned after signing the request.\nsponsorApiKey: an API key used to authenticate your sponsorship. \noptions: an object for specifying optional parameters.\nResponse\ntype RelayResponse = {\n  taskId: string;\n};\ntaskId: a unique task ID which can be used for tracking your request.\nOptional Parameters \nSee Optional Parameters.\nSending a Request\nAs of today, we support two distinct ways of sending sponsoredCallERC2771 requests:\n1.\nSequentially: This approach ensures that each request is ordered and validated against the nonce stored on-chain. You have two options in this method:\nFetch the current nonce value from the smart contract yourself and include it with your request.\nAllow the relay-sdk to fetch the nonce value for you when handling your relay request.\n2.\nConcurrently: This method enables you to send multiple transactions simultaneously. Replay protection is achieved using a hash-based salt mechanism. Again, you have two options:\nProvide your own salt value.\nAllow the relay-sdk to generate a unique salt value for you when processing your relay request.\nBy default sponsoredCallERC2771 requests are using the sequential method.\nConcurrent ERC2771 support has been introduced in the relay-sdk version 5.1.0. Please make sure that your package is up-to-date to start using it.\nRequest Body\ntype SequentialERC2771Request = {\n  chainId: BigNumberish;\n  target: string;\n  data: BytesLike;\n  user: string;\n  userDeadline?: BigNumberish;\n  isConcurrent?: false;\n  userNonce?: BigNumberish;\n};\ntype ConcurrentERC2771Request = {\n  chainId: BigNumberish;\n  target: string;\n  data: BytesLike;\n  user: string;\n  userDeadline?: BigNumberish;\n  isConcurrent: true;\n  userSalt?: string\n};\nCommon Parameters:\nchainId: the chain ID of the chain where the target smart contract is deployed.\ntarget: the address of the target smart contract.\ndata: encoded payload data (usually a function selector plus the required arguments) used to call the required target address.\nuser: the address of the user's EOA.\nuserDeadline: optional, the amount of time in seconds that a user is willing for the relay call to be active in the relay backend before it is dismissed.\nThis way the user knows that if the transaction is not sent within a certain timeframe, it will expire. Without this, an adversary could pick up the transaction in the mempool and send it later. This could transfer money, or change state at a point in time which would be highly undesirable to the user.\nParameters For Sequential Requests:\nisConcurrent: false (default), optional, represents that the users' requests are validated based on a nonce, which enforces them to be processed sequentially.\nuserNonce: optional, this nonce, akin to Ethereum nonces, is stored in a local mapping on the relay contracts. It serves to enforce the nonce ordering of relay calls if the user requires sequential processing. If this parameter is omitted, the relay-sdk will automatically query the current value on-chain.\nParameters For Concurrent Requests:\nisConcurrent: true, indicates that the users' requests are validated based on a unique salt, allowing them to be processed concurrently. Replay protection is still ensured by permitting each salt value to be used only once.\nuserSalt: optional, this is a bytes32 hash that is used for replay protection. If the salt is not provided then relay-sdk would generate a unique value based on a random seed and a timestamp.\nExample Code\nFor your testing, Gelato has deployed a simple contract which implements logic to increment a counter with ERC2771 support.\nCounterERC2771.sol: deployed at the address 0x00172f67db60E5fA346e599cdE675f0ca213b47b on these networks.\nCounterERC2771.sol's counter is special because it implements ERC-2771 _msgSender authentication to allow for secure whitelisting based on the identity of the original off-chain relay request originator, which has been verified using a user signature. \nFurthermore, to set your trusted forwarder, you need the address for GelatoRelay1BalanceERC2771.sol that you can find here.\n1. Deploy an ERC2771Context compatible contract \n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n​\nimport {\n    ERC2771Context\n} from \"@gelatonetwork/relay-context/contracts/vendor/ERC2771Context.sol\";\n​\n// Importing ERC2771Context gives access to:\n// 1. An immutable trusted forwarder address\n// 2. function isTrustedForwarder \n//    to verify an input address matches the trustedForwarder address\n// 3. function _msgSender()\n//    which decodes the user's address from the calldata\n//    _msgSender() can now be used to refer to user safely\n//    instead of msg.sender (which is Gelato Relay in this case).\n// 4. function _msgData()\n//    which decodes the function signature from the calldata\ncontract CounterERC2771 is ERC2771Context {\n    // Here we have a mapping that maps a counter to an address\n    mapping(address => uint256) public contextCounter;\n​\n    event IncrementContextCounter(address _msgSender);\n​\n    // ERC2771Context: setting the immutable trustedForwarder variable\n    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {}\n    \n    // `incrementContext` is the target function to call\n    // This function increments a counter variable which is \n    // mapped to every _msgSender(), the address of the user.\n    // This way each user off-chain has their own counter \n    // variable on-chain.\n    function incrementContext() external {\n        // Remember that with the context shift of relaying,\n        // where we would use `msg.sender` before, \n        // this now refers to Gelato Relay's address, \n        // and to find the address of the user, \n        // which has been verified using a signature,\n        // please use _msgSender()!\n​\n        // If this contract was not not called by the \n        // trusted forwarder, _msgSender() will simply return \n        // the value of msg.sender instead.\n        \n        // Incrementing the counter mapped to the _msgSender!\n        contextCounter[_msgSender()]++;\n        \n        // Emitting an event for testing purposes\n        emit IncrementContextCounter(_msgSender());\n    }\n}\n​\n2. Import GelatoRelaySDK into your front-end .js project\n1\nimport { GelatoRelay, SponsoredCallERC2771Request } from \"@gelatonetwork/relay-sdk\";\n2\nconst relay = new GelatoRelay();\n3. Send the payload to Gelato\nThis is an example using Gelato's CounterERC2771.sol which is deployed on these networks.\n// Set up on-chain variables, such as target address\nconst counter = \"0x00172f67db60E5fA346e599cdE675f0ca213b47b\"; \nconst abi = [\"function incrementContext()\"];\nconst provider = new ethers.BrowserProvider(window.ethereum);\nconst signer = provider.getSigner();\nconst user = signer.getAddress();\n​\n// Generate the target payload\nconst contract = new ethers.Contract(counter, abi, signer);\nconst { data } = await contract.incrementContext.populateTransaction();\n​\n// Populate a relay request\nconst request: CallWithERC2771Request = {\n  chainId: (await provider.getNetwork()).chainId,\n  target: counter;\n  data: data;\n  user: user;\n};\n​\n// Without a specific API key, the relay request will fail! \n// Go to https://relay.gelato.network to get a testnet API key with 1Balance.\n// Send a relay request using Gelato Relay!\nconst relayResponse = await relay.sponsoredCallERC2771(request, provider, apiKey);\nPrevious\nERC-2771 (recommended)\nNext\ncallWithSyncFeeERC2771\nLast modified 10d ago\nON THIS PAGE\nOverview\nSDK Methods\nsponsoredCallERC2771\ngetSignatureDataERC2771\ngetDataToSignERC2771\nsponsoredCallERC2771WithSignature\nOptional Parameters\nSending a Request\nExample Code\n1. Deploy an ERC2771Context compatible contract"
  },
  {
    "title": "Join our Discord - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/join-our-discord",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n✍\nJoin our Discord\nJoin the Gelato fam.\nIf you have any feedback or questions,  please join our Discord! 🚀\nPrevious\nERC2771 Migration Guide\nNext - Services\nWeb3 Functions\nLast modified 8mo ago"
  },
  {
    "title": "ERC2771 Migration Guide - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/erc2771-migration-guide",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n⏩\nERC2771 Migration Guide\nHow to migrate to the new Gelato Relay ERC2771 contracts\nThis only applies if you are using @gelatonetwork/relay-sdk v3 or contracts from the package @gelatonetwork/relay-context v2\nGelato Relay ERC2771 proxy contracts are immutable for security reasons. We have deployed new versions of our ERC2771 proxy contracts with enhanced security: GelatoRelayERC2771.sol and GelatoRelay1BalanceERC2771.sol, new addresses of which you can find here.\nTo support these new contracts, Relay Context Contracts found in the package @gelatonetwork/relay-context have been updated to version v3, along with the Gelato Relay SDK package @gelatonetwork/relay-sdk, which has been updated to version v4.\nGelato Relay continues to support ERC2771 contracts that inherit from the legacy @gelatonetwork/relay-context v2, so you can upgrade at your own convenience. Nevertheless we recommend you to upgrade as soon as possible to ensure optimal security, features and support.\nTo illustrate package and contract compatibility please refer to the following matrix:\nGelato Relay ERC2771 Contract\nrelay-sdk\nrelay-context\nLegacy GelatoRelayERC2771.sol: 0xBf175FCC7086b4f9bd59d5EAE8eA67b8f940DE0d\nv3\nv2\nGelatoRelayERC2771.sol: 0xb539068872230f20456CF38EC52EF2f91AF4AE49\nv4\nv3\nGelatoRelay1BalanceERC2771.sol: 0xd8253782c45a12053594b9deB72d8e8aB2Fca54c\nv4\nv3\nPlease note that contract addresses differ on zkSync Era. \nUsing @gelatonetwork/relay-sdk v3 with contracts inheriting from @gelatonetwork/relay-context v3, or using @gelatonetwork/relay-sdk v4 with contracts inheriting from @gelatonetwork/relay-context v2 won't work, as they refer to different Gelato Relay ERC2771 contracts.\nMigration steps\n1.\nIf you deployed contracts that inherit from @gelatonetwork/relay-context - update the package version and either upgrade or redeploy your contracts.\nIf you are using sponsoredCallERC2771 in combination with ERC2771Context.sol - make sure to use the new GelatoRelay1BalanceERC2771.sol contract address as the trustedForwarder which you can find here.\n2.\nIf you are using @gelatonetwork/relay-sdk - update the package version in your project.\n3.\nMake sure you use your newly upgraded/deployed contract addresses with the updated Gelato Relay SDK package.\nIf you cannot upgrade or redeploy your ERC2771-compatible contracts, please contact us to find a future-proof solution together.\nPrevious\nMigration Guide ethers.js v5 to v6\nNext\nJoin our Discord\nLast modified 4mo ago"
  },
  {
    "title": "Migration Guide ethers.js v5 to v6 - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/migration-guide-ethers.js-v5-to-v6",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n⏩\nMigration Guide ethers.js v5 to v6\nHow to migrate your code to ethers.js v6\nWith the @gelatonetwork/relay-sdk version 5, the package uses ethers.js v6. In this guide, we will review the main changes related to the usage of the relay-sdk.\nFor a comprehensive list of changes when migrating from ethers.js v5 to ethers.js v6, please consult the official documentation.\nCreating the calldata: populateTransaction method\nIn all Relay requests, we send the calldata to be forwarded to the target contract. One way of creating this calldata was by invoking the populateTransaction method. The way this is done has changed from ethers v5 to v6:\n\nethers@v5\n// encoding increment method call\nconst contract = new ethers.Contract(counter, abi, signer);\nconst { data } = await contract.populateTransaction.increment();\nethers@v6\n// encoding increment method call\nconst contract = new ethers.Contract(counter, abi, signer);\nconst { data } = await contract.increment.populateTransaction();\nProviders\nWhen instantiating a provider, either on the backend or frontend, you will have to update your code. This is because the package ethers.providers has been moved to ethers. So the change would look like this:\n\nethers@v5\n// Instantiating a JsonRpcProvider\nconst provider =  ethers.providers.JsonRpcProvider()\nethers@v6\n// Instantiating a JsonRpcProvider\nconst provider = new ethers.JsonRpcProvider()\nIn addition to the change mentioned above, the Web3Provider, which was used to instantiate the frontend provider using (window.ethereum), is now called BrowserProvider. So, you'll need to make the following update:\n\nethers@v5\n// Instantiating a Web3Provider\nconst provider =  new ethers.providers.Web3Provider(window.ethereum)\nethers@v6\n// Instantiating a BrowserProvider\nconst provider = new ethers.BrowserProvider(window.ethereum)\nChainId\nWhen querying the chainId from the provider in ethers.js v5, the result was returned as a number. However, in v6, the chainId is returned as a BigInt. If you have code that relies on the chainId being a number, you'll need to update it to handle a BigInt instead.\nHere's a simple example that may help you understand how to adapt your code:\n\nethers@v5\n// ChainId\nconst chainId = (await provider.getNetwork()).chainId;\nconst chainId = 5 // Goerli\nethers@v6\n// ChainId\nconst chainId = (await provider.getNetwork()).chainId;\nconst chainId = 5n // Goerli\nconst chainId = BigInt(5) // Goerli\nExamples\nPlease visit our examples GitHub repository, which showcases the usage of the new @gelatonetwork/relay-sdk v5 implementation for both frontend and backend.\nGitHub - gelatodigital/relay-examples-frontend-backend-v5: Repo showcasing how to call the relay from a React UI as well as from node\nGitHub\nPrevious\nAPI\nNext\nERC2771 Migration Guide\nLast modified 3mo ago\nON THIS PAGE\nCreating the calldata: populateTransaction method\nProviders\nChainId\nExamples"
  },
  {
    "title": "API - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/api",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n📨\nAPI\nHow to communicate directly with the Gelato Relay API\nThe Gelato Relay API endpoint URL is https://api.gelato.digital/\nThe Swagger UI is located at https://api.gelato.digital/api-docs​\n​\nOracle queries\nGET\n/oracles\nGet list of chains where the oracle is available\nGET\n/oracles/{chainId}/estimate\nGet the estimated fee in payment token with respect to the gas limit and priority\nGET\n/oracles/{chainId}/paymentTokens\nGet all the payment tokens on a chain\nGET\n/oracles/{chainId}/conversionRate\nGet the conversion rate from the native token to the requested token\nRelay Endpoints\nInformational \nGET\n/relays/v2\nGet list of chains where relay v2 is available\nSending Relay Requests:\nEach relay request method possesses optional parameters such as the gasLimit , and retries. You can find more information on these on the Optional Parameters page.\n/call-with-sync-fee/: for more information, please click here.\nPOST\n/relays/v2/call-with-sync-fee\nPlace a relay v2 callWithSyncFee request\n/call-with-sync-fee-erc2771/: for more information, please click here.\nPOST\n/relays/v2/call-with-sync-fee-erc2771\nPlace a relay v2 callWithSyncFeeERC2771 request\n/sponsored-call/: for more information, please click here.\nPOST\n/relays/v2/sponsored-call\nPlace a relay v2 sponsoredCall request\n/sponsored-call-erc2771/: for more information, please click here.\nPOST\n/relays/v2/sponsored-call-erc2771\nPlace a relay v2 sponsoredCallERC2771 request\nTask Tracking\nGET\n/tasks/status/{taskId}\nGet task status of the relay v2 task id\nPrevious\nSyncFee Payment Tokens\nNext\nMigration Guide ethers.js v5 to v6\nLast modified 1mo ago\nON THIS PAGE\nOracle queries\nGET\n/oracles\nGET\n/oracles/{chainId}/estimate\nGET\n/oracles/{chainId}/paymentTokens\nGET\n/oracles/{chainId}/conversionRate\nRelay Endpoints\nGET\n/relays/v2\nPOST\n/relays/v2/call-with-sync-fee\nPOST\n/relays/v2/call-with-sync-fee-erc2771\nPOST\n/relays/v2/sponsored-call\nPOST\n/relays/v2/sponsored-call-erc2771\nTask Tracking\nGET\n/tasks/status/{taskId}"
  },
  {
    "title": "Supported Networks - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/supported-networks",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n✅\nSupported Networks\nFind out where you can get started with Relay today!\nPlease note that our support for the Goerli, Optimism Goerli, and Arbitrum Goerli test networks will be discontinued after December 31, 2023. We recommend users to transition their operations to Sepolia, Optimism Sepolia, or Arbitrum Sepolia to ensure uninterrupted service and support.\nGelato Relay is supported on the following networks:\n​Gelato OP Testnet​\n​Gelato OP Celestia Testnet​\n​Astar zKatana Testnet​\n​Tangible Unreal Testnet​\nArbitrum / Arbitrum Goerli / Arbitrum Sepolia\nAvalanche\nBase / Base Goerli\nBNB\nEthereum / Goerli / Sepolia\nGnosis / Chiado\nLinea / Linea Testnet\nOptimism / Optimism Goerli / Optimism Sepolia\nPolygon / Mumbai\nPolygon zkEVM Mainnet / Testnet\nzkSync Era Mainnet / Testnet\nZora Mainnet\nShibarium Mainnet\nFor the most up-to-date information on Relay subscription limits and pricing plans, please visit our dedicated Relay Plans page. Here you can find detailed breakdowns of request monthly limits, throughput limits, autoscale options, and dynamic gas premium fees for each of our supported networks.\n​Check the latest Relay Plans and Rate Limits​\nContract Addresses\nAll supported networks except zkSync Era and Shibarium\nGelatoRelay.sol\nRelay method: callWithSyncFee\nAddress: 0xaBcC9b596420A9E9172FD5938620E265a0f9Df92\nGelatoRelayERC2771.sol\nRelay method: callWithSyncFeeERC2771\nAddress: 0xb539068872230f20456CF38EC52EF2f91AF4AE49\nGelatoRelayConcurrentERC2771.sol\nRelay method: callWithSyncFeeERC2771 with isConcurrent: true\nAddress: 0x8598806401A63Ddf52473F1B3C55bC9E33e2d73b\nGelatoRelay1Balance.sol\nRelay method: sponsoredCall\nAddress: 0x75bA5Af8EFFDCFca32E1e288806d54277D1fde99\nGelatoRelay1BalanceERC2771.sol\nRelay method: sponsoredCallERC2771\nAddress: 0xd8253782c45a12053594b9deB72d8e8aB2Fca54c\nGelatoRelay1BalanceConcurrentERC2771.sol\nRelay method: sponsoredCallERC2771 with isConcurrent: true\nAddress: 0xc65d82ECE367EF06bf2AB791B3f3CF037Dc0e816\nFeeCollector.sol\nAddress: 0x3AC05161b76a35c1c28dC99Aa01BEd7B24cEA3bf\nzkSync Era Mainnet / Testnet\nGelatoRelay.sol\nRelay method: callWithSyncFee\nAddress: 0xB16a1DbE755f992636705fDbb3A8678a657EB3ea\nGelatoRelayERC2771.sol\nRelay method: callWithSyncFeeERC2771\nAddress: 0x22DCC39b2AC376862183dd35A1664798dafC7Da6\nGelatoRelayConcurrentERC2771.sol\nRelay method: callWithSyncFeeERC2771 with isConcurrent: true\nAddress: 0xBa4082F4961c8Fb76231995C967CD9aa40f321b5\nGelatoRelay1Balance.sol\nRelay method: sponsoredCall\nAddress: 0x99a039d4F0e734aA8CcBE74C0FF9780BccD79f1d\nGelatoRelay1BalanceERC2771.sol\nRelay method: sponsoredCallERC2771\nAddress: 0x97015cD4C3d456997DD1C40e2a18c79108FCc412\nGelatoRelay1BalanceConcurrentERC2771.sol\nRelay method: sponsoredCallERC2771 with isConcurrent: true\nAddress: 0xB8828e4c662D1a7e4f3d1f622EfAE6B63D852ED8\nFeeCollector.sol\nAddress: 0x4626c5Bc8640396076D05D9f6D71d07E21BD6aDC\nShibarium Mainnet\nGelatoRelay.sol\nRelay method: callWithSyncFee\nAddress: 0xaBcC9b596420A9E9172FD5938620E265a0f9Df92\nGelatoRelayERC2771.sol\nRelay method: callWithSyncFeeERC2771\nAddress: 0xb539068872230f20456CF38EC52EF2f91AF4AE49\nGelatoRelayConcurrentERC2771.sol\nRelay method: callWithSyncFeeERC2771 with isConcurrent: true\nAddress: 0x8598806401A63Ddf52473F1B3C55bC9E33e2d73b\nGelatoRelay1Balance.sol\nRelay method: sponsoredCall\nAddress: 0x75bA5Af8EFFDCFca32E1e288806d54277D1fde99\nGelatoRelay1BalanceERC2771.sol\nRelay method: sponsoredCallERC2771\nAddress: 0xd8253782c45a12053594b9deB72d8e8aB2Fca54c\nGelatoRelay1BalanceConcurrentERC2771.sol\nRelay method: sponsoredCallERC2771 with isConcurrent: true\nAddress: 0xc65d82ECE367EF06bf2AB791B3f3CF037Dc0e816\nFeeCollector.sol\nAddress: 0x32E1CC9810D6051907004DC310BE2E42df33b199\nPrevious\nTracking your Relay Request\nNext\nSubscriptions and Payments\nLast modified 10d ago\nON THIS PAGE\nContract Addresses\nAll supported networks except zkSync Era and Shibarium\nzkSync Era Mainnet / Testnet\nShibarium Mainnet"
  },
  {
    "title": "Tracking your Relay Request - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/tracking-your-relay-request",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🕵\nTracking your Relay Request\nLearn how to check the status of your relay request\nWhen submitting your Gelato Relay requests, you'll receive a taskId in response. This taskId allows you to track the status of your request in two primary ways:\n1.\nWebsocket Subscriptions: This is the recommended and most efficient method. By subscribing via websocket, the Gelato backend will automatically push updates for all your tasks to your Relay SDK client. To start receiving these updates, you must register a callback function which will be triggered every time one of your tasks gets updated.\n2.\nPolling for Updates: Alternatively, you can periodically query the Gelato task status API for updates. If you're using the Gelato Relay SDK, the getTaskStatus method makes this easy.\nFor both methods, if you aren't using the Gelato Relay SDK package, you can still interact directly with the websocket or REST APIs, as detailed in the documentation linked here.\nWebsocket Subscriptions\nUsing Gelato Relay SDK\nSupport for Websocket Subscriptions was introduced in Gelato Relay SDK version 5.5.0, make sure to update your package.\nYou can subscribe to websocket updates by registering a callback handler function like this:\nimport { GelatoRelay, TransactionStatusResponse } from \"@gelatonetwork/relay-sdk\";\n​\nconst gelatoRelay = new GelatoRelay();\n​\ngelatoRelay.onTaskStatusUpdate((taskStatus: TransactionStatusResponse) => {\n  console.log(\"Task status update\", taskStatus);\n});\n​\nconst request: SponsoredCallRequest = {\n  chainId,\n  target, \n  data,\n};\n​\nconst response = await gelatoRelay.sponsoredCall(\n  request,\n  sponsorApiKey\n);\nUsing websocket API\nYou can interact with the websocket API directly by connecting to this endpoint:\nwss://api.gelato.digital/tasks/ws/status\nOnce connected, you can subscribe to updates using taskIds of your submitted tasks by sending messages like this:\n{\n    action: \"subscribe\",\n    taskId: \"0x...\"\n}\nTo unsubscribe from updates:\n{\n    action: \"unsubscribe\",\n    taskId: \"0x...\"\n}\nPolling for Updates\nUsing Gelato Relay SDK\nTo query the latest task status you can use the following method:\nimport { GelatoRelay } from \"@gelatonetwork/relay-sdk\";\n​\nconst gelatoRelay = new GelatoRelay();\n​\nconst request: SponsoredCallRequest = {\n  chainId,\n  target, \n  data,\n};\n​\nconst response = await gelatoRelay.sponsoredCall(\n  request,\n  sponsorApiKey\n);\n​\nconst taskStatus = await gelatoRelay.getTaskStatus(\n  response.taskId\n);\nQuerying from Gelato API\nhttps://api.gelato.digital/tasks/status/:taskId\nFor example, if your taskId returned from your Relay response is:\n{\n    taskId: 0x93a3defc618ff97c32a37bdd567b15c50748a5c3e8e858bca67f0c967b74a7fe\n}\nthen the URL to go to is:\nhttps://api.gelato.digital/tasks/status/0x93a3defc618ff97c32a37bdd567b15c50748a5c3e8e858bca67f0c967b74a7fe\nFor this taskId, here is the returned task information:\n{\n    \"task\": {\n        \"chainId\": 5,\n        \"taskId\": \"0x93a3defc618ff97c32a37bdd567b15c50748a5c3e8e858bca67f0c967b74a7fe\",\n        \"taskState\": \"ExecSuccess\",\n        \"creationDate\": \"2022-10-10T10:15:03.932Z\",\n        \"executionDate\": \"2022-10-10T10:15:28.718Z\",\n        \"transactionHash\": \"0x9d260d1bbe075be0cda52a3271df062748f3182ede91b3aae5cd115f7b26552b\",\n        \"blockNumber\": 7744557\n    }\n}\nTask Status Response\nThe task status response object has the following format:\ntype TransactionStatusResponse = {\n  chainId: number;\n  taskId: string;\n  taskState: TaskState;\n  creationDate: string;\n  lastCheckDate?: string;\n  lastCheckMessage?: string;\n  transactionHash?: string;\n  blockNumber?: number;\n  executionDate?: string;\n  gasUsed?: string;\n  effectiveGasPrice?: string;\n};\n​\nenum TaskState {\n  CheckPending = \"CheckPending\",\n  ExecPending = \"ExecPending\",\n  WaitingForConfirmation = \"WaitingForConfirmation\",\n  ExecSuccess = \"ExecSuccess\",\n  ExecReverted = \"ExecReverted\",\n  Cancelled = \"Cancelled\",\n}\nTask states\nFor the taskState key, these are the possible values:\nCheckPending: the relay request has been received by Gelato Relay (pending simulation).\nExecPending: the relay task is executable and is awaiting inclusion into the blockchain.\nWaitingForConfirmation: the task was included into the blockchain but is still awaiting the required amount of blocks confirmations.\nExecSuccess: the task has been successfully executed.\nCancelled: the task has been cancelled due to failed simulations or other errors. The error message will be shown in the lastCheckMessage key.\nExecReverted: the task transaction has been reverted.\nWhat if my task is cancelled?\nIf your task is cancelled, you can find your error message under the lastCheckMessage key, for example:\n{\n    \"task\": {\n        \"chainId\": 56,\n        \"taskId\": \"0x5f0200652404f9f113a757b4208984f7f4ca25754ddd5c49ca28330e72160c12\",\n        \"taskState\": \"Cancelled\",\n        \"creationDate\": \"2023-03-03T14:01:14.327Z\",\n        \"lastCheckDate\": \"2023-03-03T14:01:44.128Z\",\n        \"lastCheckMessage\": \"Execution error: GelatoRelay.sponsoredCall:root already sent\"\n    }\n}\nThe error message in this case refers to the target contract reverting with the message \"root already sent\" when being called by Gelato Relay's sponsoredCall function. If you get something similar and you are stuck on troubleshooting, please get in touch with us via Discord and ask in the relay channel! We will be sure to figure out what's going on.\nPrevious\nOptional Parameters\nNext\nSupported Networks\nLast modified 2mo ago\nON THIS PAGE\nWebsocket Subscriptions\nUsing Gelato Relay SDK\nUsing websocket API\nPolling for Updates\nUsing Gelato Relay SDK\nQuerying from Gelato API\nTask Status Response\nTask states\nWhat if my task is cancelled?"
  },
  {
    "title": "Optional Parameters - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/optional-parameters",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n❔\nOptional Parameters\nWhat other options do you have?\nAll four main Relay SDK methods use the same optional parameters.\nOptional Parameters\nrelayRequestOptions is a type with the following properties:\ntype RelayRequestOptions = {\n  gasLimit?: BigNumberish;\n  retries?: number;\n};\ngasLimit: the gas limit of the relay call. This effectively sets an upper price limit for the relay call.\nIf you are using your own custom gas limit, please add a 150k gas buffer on top of the expected gas usage for the transaction. This is for the Gelato Relay execution overhead, and adding this buffer reduces your chance of the task cancelling before it is executed on-chain.\nIf your contract has any hardcoded requirements about gas usage, please always explicitly pass the gasLimit to the SDK/API, as Gelato will not know what hardcoded gas expectations your contract has. Otherwise, your relay requests might not be executable.\nretries: the number of retries that Gelato should attempt before discarding this relay call. This can be useful if the state of the target contract is not fully known and such reverts can not be definitively avoided. \nPrevious\nGelato's Fee Oracle\nNext\nTracking your Relay Request\nLast modified 1mo ago"
  },
  {
    "title": "Gelato's Fee Oracle - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/gelatos-fee-oracle",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n💰\nGelato's Fee Oracle\nHow to get a quote for your relay fee before sending the request\nAfter reading this page: \nYou'll understand how to query the fee oracle using either the SDK or the API directly and which methods/endpoints are available.\nYou'll learn the difference between different fee modalities and trade offs: for example, allowing your user to sign off on a maximum fee they are willing to pay helping account for gas volatility, or allowing them to sign off on the exact fee but with a higher risk of non-execution.\nYou can query our fee oracle before the relay request to get an overall estimated fee (gas costs + Gelato fee) for your relay request.\nQuerying via the SDK\nSDK method: isOracleActive\nconst isOracleActive = async (chainId: bigint): Promise<boolean>\nArguments:\nchainId: the chain ID of the network on which to check if the fee oracle is active.\nReturn Object:\ntrue/false: depending on the status of the fee oracle on the requested network.\nSDK method: getPaymentTokens\nconst getPaymentTokens = async (chainId: bigint): Promise<string[]>\nArguments:\nchainId: the chain ID of the network where you want to check if the fee oracle is active there.\nReturn Object:\nAn array of strings listing all accepted payment tokens on the requested network.\nSDK method: getEstimatedFee\ngetEstimatedFee = (\n  chainId: bigint,\n  paymentToken: string,\n  gasLimit: bigint,\n  isHighPriority: boolean,\n  gasLimitL1?: bigint\n): Promise<bigint>\nArguments:\nchainId: the chain ID of the network where you want to check if the fee oracle is active there.\npaymentToken: the address of the token you would like to pay in.\ngasLimit: a custom gas limit for your transaction, please remember to add an overhead for Gelato Relay's contract calls and security checks, see here for more info.\nisHighPriority: EIP-1559 flag for increasing your priority gas fee. If true, you will incur higher costs but have a higher certainty of block inclusion.\ngasLimitL1: gas limit for the L1 data fee which is required to properly estimate fees on OP Stack chains, e.g. Optimism, Base, Zora. Can be omitted on all other chains.\nReturn Object\nThe value of your estimated fee, including gas costs + gelato fee on top. \nNOTE:  please be aware that if your relayed transaction incurs gas refunds, for example, for clearing out storage slots, this is not known beforehand. These refunds can only be known after the fact, from the transaction receipts. This means that the fee oracle will give you a price which does not include the gas refunds, so it may be higher than you think. This is due to how the EVM works, and the initial gas allocated for execution should still be the total amount before refunds, otherwise you will get an 'Out of gas' error. See here for more info.\nQuerying via the API\nPlease see the available endpoints on the API page.\n​\nPrevious\nRelay Context Contracts\nNext\nOptional Parameters\nLast modified 15d ago\nON THIS PAGE\nQuerying via the SDK\nSDK method: isOracleActive\nSDK method: getPaymentTokens\nSDK method: getEstimatedFee\nQuerying via the API"
  },
  {
    "title": "Non-ERC-2771 - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/non-erc-2771",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n3⃣\nsponsoredCall\n2⃣\ncallWithSyncFee\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🔧\nNon-ERC-2771\nPermissionless meta-transactions\nPlease proceed to our Security Considerations page and read it thoroughly before advancing with your implementation. It is crucial to understand all potential security risks and measures to mitigate them.\nIf you're not using ERC-2771, your users might have smart contract wallets, in which case you should have a look at Account Abstraction.\nGelato Relay offers two methods that don't implement ERC2771 signature verification:\n​sponsoredCall where gas fees are sponsored by a 1Balance account.\n​callWithSyncFee, where the target contract transfers gas fees using Relay Context Contracts.\nPlease exercise utmost caution when using the Gelato Relay without implementing ERC-2771 for authentication/authorization.\nWe highly recommend cross-checking with us on Discord if you believe your setup doesn't require the ERC-2771 user verification. We can help confirm whether your implementation is sufficiently secure.\nThere are specific use cases where the Gelato ERC-2771 implementation may not be necessary:\n1.\nIf your application or protocol already implements user signature/verification and has authentication/authorization mechanisms in place.\n2.\nApplications like Gnosis Safe multisigs, where a non-ERC2771 compliant signature mechanism is already established.\n3.\nIf your application does not require any access control and does not involve any fund transfers.\nPrevious\nRelay Context Contracts ERC2771\nNext\nsponsoredCall\nLast modified 4mo ago"
  },
  {
    "title": "ERC-2771 (recommended) - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/erc-2771-recommended",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n1⃣\nsponsoredCallERC2771\n2⃣\ncallWithSyncFeeERC2771\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🔏\nERC-2771 (recommended)\nNative meta transactions with top notch security\nIf you plan to use ERC-2771 with a multicall method or any other method using delegateCall()Please read carefully the section Avoid ERC-2771-risks​\nIf you are using @gelatonetwork/relay-sdk v3 or contracts from the package @gelatonetwork/relay-context v2 please follow this migration guide to migrate to the new versions.\nAfter reading this page: \nYou'll understand the difference between sponsoredCallERC2771and callWithSyncFeeERC2771​\nYou'll understand how to use sponsoredCallERC2771 and callWithSyncFeeERC2771 in combination with ERC2771Context to achieve a gasless UX for your app, with secure user signature verification.\nYou'll understand ERC-2771's core functionality and how it allows for the off-chain sender address to be verified on-chain.\nRecommendation for using ERC-2771  \nAs detailed in the Security Considerations section, it's crucial to ensure that your relay implementation is impervious to vulnerabilities when using a relayer. The most secure approach is to utilize our ERC-2771 implementations: \n​sponsoredCallERC2771​\n​callWithSyncFeeERC2771​\nWhen using sponsoredCallERC2771, you sponsor your user's gas fees, leveraging 1Balance for payment. In contrast, with callWithSyncFeeERC2771, the fees are paid from the target contract.\nIn both instances, users are prompted to sign their transaction's relay request using their private keys (for instance, through MetaMask). This step is crucial for security purposes. Gelato verifies on-chain that the user's signature corresponds with the required address before forwarding the call.\nWhen relaying a message to a target smart contract function, it's essential for the function to authenticate the message's origin and confirm it was forwarded through the correct relayer. Without these verifications, your target function becomes susceptible to exploitation. ERC-2771 employs sophisticated data encoding to relay the original _msgSender from off-chain, and it guarantees that only the trustedForwarder is capable of encoding this value. These two parameters, in tandem, safeguard against any potential misconduct, ensuring a secure transmission of information from off-chain to on-chain!\nWhy is this important?\nIn the context of relaying, msg.sender loses its usual informational significance. Under normal circumstances, msg.sender would denote the user initiating the transaction; however, with off-chain relaying, we lose this valuable piece of information.\nConsider this scenario: how does a target smart contract determine who can call a particular function? In this case, msg.sender will be the relayer, but merely whitelisting this address is insufficient and still permits others using the same relayer to call your function. This situation can raise significant concerns, particularly when low-level calls are involved.\nThe optimal solution would be to allow the initiator of the relay call to specify an address and relay this address on-chain. The target smart contract can then authenticate a function call using this address.\nThe challenge then becomes: how can we successfully transmit information (a specific address) via low-level calldata from off-chain to on-chain without disrupting the calldata's integrity?\nCore Functionality of ERC-2771\nHere's where the real magic unfolds. The trustedForwarder encodes the from address (i.e., the off-chain address) into the calldata by appending it at the end:\n1\n(bool success, ) = to.call.value(value)(abi.encodePacked(data, from));\nNow, the target contract can validate the from address by decoding the data in the same manner, ensuring that this message has been passed through the trustedForwarder.\nThe necessary target contract function can then confidently confirm that the correct entity signed and requested this payload to be relayed, and only via a trusted forwarder - in our case, the Gelato Relay.\nHow does Gelato encode this data?\nLet's take as an example relay method sponsoredCallERC2771. Method callWithSyncFeeERC2771 works similarly.\nGelato Relay's sponsoredCallERC2771 function encodes the user's address, which can then be utilized by the ERC-2771 compatible target smart contract.  The most relevant part, where the user address is appended to the calldata, is shown below:\nGelatoRelay1BalanceERC2771.sol\n1\n_call.target.revertingContractCall(\n2\n    _encodeERC2771Context(_call.data, _call.user),\n3\n    \"GelatoRelay1BalanceERC2771.sponsoredCallERC2771:\"\n4\n);\nwhere _encodeERC2771Context refers to:\nGelatoRelayUtils.sol\n1\nfunction _encodeERC2771Context(bytes calldata _data, address _msgSender)\n2\n    pure\n3\n    returns (bytes memory)\n4\n{\n5\n    return abi.encodePacked(_data, _msgSender);\n6\n}\nWe are encoding the calldata and the user address together by simply appending the user's address to the end as required by ERC-2771.\nHow can I modify my smart contract to be ERC-2771 compatible?\nLet's take a look at an example using relay method sponsoredCallERC2771. For callWithSyncFeeERC2771 please refer to the steps described here.\n1. Install Gelato's relay-context package in your contract repo\nSee also relay-context-contracts: Installation​\nnpm install --save-dev @gelatonetwork/relay-context\nor\nyarn add -D @gelatonetwork/relay-context\n2. Import the ERC2771Context contract:\n1\nimport {\n2\n    ERC2771Context\n3\n} from \"@gelatonetwork/relay-context/contracts/vendor/ERC2771Context.sol\";\nThis contract's main functionality (originally implemented by OpenZeppelin) is to decode the off-chain msg.sender from the encoded calldata using _msgSender() . \nERC2771Context.sol\n1\n// SPDX-License-Identifier: MIT\n2\n// OpenZeppelin Contracts (last updated v4.7.0) (metatx/ERC2771Context.sol)\n3\n​\n4\npragma solidity ^0.8.9;\n5\n​\n6\nimport \"../utils/Context.sol\";\n7\n​\n8\n/**\n9\n * @dev Context variant with ERC2771 support.\n10\n */\n11\nabstract contract ERC2771Context is Context {\n12\n    address private immutable _trustedForwarder;\n13\n    \n14\n    constructor(address trustedForwarder) {\n15\n        _trustedForwarder = trustedForwarder;\n16\n    }\n17\n​\n18\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n19\n        return forwarder == _trustedForwarder;\n20\n    }\n21\n​\n22\n    function _msgSender() internal view virtual override returns (address sender) {\n23\n        if (isTrustedForwarder(msg.sender)) {\n24\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n25\n            /// @solidity memory-safe-assembly\n26\n            assembly {\n27\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n28\n            }\n29\n        } else {\n30\n            return super._msgSender();\n31\n        }\n32\n    }\n33\n​\n34\n    function _msgData() internal view virtual override returns (bytes calldata) {\n35\n        if (isTrustedForwarder(msg.sender)) {\n36\n            return msg.data[:msg.data.length - 20];\n37\n        } else {\n38\n            return super._msgData();\n39\n        }\n40\n    }\n41\n}\nThe trustedForwarder variable is set in the constructor which allows for setting a trusted party that will relay your message to your target smart contract. In our case, this is Gelato Relay1BalanceERC2771.sol which you can find in the contract addresses section.\nThe _msgSender() function encapsulates the main functionality of ERC-2771, by decoding the user address from the last 20 bytes of the calldata. \nIn Solidity, the logic is equivalent to:\n1\nabi.decode(\n2\n    msg.data[msg.data.length - 20:],\n3\n    (address)\n4\n);\nGelato's smart contracts handle the encoding of important information to the calldata (see How does Gelato encode this data?). It is the job of your target smart contract function to decode this information using this _msgSender() function. \nThe function  _msgData() removes the msg.sender from the entire calldata if the contract was called by the trustedForwarder, or otherwise falls back to return the original calldata.\n3. Replace msg.sender with _msgSender()\nWithin the function that you would like to be called with Gelato Relay, replace all instances of msg.sender with a call to the _msgSender() function inherited from ERC2771Context. _msgSender() is the off-chain signer of the relay request, allowing for secure whitelisting on your target function. \n4. (Re)deploy your contract and whitelist GelatoRelay1BalanceERC2771\nIf your contract is not upgradeable, then you will have to redeploy your contract to set GelatoRelay1BalanceERC2771.sol as your trustedForwarder:\nGelatoRelay1BalanceERC2771.solis immutable for security reasons. This means that once you set GelatoRelay1BalanceERC2771.sol as your trusted forwarder, there is no way for Gelato to change the ERC2771 signature verification scheme and so you can be sure that the intended _msgSender is correct and accessible from within your target contract.\nPlease refer to the contract addresses section to find out which Gelato relay address to use as a trustedForwarder. Use GelatoRelay1BalanceERC2771.sol address for sponsoredCallERC2771.\nPrevious\nQuick Start\nNext\nsponsoredCallERC2771\nLast modified 10d ago\nON THIS PAGE\nRecommendation for using ERC-2771\nWhy is this important?\nCore Functionality of ERC-2771\nHow does Gelato encode this data?\nHow can I modify my smart contract to be ERC-2771 compatible?\n1. Install Gelato's relay-context package in your contract repo\n2. Import the ERC2771Context contract:\n3. Replace msg.sender with _msgSender()\n4. (Re)deploy your contract and whitelist GelatoRelay1BalanceERC2771"
  },
  {
    "title": "Quick Start - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/quick-start",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🌠\nQuick Start\nGelato Relay, as easy as 0xabc...\nPlease see here for supported networks and contract addresses.\nAfter reading this page:\nYou'll go through a decision process to understand the best way to integrate with Gelato Relay.\nYou'll know exactly which SDK/API method is for you.\nDepending on your final destination, please click the corresponding link to find about your chosen SDK method:\n​sponsoredCallERC2771​\n​callWithSyncFeeERC2771​\n​sponsoredCall​\n​callWithSyncFee​\nOption 1: Your users pay for for their own gas\nIf you do not want to sponsor your user's gas, you will use the callWithSyncFeeERC2771 or callWithSyncFee SDK method with the SyncFee payment method. This will require you to deploy a new contract (or upgrade if you can) to be compatible with Gelato's relay context contracts.\nOption 2: Sponsoring some/all of your users' gas\nSponsoring some of your user's gas:\nGelato Relay allows for partial sponsoring of gas based on certain conditions with developer-defined rules! For example, an app could sponsor user's gas based on a certain NFT being present in their wallet, or perhaps the NFT allows the user to have 10 gasless transactions a day. As a sponsor, you will able to customize with Gelato Relay's sponsor dashboard, coming soon™.\nSponsoring all of your user's gas: \nGelato handles user signature verification: go ahead and use sponsoredCallERC2771 where Gelato handles user signature verification for you. In this method, you can use ERC-2771's _msgSender() to validate your relay calls on-chain. This will require an upgrade to your target contract for ERC2771Context support, if it does not support it already.\nYou handle user signature verification: If your app workflow already handles its security in-house (i.e. use of user signatures, replay/reentrancy protection etc.) and you do want to sponsor all of your user's gas, you are ready to use Gelato Relay without any change to your existing smart contract logic. This will be using the sponsoredCall method.\nPrevious\nTemplates\nNext\nERC-2771 (recommended)\nLast modified 4mo ago\nON THIS PAGE\nOption 1: Your users pay for for their own gas\nOption 2: Sponsoring some/all of your users' gas"
  },
  {
    "title": "Templates - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/templates",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n📜\nTemplates\nGet started with Gelato Relay in seconds\nFoundry Template\nGitHub - gelatodigital/gelato-relay-foundry-template\nGitHub\nHardhat Template\nGitHub - gelatodigital/relay-example-unit-tests: Relay Examples with Unit tests\nGitHub\nPrevious\nInstallation\nNext\nQuick Start\nLast modified 1mo ago\nON THIS PAGE\nFoundry Template\nHardhat Template"
  },
  {
    "title": "Installation - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/installation",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🚀\nInstallation\nNow we're cooking with gas...\n@gelatonetwork/relay-sdk package v5 and above is using ethers v6. If you are using @gelatonetwork/relay-sdk v4 or below, please follow this migration guide to migrate from ethers v5 to v6.\n\nIf you are using @gelatonetwork/relay-sdk v3 or contracts from the package @gelatonetwork/relay-context v2 please follow the ERC2771 Migration guide to migrate to the new versions.\nRelay-SDK\nnpm: @gelatonetwork/relay-sdk\nnpm\nNote: please make sure to use version v4.0.0 and above.\nnpm install @gelatonetwork/relay-sdk\nor\nyarn add @gelatonetwork/relay-sdk\nPrevious\nERC-2771 Delegatecall Vulnerability\nNext\nTemplates\nLast modified 4mo ago"
  },
  {
    "title": "Security Considerations - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/security-considerations",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n⚠\nERC-2771 Delegatecall Vulnerability\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n🔒\nSecurity Considerations\nEssential reading to safeguard your contracts\nAfter reading this page:\nYou will understand the security risks associated with using a Relayer.\nYou will learn strategies for safeguarding your contracts effectively.\nYou will be exposed to an example of a contract that is susceptible to exploitation.\nPotential Security Risk in Relayer Authentication\nA relayer is responsible for dispatching a transaction to an external or public contract method. Given the public nature of this method, it is accessible for invocation by any third party. So, how can we ascertain the legitimacy of the party executing this method?\nIn certain implementations, we have observed an approach that utilizes a mechanism to ensure that solely the Gelato Relay is authorized to call the contract. This mechanism employs a modifier, known as onlyGelatoRelay. This modifier verifies that the transaction's msg.sender is the GelatoRelay contract. However, it's crucial to note that this form of validation does not offer protection from potential malevolent third parties leveraging the relayer to compromise your contract.\n🚨 Additional authentication is required to safeguard your contracts!\nTo ensure robust security for your contracts, additional layers of authentication are indispensable. We urge you to adhere to our tried and tested security best practices. These guidelines have been designed to efficiently manage and mitigate security risks. Let's dive in!\n✅  Battle Tested Best Practice\nThe most prevalent method to authenticate users within the web3 ecosystem relies on the ERC-2771 standard and EIP-712 signature. Gelato offers convenient helper contracts that facilitate the verification and decoding of the user's signature, thereby ensuring that the user initiating the transaction is indeed legitimate.\nGelato's SDK provides two methods that implement the ERC-2771 standard behind the scenes:\n1.\nsponsoredCallERC2771\n2.\ncallWithSyncFeeERC2771\nIn both instances, Gelato offers built-in methods to decode the msg.sender and msg.data, substituting these with _msgSender() and _msgData(), respectively.\nWe strongly advocate for the use of Gelato's built-in ERC-2771 user signature verification contracts, coupled with the onlyGelatoRelay modifier. This combination offers a robust level of security and helps safeguard your contracts against potential threats.\nAddressing the Risk of Relayer Fee Payment\nGelato Relayer can be used in various ways. Among these, two specific methods exist: callWithSyncFeeERC2771 and callWithSyncFee. In these, the target contract is responsible for transferring the fees to the feeCollector.\nGelato provides Relay Context Contracts, which include helper methods that simplify the extraction process for feeCollector, fee, and feeToken. The fees are transferred by invoking the _transferRelayFee() method.\n// DANGER! Only use with onlyGelatoRelay or `_isGelatoRelay` before transferring\nfunction _transferRelayFee() internal {\n    _getFeeToken().transfer(_getFeeCollector(), _getFee());\n}\nThe following code sample illustrates how feeCollector is extracted from the callData:\nuint256 constant _FEE_COLLECTOR_START = 72; // offset: address + address + uint256\n​\n// WARNING: Do not use this free fn by itself, always inherit GelatoRelayContext\n// solhint-disable-next-line func-visibility, private-vars-leading-underscore\nfunction _getFeeCollectorRelayContext() pure returns (address feeCollector) {\n    assembly {\n        feeCollector := shr(\n            96,\n            calldataload(sub(calldatasize(), _FEE_COLLECTOR_START))\n        )\n    }\n}\nThis snippet lacks a built-in security check or protective measure; it simply extracts the feeCollector from the callData. \n🚨 Without additional safeguards, this implementation is susceptible to Miner Extractable Value (MEV) front running. \nTherefore, any external actor could potentially call the target contract and encode their addresses as feeCollector.\nGiven these risks, it is absolutely essential to implement the following security best practices. 👇🏻\n✅  Battle Tested Best Practice\nAlongside implementing the Relay Context Contracts, it's crucial to verify that the msg.sender of the transaction is the GelatoRelay address before executing fee transfers.\n// Using onlyGelatoRelay modifier\nfunction targetMethod() external onlyGelatoRelay {\n    ...\n    // If you are not using ERC-2771 remember to authenticate all \n    // on-chain relay calls to your contract's methods even if you \n    // identify GelatoRelay as the msg.sender\n    // The following pseudocode signifies an authentication procedure\n    _yourAuthenticationLogic();\n​\n    // Payment to Gelato\n    _transferRelayFee();\n    ...\n}\n​\n// Or alternatively using _isGelatoRelay(address _forwarder) method\nfunction targetMethod() external {\n    ...\n    // If you are not using ERC-2771 remember to authenticate all \n    // on-chain relay calls to your contract's methods even if you \n    // identify GelatoRelay as the msg.sender\n    // The following pseudocode signifies an authentication procedure\n    _yourAuthenticationLogic();\n        \n    if (_isGelatoRelay(msg.sender)) {\n        // Payment to Gelato\n        _transferRelayFee();\n    }\n    ...\n}\n✅ Additional Security Layer\nThe aforementioned best practice ensures protection from front-running and unauthorized third-party fund drains. However, if your use case demands heightened control over the fees, you can further minimize risk by introducing a maxFee into your function using the method _transferRelayFeeCapped(uint256 maxFee).\n// Using onlyGelatoRelay modifier\nfunction targetMethod() external onlyGelatoRelay {\n    ...\n    // If you are not using ERC-2771 remember to authenticate all \n    // on-chain relay calls to your contract's methods even if you \n    // identify GelatoRelay as the msg.sender\n    // The following pseudocode signifies an authentication procedure\n    _yourAuthenticationLogic();\n​\n    // Payment to Gelato\n    _transferRelayFeeCapped(maxFee);\n    ...\n}\n​\n// Or alternatively using _isGelatoRelay(address _forwarder) method\nfunction targetMethod() external {\n    ...\n    // If you are not using ERC-2771 remember to authenticate all \n    // on-chain relay calls to your contract's methods even if you \n    // identify GelatoRelay as the msg.sender\n    // The following pseudocode signifies an authentication procedure\n    _yourAuthenticationLogic();\n        \n    if (_isGelatoRelay(msg.sender)) {\n        // Payment to Gelato\n        _transferRelayFeeCapped(maxFee);\n    }\n    ...\n}\nFor more detailed information on utilizing _transferRelayFeeCapped(uint256 maxFee), please consult our comprehensive guide here.\nExample of a Poor and Insecure Implementation\nThe VeryDummyWallet in the following example gives the impression of being a well-constructed implementation of the Gelato Relay, since it:\nInherits the GelatoRelayContext\nImplements the onlyGelatoRelay modifier\nTransfers the fees using the built-in method _transferRelayFee()\nHowever, this contract has a critical flaw: any user can create a request by calling the Gelato Relay and passing any \"to\" address to the sendToFriend() method. This contract does not implement any form of user authentication or authorization, making it susceptible to exploitation.\n \n🚨🚨🚨 WARNING: THIS IS A BAD EXAMPLE. DO NOT REPLICATE 🚨🚨🚨\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n​\nimport {\n    GelatoRelayContext\n} from \"@gelatonetwork/relay-context/contracts/GelatoRelayContext.sol\";\n​\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n​\ncontract VeryDummyWallet is GelatoRelayContext {\n    // `sendToFriend` is the target function to call\n    // this function uses this contract's mock ERC-20 balance to send\n    // an _amount of tokens to the _to address.\n    function sendToFriend(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) external onlyGelatoRelay {\n        // payment to Gelato\n        _transferRelayFee();\n​\n        // transfer of ERC-20 tokens\n        SafeERC20.safeTransfer(IERC20(_token), _to, _amount);\n    }\n}\n​\n​\nPrevious\nWhat is Relaying?\nNext\nERC-2771 Delegatecall Vulnerability\nLast modified 1mo ago\nON THIS PAGE\nPotential Security Risk in Relayer Authentication\nAddressing the Risk of Relayer Fee Payment\nExample of a Poor and Insecure Implementation"
  },
  {
    "title": "What is Relaying? - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/what-is-relaying",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n📨\nWhat is Relaying?\nUnderstanding the benefits of relaying and how it can help your dApp thrive\nAfter reading this page: \nYou'll understand the context shift between standard transactions and relayed transactions.\nYou'll know the ways relaying can help improve UX.\nYou'll know exactly why Gelato Relay is the relayer you should integrate with.\nYou'll know what meta transactions are and how EIP-712 signatures work.\nPlease visit our page Security Considerations and read carefully before moving forward.\nStandard transactions\nIn a standard Ethereum transaction, an ethereum user signs and sends the transaction themselves. This user controls the private key to an externally owned account (EOA) which they can use to sign   a transaction and prove they have the right to spend the balance associated with that account address. \nFor each transaction a user sends, there is an associated transaction fee, known as gas. Since Ethereum executes computation, each unit of computation has an associated gas cost, which deters malicious actors from overloading the network by requiring them to pay heavily for a potential attack. This is excellent news for Ethereum's security and helps keep the network consistent under load, but it comes at a hidden cost for onboarding new users.\nOnboarding issues\nHow does a new user start interacting with exciting on-chain applications like DeFi, NFTs, or gaming? They will always need the native token to pay for gas on every network, even if the network has very cheap gas fees like Polygon. This requires the user to open an account at a centralised exchange, go through KYC, and buy crypto using fiat. This can be quite a process, even for the most skilled of degens out there, and it can deter new users from being onboarded to a dApp by increasing the latency between their initial excitement and the time it takes to actually get started.\nThis is where relaying comes in! A relayer can help solve these issues by sending a transaction on behalf of the user. \nWhat is a relayer?\nWe allow the user to send a transaction without a native token balance (it turns out relayers can be super nifty in loads of ways, for example, allowing a user who wants to swap a token to pay for the gas using the token being swapped!). Ideally, we would also like to still utilise the excellent security of a user signature, but for the transaction to be sent by a different EOA, one controlled by a relayer, who abstracts gas payment away from the user.\nThis is a very import context shift to understand. We have shifted from a user signing and sending a transaction themselves, to a user signing a standardised message and passing that on to a relayer. This relayer will, first, verify the user's signature for security, and then pass their message along on-chain. Gelato Relay does exactly this by taking a user's message off-chain and subsequently building a meta-transaction which is executed on chain.\nWhat is Gelato Relay?\nUsing Gelato Relay, we relay your user's transactions on-chain, enabling secure gasless transactions for an ultra smooth UX for your app. This allows for a variety of new web3 experiences, as the user can now pay by only signing a message, or their transaction costs can be sponsored by the developer. As long as the gas costs are covered in one of the multiple payment methods that Gelato supports, we handle the rest reliably, quickly and securely. \nWhat is a meta transaction?\nA meta transaction is a regular ethereum transaction which contains the actual message to be delivered on-chain to a target contract within itself, hence the term meta.  The outer transaction helps facilitate the first on-chain call which is sent by a relayer. The call is forwarded to the target contract using an intermediate smart contract (Gelato Relay), which in turn forwards the call using the inner transaction to deliver the relayed message. \nEIP-712 signatures\nTo achieve gasless transactions securely, Gelato Relay makes use of the EIP-712 standard. EIP-712 allows for a standardised way to sign and hash typed structured data. This means the user can sign a message using their wallet without incurring a gas cost or interacting with the chain at all, and this signature can be verified on-chain, by the relayer, facilitating a gasless transaction with security built in. This message will include important information such as the transaction signer address, the target contract address, and the calldata payload used to target a specific function.\n​\nServices - Previous\nRelay\nNext\nSecurity Considerations\nLast modified 4mo ago\nON THIS PAGE\nStandard transactions\nOnboarding issues\nWhat is a relayer?\nWhat is Gelato Relay?\nWhat is a meta transaction?\nEIP-712 signatures"
  },
  {
    "title": "Templates & Examples - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/account-abstraction/templates-and-examples",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nTemplates & Examples\nGet started with the Bundler & Paymaster in seconds\nZeroDev Template\nGitHub Repo implementing Gelato + ZeroDev to gaslessly deploy a Smart Wallet and increment a counter. The repo contains a quick start guide in the README. To generate a 1Balance API Key, please refer to 1Balance & Relay.\nThe example uses a maxFeePerGas=0 override which allows transaction fees to be accurately settled post-execution rather than by the EntryPoint.\nThis reduces our on-chain footprint leading to gas savings and avoids overcharging users (e.g., preVerificationGas).\nGitHub - gelatodigital/erc4337-counter-example\nGitHub\nPrevious\nAdvantages & Highlights\nNext\nBundler API Endpoints\nLast modified 2mo ago"
  },
  {
    "title": "Supported Networks - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/account-abstraction/supported-networks",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nSupported Networks\nThe following networks are supported in addition to all Gelato Rollups.\nName\nDeployment\nEthereum\nMainnet\nGoerli\nSepolia\nOptimism\nMainnet\nGoerli\nSepolia\nPolygon\nMainnet\nMumbai\nAvalanche\nMainnet\nBinance Smart Chain\nMainnet\nArbitrum\nMainnet\nGoerli\nSepolia\nBase\nMainnet\nGoerli\nPolygon zkEVM\nMainnet\nTestnet\nLinea\nMainnet\nGoerli\nGnosis\nMainnet\nChiado\nZora\nMainnet\nIf you don't see a network that you'd like supported, feel free to reach out to us.\nServices - Previous\nAccount Abstraction\nNext\nAdvantages & Highlights\nLast modified 1mo ago"
  },
  {
    "title": "Advantages & Highlights - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/account-abstraction/advantages-and-highlights",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nAdvantages & Highlights\nThe Gelato bundler & paymaster take a new approach to ERC-4337 and offer various advantages whilst remaining fully compatible with other implementations.\nAll major EVM-compatible networks are supported, including all Gelato Rollups.\n​1Balance paymaster sponsors operations across all networks with just a single deposit. This allows for easier accounting & management of funds as well as increased transparency.\nTransaction fees are settled post-execution so users are charged exact amounts and not overcharged like is common with other bundlers (e.g., preVerificationGas).\nCheaper transactions due to not incurring on-chain paymaster and fee transfer overhead.\nInstant inclusion as there is no need to wait for other UserOperations to form a bundle.\nMeV Protection as all transactions on Ethereum Mainnet are executed through Flashbots.\nSmart Accounts have unlimited freedom during validation & execution - no blacklisted opcodes or restrictive gas limits. This enables more elaborate signature verification and authentication logic.\nBuilt on top of the existing Relay infrastructure which is battle-tested and scalable.\nThe key difference between Gelato and other bundlers is that no EntryPoint deposit or on-chain paymaster is required. Instead, 1Balance settles transaction fees post-execution across all supported networks.\nThis avoids per-chain user deposits and ensures that the exact amount of gas consumed is charged with 100% accuracy. This is possible by setting maxFeePerGas=0 so that the EntryPoint doesn't require any fee payment (requiredPrefund=0).\nPrevious\nSupported Networks\nNext\nTemplates & Examples\nLast modified 1mo ago"
  },
  {
    "title": "Bundler API Endpoints - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/account-abstraction/bundler-api-endpoints",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\neth_sendUserOperation\neth_estimateUserOperationGas\neth_getUserOperationByHash\neth_getUserOperationReceipt\neth_supportedEntryPoints\neth_maxPriorityFeePerGas\neth_chainId\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nBundler API Endpoints\nList of all supported ERC-4337 Bundler JSON-RPC methods.\nGelato bundlers are ERC-4337 compliant and implement the following JSON-RPC methods as outlined in the specification.\n​eth_sendUserOperation​\n​eth_estimateUserOperationGas​\n​eth_getUserOperationByHash​\n​eth_getUserOperationReceipt​\n​eth_supportedEntryPoints​\n​eth_maxPriorityFeePerGas​\n​eth_chainId​\nPrevious\nTemplates & Examples\nNext\neth_sendUserOperation\nLast modified 2mo ago"
  },
  {
    "title": "1Balance & Relay - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/subscriptions-and-payments/1balance-and-relay",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n1⃣\n1Balance & Relay\n2⃣\nSyncFee Payment Tokens\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n1⃣\n1Balance & Relay\nHow to use Gelato's 1Balance for all your relaying needs\nPlease go to https://app.gelato.network/1balance and log in with your wallet. Deposit SEP for testnets via Sepolia, or USDC on Polygon for production networks and generate an API key based on your needs. Once you have your API key, you are ready to send sponsoredCall and sponsoredCallERC2771 requests.\nYou will have to generate two separate API keys if using both testnets and production i.e. one API key for testnets, one API key for production networks.\nGelato 1Balance is a new flexible and bespoke payment system built from the ground up exclusively for Gelato customers. Gelato 1Balance allows for customers to deposit on any chain they prefer, whilst using that balance to cover their relay costs regardless of target chain.\nHow does 1Balance work?\nFor example, a user can top up their Gelato 1Balance using USDC on Polygon. This USDC balance will now be used to cover all gas costs and fees for any relay call, regardless of the underlying chain.  \nTherefore, a user could request relay calls on Ethereum mainnet, and Gelato will query their 1Balance to see if they possess enough equivalent USDC to cover the costs for this call.  If the balance is sufficient, Gelato will go ahead and relay the message on-chain. \nAfter the transaction is successful, Gelato can use the transaction receipts to charge you exactly the amount that the transaction costs plus a nominal fee. This makes Gelato 1Balance much more friendly on your wallet than payment based on a priori gas simulation which can be uncertain at best, and lead to consistent overcharging in the worst case.\nHow can I use 1Balance?\nGelato 1Balance is live for both testing and production networks. \nTesting\nYou can deposit SEP on Sepolia to cover any transactions across all supported Testnets.\nProduction\nYou can deposit USDC on Polygon to cover any transactions across all supported Mainnets.\n1.\nGo to https://app.gelato.network/1balance and log in with your wallet. Make sure to be connected to the Sepolia network for testing or Polygon for production networks.  You will have to generate two separate API keys if using both testnets and production i.e. one API key for testnets, one API key for production networks.\n2.\nDeposit SEP/USDC using the 1Balance tab.\n3.\nCreate a Relay App, under the Relay tab:\nGive your target contract address, or use the any contract address. \nIf your contract is not verified via Etherscan, paste in a manual ABI to specify which function you want to call using relay.\n4.\nOnce you have successfully created a relay app, you can go ahead and copy your API key, which will be valid across all testnets for sponsoredCall, and sponsoredCallERC2771.\nPrevious\nSubscriptions and Payments\nNext\nSyncFee Payment Tokens\nLast modified 10d ago\nON THIS PAGE\nHow does 1Balance work?\nHow can I use 1Balance?\nTesting\nProduction"
  },
  {
    "title": "Pricing & Rate Limits - Gelato Network",
    "url": "https://docs.gelato.network/~/changes/OV5ZOUyF4Q7199AZf4M3/developer-services/web3-functions/pricing-and-rate-limits",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nPricing & Rate Limits\nVRF\nAutomate (Legacy)\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n💰\nPricing & Rate Limits\nOverview\nIn order for the network to be sustainable & decentralized, Gelato Nodes charge fees for running off-chain computation and executing transactions.\nOur default method is to pay for all your Web3 Function costs across all networks from a single balance using  Gelato 1Balance.  Learn more about it by heading over the linked page:\n1Balance\nComputation Charges\nGelato Nodes will charge computation charges, similar to what you are used to in AWS or Google Cloud. The more computation your Web3 Functions require to run, the more costs Gelato Nodes have and thus need to get compensated. \nGelato Nodes limit the amount of computational resources that your Web3 functions can consume based on the limits set out in your Subscription Plan. \nComputation Limits\nEach subscription plan has limits. For example, on our free Accelerate plan your Web3 Functions usage is limited to:\nNumber of runs per month: 90,000\nRPC requests per run: 5 calls\nMaximum run duration: 5 secs\nMax memory per run: 128mb\nMax storage size per function: 1024 kb (1 mb)\nIf you exceed these limits your Web3 Function runs will be throttled. If you have any questions or would like to discuss your subscription, please reach out to us here. \nTransaction Charges\nEach transaction that Gelato Nodes execute require a small fee to incentivize Nodes to adhere to the protocol and get your transactions included into your desired blockchain in a fast and secure fashion. \nTo achieve this, Nodes charge a fee as a percentage of total gas cost for the executed transaction. This varies across networks - Nodes charge higher premiums on cheaper networks and vice versa.\nNetwork\nPercentage Premium (%)\nEthereum\n20\nPolygon\n70\nFantom\n50\nAvalanche\n40\nBNB\n30\nOptimism\n50\nArbitrum\n50\nGnosis\n100\nZkSync Era\n50\nPolygon zkEvm\n50\nBase\n50\nLinea\n50\nTable 1 - Fee premiums as a percentage of total gas cost per network. Testnet transactions are subsidized by Gelato.\nThese transaction premiums can be customised for users. Please reach out to us here to discuss your needs.\nTransaction pays for itself\nYou can also choose to have your function pay the fee during executions. It must be remembered that running Web3 Functions has computational costs. Please see here the Free Tier limits, in the case that the Web3 Functions goes above these limits, 1Balance will be also required to pay for the computational costs. \nWe offer a range of subscription plans - ranging from Accelerate - a free plan subsidized by Gelato that provides all the essentials to get started - all the way through to an Enterprise Plan with custom computation limits and execution premiums.\nThis can be done by inheriting AutomateReady.\ncontract CounterWT is AutomateReady {\n    uint256 public count;\n    uint256 public lastExecuted;\n​\n    constructor(address _automate, address _taskCreator)\n        AutomateReady(_automate, _taskCreator)\n    {}\n​\n    receive() external payable {}\n​\n    function increaseCount(uint256 amount) external onlyDedicatedMsgSender {\n        count += amount;\n        lastExecuted = block.timestamp;\n​\n        (uint256 fee, address feeToken) = _getFeeDetails();\n​\n        _transfer(fee, feeToken);\n    }\n}\n​\nIn the increaseCount function, we use _transfer inherited from AutomateReady to pay Gelato.\n_transfer has two parameters, fee and feeToken which has to be queried from the Automate contract by using getFeeDetails()\nTo create a task that pays for itself, head over to the task properties and enable the 'Transaction pays itself\"\n​\nPrevious\nContract Addresses\nNext - Services\nVRF\nLast modified 1mo ago\nON THIS PAGE\nOverview\nComputation Charges\nComputation Limits\nTransaction Charges\nTransaction pays for itself"
  },
  {
    "title": "Subscription Notifications - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/1balance/subscription-notifications",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\n1Balance Alerts\nSubscription Plans\nSubscription Notifications\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nSubscription Notifications\nGet upcoming payment and renewal notifications via email\nAdding your Email Address\n1.\nSign In: Access your account by logging in with your wallet.\n2.\nNavigate to Settings: Look for the 'Settings' option within the platform interface. It is typically symbolized by a gear icon.\n\n\n3.\nEmail Configuration: Within 'Settings', switch to the 'Notifications' tab where you can add or edit your email address.\n\n\nVerify your email\nAfter entering your email you should receive a verification email from noreply@gelato.digital asking you to verify your address. \nOn confirmation you will receive a welcome email informing you that you will start to receive notifications.\n\n\nAvailable notifications\nYou will be notified when:\nAn upcoming subscription payment is due\nA subscription has been successfully renewed\nIf there has been an issue renewing your subscription\nRenewal has not been possible and your subscription has been downgraded\nWe will be expanding the range of notifications available.\nStopping notifications\nThe best way to stop notifications is to go to your notifications settings and delete your email. \nYou can also use the unsubscribe links in your emails but note that if you do this and then try to reactivate it you will need to notify us to remove you from the suppression list. \nPrevious\nSubscription Plans\nNext - Services\nAccount Abstraction\nLast modified 1mo ago\nON THIS PAGE\nAdding your Email Address\nVerify your email\nAvailable notifications\nStopping notifications"
  },
  {
    "title": "Subscription Plans - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/1balance/subscription-plans",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\n1Balance Alerts\nSubscription Plans\nSubscription Notifications\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nSubscription Plans\nHow to view and manage your Gelato subscription plans\nTo see your current plan or explore other options, please visit Gelato Network Subscriptions. This page provides detailed information on plan specifications and pricing, helping you choose the right plan for your project.\nOverview\nWe have launched subscription plans for some of our services to provide your project with access to increased thresholds and premium features at a predictable monthly cost, billed seamlessly from 1Balance.\nWeb3 Functions is the first Gelato service to have this feature. When you go to your 1Balance page and login you will see which subscription plan(s) you have active. By default you are enrolled on our free Accelerate plan which we subsidize. \nYour active subscription is shown on your 1Balance page\nClicking on Limits & costs unfolds a panel that details your plan limits and the premiums applied to your transactions. For more information on how these work please see the Fees & Limits section in Web3 Functions. \nUpgrading your subscription\nYou can upgrade your subscription immediately at any time. Click on the Manage button to display the subscriptions managements page.\nTo upgrade your plan, simply click on the Upgrade button for the plan you would like to move up to. You will be asked to confirm the selection. On confirmation, payment will be taken from your 1Balance and your new limits will take immediate effect. \nHow subscription payments work\nSubscription plans renew monthly. 3-days before the end of the month the system will take payment for the upcoming month. For example, on 28th June the system will take payment for your July subscription. If you have insufficient balance, the system will retry every 24 hours. \nIf payment has not been taken by the start of your new month the system will downgrade you to the free plan.\nWe are working on an alerts service to notify you of any upcoming subscription payments and warn you of any problems taking payment\nCustom Subscription Plans\nWe offer tailored plans for customers with particular limit or transaction premium needs. We encourage you to reach out to us to discuss your requirements.\nWhen you have upgraded to a custom plan you will see your limits and costs when you are logged into your account.\nDowngrading & Cancelling\nYou can cancel or downgrade your plan at any time. \nDowngrades or cancellations take effect from the end of the calendar month in which they are triggered. For example, if you are on the Growth Plan and cancel mid-June then you will be downgraded to the Accelerate plan from 1syt July onwards. \nIf you Cancel or Downgrade and change your mind before the end of the month you can reactivate your current plan at any point before the end of the month.\nNotifications\nTo receive email notifications regarding upcoming subscription payments and renewals please setup your notifications.\nPrevious\n1Balance Alerts\nNext\nSubscription Notifications\nLast modified 4d ago\nON THIS PAGE\nOverview\nUpgrading your subscription\nHow subscription payments work\nCustom Subscription Plans\nDowngrading & Cancelling\nNotifications"
  },
  {
    "title": "Others - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/gelato-rollup-as-a-service-raas/marketplace/others",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\nDeploy your L2 Chain\nExecution Frameworks\nData Availability\nReliability & Security\nScaling Solutions Wiki\nMarketplace\nGelato Services\nData Indexers\nBlock Explorers\nOracles\nBridges\nAccount Abstraction\nOn & Off-ramp\nCommunity\nIdentity & KYC\nOthers\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nOthers\nShutter\n​Shutter is a protocol that protects users from malicious MEV and offers censorship resistance on your L2 by using threshold encryption with Distributed Key Generation (DKG).\nShutter is live with:\nAdvanced MEV protection: Combat front-running & exploitative attacks\nEncrypted mempool: Transaction privacy by keeping strategies confidential\nCensorship-resistance: Safeguard your transactions from undue influence and complete autonomy over trades.\nZerion\n​Zeroin streamlines DeFi asset, NFT tracking, and multi-chain portfolio management for your L2\nZerion is live with:\nPortfolio Tracking Dapp: Zerion offers a portfolio tracking application that encompasses NFTs, DeFi, and transaction history for all wallets across major chains.\nPrevious\nIdentity & KYC\nNext - Services\n1Balance\nLast modified 11d ago"
  },
  {
    "title": "Subscriptions and Payments - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay/subscriptions-and-payments",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n1⃣\n1Balance & Relay\n2⃣\nSyncFee Payment Tokens\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n💸\nSubscriptions and Payments\nHow can you pay for your relayed transactions?\nRelay Subscriptions \nGelato Relay Subscription Plans are designed to scale effectively and efficiently to fit your needs, whether they are large or small. Below, you'll find the updated pricing details for each plan, along with explanations for each pricing component.\nAutoscale Feature\nTo prevent service interruption upon exceeding plan limits, you can enable the autoscale feature. This allows your plan to automatically accommodate additional requests beyond your set limits, billed at the specified autoscale rates.\nIf the autoscale feature is deactivated, all requests that exceed either monthly or throughput limits included in your Relay subscription plan, will be rejected.\nPayment Methods\nPayments for Relay subscription plans are processed through 1Balance. When transactions are conducted using sponsoredCall or sponsoredCallERC2771, the associated gas costs are also settled via 1Balance. However, if you utilize callWithSyncFee or callWithSyncFeeERC2771, your transaction gas costs should be covered by an on-chain transfer. For further details, please see the information below.\n1Balance\nSupported SDK methods: see sponsoredCall, sponsoredCallERC2771​\nGelato 1Balance is a new flexible and bespoke payment system built from the ground up exclusively for Gelato customers. Gelato 1Balance allows for customers to deposit on any supported, whilst using that balance to cover their relay costs regardless of target chain.\nNetworks & Tokens supported\nTestnets: Deposit SEP on Sepolia to cover transactions across all supported Testnets.\nMainnets: Deposit USDC on Polygon to cover transactions across all supported Mainnets.\nFor more information, please see 1Balance.\nSyncFee\nSupported SDK methods: see callWithSyncFee, callWithSyncFeeERC2771​\nSyncFee is the simplest way to pay, but it delegates all security (reentrancy/replay protection etc.) and payment logic to the target smart contract. You can use ERC-2771 to achieve out-of-the-box security and authentication. Relay costs are covered in either native or ERC-20 tokens and they are paid synchronously during the relay call. \n\nPlease visit SyncFee Payment Tokens for the full list of supported tokens per network.\nPrevious\nSupported Networks\nNext\n1Balance & Relay\nLast modified 2d ago\nON THIS PAGE\nRelay Subscriptions\nAutoscale Feature\nPayment Methods\n1Balance\nSyncFee"
  },
  {
    "title": "1Balance Alerts - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/1balance/1balance-alerts",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\n1Balance Alerts\nSubscription Plans\nSubscription Notifications\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n1Balance Alerts\nGet alerted when your balance is running low\nGet alerted when your balance is running low. If you are utilizing Gelato 1Balance, you can subscribe to a real-time alerting system that uses Email, Telegram or Discord to inform you when your 1Balance funds drop below a specified threshold.\nEmail \nYou can opt-in for email notifications. This feature ensures you are promptly informed when your balance falls below a specified minimum threshold, allowing you to take immediate action to replenish your funds.\nTo receive low balance alerts via email, ensure your email address is verified in the settings. You can set up alerts to be sent when your balance is low by toggling the feature in the 'Low Balance Alerts' section and defining the minimum balance.\nAlert received that balance has dropped below 4.9 USDC\nAdditional Alert Triggers\nThe system will send out alerts not only for low balances but also when:\nYour balance reaches zero.\nShould your account enter overdraft.\nWhen the allotted overdraft amount is fully utilized.\nTelegram\nDM GelatoWatcherBot on Telegram. \nChoose from the list of commands below.\nCommand\nUsage\n /balance\nThis command initiates the balance alert system on Telegram. After entering this command, the bot will start sending alerts for your balance.\n/1balance_threshold\nThis command allows you to configure the balance threshold. The bot will ask for a token and a threshold value. Respond with a comma-separated input in the form (TOKEN, THRESHOLD). For example, USDC,100 sets a threshold of 100 for USDC.\n/list_threshold\nThis command lists all your set thresholds.\n/stop_balance\nThis command stops the balance alert system. If you wish to stop receiving balance alerts, enter this command.\nDiscord server\nAdd Gelato Bot to your server using this invite link (you need to be the admin of the server)\nIf you want to receive notifications in a private channel, make sure to add Gelato Bot as a member in the channel where you want to receive the notification.\nEnter the following commands in the channel you want to receive alerts.\nCommand\nUsage\n/balance-channel address\nThis command initiates the balance alert system on your Discord server. Replace address with the address you want to set up alerts for.\n/1balance-threshold-channel token threshold\nThis command allows you to configure the balance threshold. Replace token and threshold with the respective token and threshold value.\n/list-threshold-channel\nThis command lists all your set thresholds.\n/stop-balance-channel\nThis command stops the balance alert system. If you wish to stop receiving balance alerts, enter this command.\nDiscord Direct Message (DM)\nJoin our Gelato Discord server​\nChoose from the list of commands below\nCommand\nUsage\n/balance-dm address\nThis command initiates the balance alert system in a Direct Message on Discord. Replace address with the address you want to set up alerts for.\n/1balance-threshold-dm token threshold\nThis command allows you to configure the balance threshold. Replace token and threshold with the respective token and threshold value.\n/list-threshold-dm\nThis command lists all your set thresholds.\n/stop-balance-dm\nThis command stops the balance alert system. If you wish to stop receiving balance alerts, enter this command.\nSubscription Notifications\nIf you would like to receive subscrption notifications emails, follow this guide.\nServices - Previous\n1Balance\nNext\nSubscription Plans\nLast modified 1mo ago\nON THIS PAGE\nEmail\nTelegram\nDiscord server\nDiscord Direct Message (DM)\nSubscription Notifications"
  },
  {
    "title": "Celestia - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/gelato-rollup-as-a-service-raas/data-availability/celestia",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\nDeploy your L2 Chain\nExecution Frameworks\nData Availability\nCelestia\nAvail\nReliability & Security\nScaling Solutions Wiki\nMarketplace\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nCelestia\n​Celestia offers a scalable modular data availability network that securely scales with user numbers, enabled by Data Availability Sampling (DAS). It facilitates the deployment of high-throughput and low-cost validium and sovereign rollups on Gelato. Layer 2 solutions utilize Celestia as a network for publishing transaction data, making it available for download by anyone.\nCelestia DA layer key features\nDynamic Scaling\nCelestia uses data availability sampling to enable scaling that increases with the number of users, ensuring dynamic adaptability to growing demands\nVirtual Machine Flexibility\nOffers the ability to choose any Virtual Machine, facilitating the development of applications with specialized features and diverse use-cases.\nEase of Deployment\nUsers can deploy their own L2 Blockchain quickly, with a simplicity comparable to deploying a smart contract.\nDesign Principles\nData Availability Sampling (DAS)\nThis process allows light nodes in Celestia to verify the availability of block data without downloading the entire block. Light nodes randomly sample small portions of the data, and if these samples are verified, it indicates that the full block's data is likely available. This method ensures efficient and scalable data verification.\nNamespaced Merkle Trees (NMTs)\nNMTs are used to organize block data into distinct sections (namespaces), each corresponding to different applications like rollups. They enable applications to download and verify only the data relevant to them, ignoring data from other applications. This system ensures that applications receive all the necessary data for their specific namespace.\nCelestia with Gelato execution frameworks\nGelato integrates with Celestia so execution frameworks post the calldata to Celestia rather than directly on Ethereum. This reduces data storage costs significantly and enables higher transaction throughput making the roll-ups more attractive for applications that require high performance and lower fees.\nCelestia x Arbitrum Orbit \nGelato's support  Celestia integration with Arbitrum Orbit provides developers with an alternative data availability layer facilitating the launch of high-throughput, optimistic-powered Ethereum Layer 2 chains. This integration enables the deployment of Arbitrum Rollups using Celestia for data availability instead of Ethereum, scaling securely with numbers of users' with data availability sampling (DAS).\nIn the case of ERC20 transfer rollup transactions on OP stack with 1M transactions and an average callData size of 120 bytes, the expected cost is $122,413 while using Celestia for callData, the cost is significantly lower at $347, resulting in 99.74%% savings.\nCelestia x OP Stack\nGelato's support for Celestia's integration with OP Stack facilitates the launch of high-throughput, optimistic-powered Ethereum Layer 2 chains made possible by Celestia’s data availability sampling (DAS). If Celestia experiences downtime or temporary unavailability, L2s can fallback to posting transactions as calldata on Ethereum or another DA layer to maintain data availability.\nIn the case of ERC20 transfer rollup transactions on OP stack with 1M transactions and an average callData size of 120 bytes, the expected cost is $78,558 while using Celestia for callData, the cost is significantly lower at $332, resulting in 99.61% savings.\nCelestia x Polygon CDK\nGelato supports integration of Celestia's modular DA layer with Polygon CDK enabling the easy launch of high-throughput, zero knowledge-powered Ethereum Layer 2 chains. This integration is poised to reduce Ethereum L2 transaction fees significantly and improve scalability through data availability sampling (DAS), where users can participate with a Celestia light node.\nIn the case of ERC20 transfer rollup transactions on OP stack with 1M transactions and an average callData size of 120 bytes, the expected cost is $65,315 while using Celestia for callData, the cost is significantly lower at $306, resulting in 99.53% savings.\nGet more information about Celestia, or Schedule call to set up your custom Op Stack Gelato L2 testnet.\nPrevious\nData Availability\nNext\nAvail\nLast modified 8d ago"
  },
  {
    "title": "Avail - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/gelato-rollup-as-a-service-raas/data-availability/avail",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\nDeploy your L2 Chain\nExecution Frameworks\nData Availability\nCelestia\nAvail\nReliability & Security\nScaling Solutions Wiki\nMarketplace\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nAvail\nGelato RaaS leverages Avail as a data availability (DA) layer. Avail provides a fast and secure data and consensus layer enabling the creation of hyperefficient L2 blockchains such as Validiums and Plasma, for ultimate control of your state, and execution environment.\nAvail DA layer key features\nAvail's system design enhances efficiency by decoupling data hosting, execution, and verification.\nSecure Verifiable Data\nAvail allows light clients to easily verify data availability through sampling over a peer-to-peer network, and inherit full node-level security and validation directly from the DA layer.\nSimple Blockchain Integration\nAvail's modular approach eliminates the need for developers to manage validator sets or understand tokenomics.\nFlexible Execution Environment\nAvail's data-agnostic nature accommodates multiple execution environments, such as EVM, WASM, and custom new runtimes, providing a flexible foundation for a wide range of blockchain applications.\nDesign Principles\nErasure coding:\nErasure coding in Avail works by adding layers of redundancy to transaction data to ensure its integrity and reliability.  When transactions are processed in Avail, they are split into parts that are duplicated and can be used to reconstruct the full data. This means that even if some parts are lost or corrupted, the complete data can still be recovered.\nData Availability Sampling (DAS):\nAvail's light clients perform data availability sampling by randomly sampling small sections of block data to verify their correctness. Combined with erasure coding and KZG polynomial commitments, this technique enables Avail clients to provide strong guarantees of data availability, nearly 100%, without relying on fraud proofs and with only a minimal number of queries\nGet more information about Avail, or Schedule call to set up your custom Op Stack Gelato L2 testnet.\nPrevious\nCelestia\nNext\nReliability & Security\nLast modified 8d ago"
  },
  {
    "title": "OP Stack - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/gelato-rollup-as-a-service-raas/execution-frameworks/op-stack",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\nDeploy your L2 Chain\nExecution Frameworks\nPolygon CDK\nOP Stack\nArbitrum Orbit\nData Availability\nReliability & Security\nScaling Solutions Wiki\nMarketplace\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nOP Stack\nOptimistic Scaling Solutions: OP Stack\n​OP Stack is a standardized, shared, and open-source development framework, combined with Gelato RaaS, it enables developers to deploy their own Optimistic Layer 2 chains, specific to end-users needs on Ethereum. By utilizing optimistic rollups, developers can take advantage of near-zero computational overhead, fast throughput, low transaction costs, and improved EVM compatibility. This powerful combination prioritizes key business operations and user interaction, ensuring optimal performance through adaptable L2 chains.\nOptimism Bedrock is the current iteration of the OP Stack. The Bedrock release provides the tools for launching a production-quality Optimistic Rollup blockchain.\nOP Stack Features\nLower Fees\n90% lower than Ethereum's gas fees, Bedrock achieves this reduction by optimizing data compression to cut costs and eliminate gas expenses for EVM execution.\nFast Transactions\nWith a 2-second block time compared to Ethereum's average of 12 seconds, Optimism ensures significantly faster transaction confirmations.\nEnhanced Proof Modularity\nBedrock's design allows rollups to use various proof systems, like fault or validity proofs, providing flexibility for technologies like Cannon to verify correct execution.\nEthereum Equivalence\nBedrock aims for high compatibility with Ethereum, offering developers a familiar experience by allowing the running of smart contracts and dApps designed for Ethereum without modification and utilizing existing Ethereum tooling and infrastructure.\nImproved Node Performance\nExecution of multiple transactions in a single rollup block and removal of technical debt from previous versions improve node software performance.\nThe Superchain\nThe Superchain is a future development by Optimism, envisioned as a network of Layer 2 chains (OP Chains) built on the OP Stack. These OP Chains will share security, a communication layer, and a technology stack, but will be standardized and interchangeable, differing from traditional multi-chain designs. It's a concept and in-progress project aimed at merging Optimism Mainnet and other chains into a unified network, enhancing scalability and decentralized computing​​.\nIndependent Data Availability\nGelato provides support for Optimium, a dedicated data availability layer for OP Stack that offers robust off-chain data access. It enables the launch of high-throughput and very low-cost, optimistic-powered Layer 2 chains on the Ethereum network.\nFor OP Stack, Gelato RaaS Supports:\n- Celestia modular data availability network​\nGet more information about OP Stack here, or Schedule call to set up your custom Op Stack Gelato L2 testnet.\nPrevious\nPolygon CDK\nNext\nArbitrum Orbit\nLast modified 8d ago"
  },
  {
    "title": "Arbitrum Orbit - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/gelato-rollup-as-a-service-raas/execution-frameworks/arbitrum-orbit",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\nDeploy your L2 Chain\nExecution Frameworks\nPolygon CDK\nOP Stack\nArbitrum Orbit\nData Availability\nReliability & Security\nScaling Solutions Wiki\nMarketplace\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nArbitrum Orbit\nOptimistic Scaling Solutions: Arbitrum Orbit\n​Arbitrum Orbit is an advanced, adaptable, and open-source framework, enabling developers to deploy their own customized Arbitrum Rollup and AnyTrust chains. This solution is tailored for Ethereum's ecosystem, leveraging the unique strengths of Arbitrum's technology. By using Orbit, developers can create chains that meet specific needs with high performance, cost efficiency, and Ethereum compatibility.\nArbitrum Rollup is a protocol implemented by Arbitrum One. It stores raw transaction data on Ethereum's Layer 1 (L1) blockchain. This approach ensures complete security by leveraging Ethereum’s security model while improving scalability through off-chain computation.\nArbitrum Orbit Features\nEnhanced Throughput and Isolation\nOrbit chains offer dedicated throughput and traffic isolation, ensuring reliable gas prices and improved performance for end-users. This is especially beneficial for applications demanding high performance or consistent resource availability.\nVersatility and interoperability\nOrbit chains can be used for a range of purposes, from hosting a single dApp to an ecosystem of dApps, with the capability to communicate with other Orbit chains.\nCut Customizable Chain Architecture\nOrbit's architecture allows for the creation of chains using either Arbitrum Rollup or AnyTrust protocols. This provides developers with the flexibility to choose the optimal proof system for their specific requirements, ensuring effective and efficient operation.\nEVM+ Compatibility\nOrbit supports EVM+ compatibility via Stylus, enabling the deployment of smart contracts in multiple programming languages without moving away from existing workflows.\nCustom Gas Token\nOrbit supports the use of alternative ERC-20 tokens for gas fees, allowing seamless integration with different app ecosystems.\nGas Price Stability\nOrbit's isolated chains provide more predictable gas prices, enhancing the user experience and cost management for dApps.\nIndependent Data Availabiliy\nGelato provides support for Optimium, a dedicated data availability layer for Arbitrum orbit that offers robust off-chain data access. It enables the launch of high-throughput and very low-cost, optimistic-powered Layer 2 chains on the Ethereum network.\nFor Arbitrum orbit, Gelato RaaS Supports:\n- Celestia modular data availability network​\n- Arbitrum AnyTrust​\n AnyTrust protocol differs from Rollup by using a Data Availability Committee (DAC) to store raw transaction data. This setup expedites settlement and reduces costs, introducing a slight security trade-off. AnyTrust is a good fit for projects seeking higher performance and lower costs,\nGet more information about Arbitrum Orbit, or Schedule call to set up your custom Op Stack Gelato L2 testnet.\nPrevious\nOP Stack\nNext\nData Availability\nLast modified 8d ago"
  },
  {
    "title": "Polygon CDK - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/gelato-rollup-as-a-service-raas/execution-frameworks/polygon-cdk",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\nDeploy your L2 Chain\nExecution Frameworks\nPolygon CDK\nOP Stack\nArbitrum Orbit\nData Availability\nReliability & Security\nScaling Solutions Wiki\nMarketplace\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nPolygon CDK\nZero Knowledge Scaling Solution: Polygon CDK\nGelato pioneers the first public Chain Development Kit (CDK) testnet chain on Polygon, in collaboration with Astar Network.\nGelato L2 Chains can leverage the Polygon zkEVM execution environment a Layer Two (L2) scaling solution for Ethereum, that utilizes zero-knowledge (ZK) proofs. Its main features are:\nPolygon CDK Features\nHyper Scalability\nGelato L2 chains leveraging Polygon CDK benefit from enhanced transaction speed and are fully aligned with Polygon 2.0's vision of a highly scalable ecosystem.\nLower Gas\n86% cheaper than Ethereum Mainnet, Polygon zkEVM utilizes ZK proofs and a reduced zkSNARK footprint on L1 for user cost optimization, offering significantly lower transaction costs.\nPrivacy Options\nCDK-developed Gelato chains allow for private app chains, prioritizing privacy. Clients can maintain data confidentiality while benefiting from blockchain technology.\nEVM equvivalence\nEnables deployment onto the Ethereum Virtual Machine without code changes, ensuring that the vast majority of existing smart contracts, developer tools, and wallets work seamlessly, allowing developers to concentrate on improving code rather than rewriting it.\nSecurity\nPolygon zkEVM utilizes ZK proofs to enhance transaction efficiency and throughput, inheriting Ethereum L1's robust security.\nUnified Liquidity\nGelato L2 chains developed with Polygon CDK ensure unified liquidity, allowing fluid asset transfers across multiple chains within Polygon 2.0's L2 ecosystem.\nDedicated Data Availability\nWith a dedicated data availability layer and DAC, Gelato RaaS L2 chains utilizing Polygon’s CDK framework offer independent off-chain data access and reliability, ensuring substantial data resilience and integrity.\nComposable Interoperability\nGelato RaaS deployed L2 chains utilizing Polygon CDK enjoy enhanced interoperability through the LXLY Bridge, enabling seamless interaction and asset exchange across diverse blockchains.\nNear Instant Finality\nGelato RaaS L2 Chains deployed using the Polygon CDK provide near-instant finality and robust security through cryptographic measures, eliminating the need for full nodes.\nIndependent Data Availability\nGelato provides support for Validium, a dedicated data availability layer for Polygon CDK that offers robust off-chain data access. It enables the launch of high-throughput and very low-cost, ZK-powered Layer 2 chains on the Ethereum network.\nFor Polygon CDK, Gelato RaaS Supports:\n- Celestia modular data availability network​\n- Avail modular data availability network​\n- Data Availability Committee (DAC)​\nGet more information about Polygon CDK here, or Schedule call to set up your custom Polygon CDK Gelato L2 testnet.\nPrevious\nExecution Frameworks\nNext\nOP Stack\nLast modified 8d ago"
  },
  {
    "title": "Marketplace - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/gelato-rollup-as-a-service-raas/marketplace",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\nDeploy your L2 Chain\nExecution Frameworks\nData Availability\nReliability & Security\nScaling Solutions Wiki\nMarketplace\nGelato Services\nData Indexers\nBlock Explorers\nOracles\nBridges\nAccount Abstraction\nOn & Off-ramp\nCommunity\nIdentity & KYC\nOthers\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nMarketplace\nAt Gelato, we have a strong ecosystem of vetted 3rd party infrastructure providers for rapid deployment of your tailored App or Ecosystem chains. At Gelato, we handle all heavy lifting—no negotiations or manual setups are required. Gelato Rollups go beyond standard offerings by integrating essential services from the Genesis block onwards. Each Gelato RaaS chain comes equipped with;\nRPC: Query and transact with your rollup via high-performance APIs\nBlock Explorer: View and search transaction histories, block details and network activity\nBridge UI: Easily transfer assets between your rollup and its Layer 1 network\nTX Debugger: Inspect, trace and debug transactions to help identify and fix issues\nAccount Abstraction: Simplified user accounts based on smart-contracts\nWeb3 Functions: Comprehensive automation solution supporting both on & off-chain data\nVRF Randomness: Secure and verifiable way to generate random numbers\nMulti-sig Support: Enhanced security requiring multiple parties to agree on tx executions\nOn/Off-Ramps: Easy conversion between fiat currencies and your L2 cryptos\nGelato | Rollup-as-a-Service RaaS Marketplace\nPrevious\nScaling Solutions Wiki\nNext\nGelato Services\nLast modified 8d ago"
  },
  {
    "title": "Scaling Solutions Wiki - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/gelato-rollup-as-a-service-raas/scaling-solutions-wiki",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\nDeploy your L2 Chain\nExecution Frameworks\nData Availability\nReliability & Security\nScaling Solutions Wiki\nMarketplace\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nScaling Solutions Wiki\nThe Layer 1 Ethereum blockchain faces scalability issues as the number of users grows, leading to slower transactions and higher costs. This necessitates scaling solutions to increase transaction speed and throughput without compromising decentralization or security, which are crucial for Ethereum's widespread adoption.\nOff-chain scaling solutions are implemented separately from the main Ethereum network and do not require changes to the protocol. They include:\nLayer 2 solutions, such as optimistic rollups and zero-knowledge rollups, which derive their security from the main Ethereum network.\nOther off-chain solutions, such as sidechains, validiums, or plasma chains, which have separate security mechanisms and interact with the main network in various ways\nRollups\nRollups are a layer-2 scaling solution for Ethereum, designed to enhance transaction throughput and efficiency. They work by \"rolling up\" multiple transactions into a single batch, processing them off the main blockchain (off-chain), and then submitting a summarized record to the main chain. This reduces the data and computational load on the primary blockchain, enabling faster and cheaper transactions. \nThere are two types of rollups, each with different security models:\nOptimistic rollups\nOptimistic Rollups operate under the assumption that transactions are valid, which is why they are called \"optimistic.\" These frameworks offer scalability improvements of up to 10-100x compared to the main Ethereum chain. One key feature is the fraud-proof mechanism, which enables anyone to challenge the validity of a transaction within a specified period. If a challenge proves a transaction to be fraudulent, it is corrected, and penalties are imposed on the responsible party. Transactions that go unchallenged are accepted as valid, greatly enhancing Ethereum's scalability and operational efficiency.\nZero Knowledge rollups\nTo enhance Ethereum's throughput, zero-knowledge rollups execute transactions off-chain. A summary of these transactions, along with a cryptographic proof of correctness, is then posted to the Ethereum Mainnet. This cryptographic validity proof confirms that the state changes are a result of the processed transactions. By adopting this approach, the amount of data transmitted to the blockchain is significantly reduced. Additionally, transaction finality is instant as state updates are approved once the validity proofs are verified on L1.\nWhat is Rollup-as-a-Service?\nRollups-as-a-Service (RaaS) is a specialized service designed to simplify the creation and customization of Rollup chains or application-specific Rollups for web3 projects. RaaS providers offer an integrated stack that handles the complexities traditionally associated with launching Rollups using SDKs and frameworks. This service provides an abstraction layer, eliminating the need for intensive infrastructure management, operating nodes, or writing complex code. \nWith RaaS, developers can easily tailor aspects like data availability and fee payments to fit their application's needs. The service offers a user-friendly, dashboard-like platform with advanced tooling, allowing developers to deploy production-grade, custom Rollups quickly and without requiring extensive technical expertise in the Rollup stack, similar to how software-as-a-service products operate without the need for users to manage hardware or host services.\nValidiums\nValidium is a scaling solution that enhances the processing capacity of Ethereum by utilizing off-chain data availability and computation. It operates similarly to ZKRollups, using zero-knowledge proofs to validate off-chain transactions on Ethereum. Unlike ZK-rollups, Validium stores all transaction data off-chain, substantially reducing its on-chain data footprint. This off-chain data model not only boosts scalability (enabling around 2500 transactions per second or more) but also reduces transaction fees for users, as the cost of publishing call data is lower. Validiums focus on transaction privacy and scalability making them primarily beneficial for applications like high-frequency trading or blockchain gaming.\nData Availability\nData availability in blockchain refers to ensuring that the data needed to validate and verify new blocks is accessible to all network participants. This is crucial for maintaining the integrity and security of the blockchain. In traditional blockchains, such as Ethereum, full nodes download each block to verify its contents. However, this approach is challenging for scalability. Modular blockchains, like those using Layer 2 rollups, address this by processing transactions off the main chain and then posting summaries to the primary chain. The key challenge here is to guarantee that all necessary data to recreate the off-chain (Layer 2) state is available, without requiring primary layer (Layer 1) nodes to download and store extensive data. This ensures the security and efficacy of off-chain scaling solutions.\n\n\n\n​\nPrevious\nReliability & Security\nNext\nMarketplace\nLast modified 8d ago"
  },
  {
    "title": "Reliability & Security - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/gelato-rollup-as-a-service-raas/reliability-and-security",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\nDeploy your L2 Chain\nExecution Frameworks\nData Availability\nReliability & Security\nScaling Solutions Wiki\nMarketplace\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nReliability & Security\nAt Gelato, we are committed to upholding industry-standard best practices to guarantee the reliability and availability of our services. Our systems are designed with High Availability (HA) and fault tolerance as fundamental principles, resulting in a resilient and robust infrastructure. This approach is essential for mitigating service disruptions and guaranteeing consistent performance.\nReliability\nMulti-cloud\nAll Gelato infrastructure benefits from a multi-cloud and multi-region strategy, distributed globally across various clouds and regions. Our approach guarantees operational continuity, enhancing stability against regional variances, optimizing response times, and delivering a seamless experience to users worldwide.\nData Recovery\nEnsuring maximum data preservation and maintaining the safety and security of your operations, even in unforeseen circumstances.\nAutoscaling RPC nodes\nWe dynamically adjust resources to match your transaction volume and deliver best-in-class performance.\nResponse times & Escalation Guidelines\nEffective and timely response and resolution are key to maintaining our high service reliability. We prioritize incidents and issues based on their urgency and define response times accordingly. Our response time framework is as follows:\nP1 (High Priority): 2 business hours response\nP2 (Medium Priority): 6 business hours response\nP3 (Low Priority): 8 business hours response\nInternal Alert System\nOur system effectively triggers alerts and pages relevant personnel for immediate action. It is crucial for our operations, providing dependability and swift response capabilities.\nSecurity\nMulti-Signature Rollup Security\nGelato employs a multi-signature system for managing its rollup contracts, necessitating consensus among multiple team members for critical decisions. It enhances security by distributing authority, thus safeguarding the system and user funds even in scenarios of potential compromise.\nSecure Encryption\nAll communications and data transfers, including hot wallet keys, are fully encrypted to ensure comprehensive protection.\nAdvanced Security for Key Management\nAdvanced security methods are employed to manage keys and secrets, to ensure a secure and tightly controlled access to sensitive data. This ensures safe key injection into applications without direct access by the provider.\nDDoS Protection\nProtect your rollups from hostile attempts to overwhelm your public RPC endpoints with traffic. This robust defense mechanism safeguards against malicious attacks, ensuring the security and availability of your system\nPrevious\nAvail\nNext\nScaling Solutions Wiki\nLast modified 11d ago"
  },
  {
    "title": "Deploy your L2 Chain - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/gelato-rollup-as-a-service-raas/deploy-your-l2-chain",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\nDeploy your L2 Chain\nExecution Frameworks\nData Availability\nReliability & Security\nScaling Solutions Wiki\nMarketplace\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nDeploy your L2 Chain\nGelato makes L2 chain deployments easy. Our approach focuses on seamless L2 chain deployment, scalability, and integrated blockchain solutions to speed up your time to market with zero infrastructure overhead.\nWhat's not to love?\nThe Gelato RaaS App is invite-only! Schedule call to set up your custom Gelato L2 testnet.\nTestnet & Mainnet Deployment\nTo launch your custom Gelato L2 testnet, simply follow these steps:\n1.\nEnter a deployment name\n2.\nSelect your rollup framework of choice (Polygon CDK or OP Stack)\n3.\nPick your deployment environment as \"Testnet\"\n4.\nAdd wallet addresses if you need to receive test ETH\n5.\nOnce you're ready, click \"Deploy\" to launch your testnet chain!\nHere's how to get started:\n1.\nSchedule an exploratory call to discuss your project and how the Gelato team can help.\n2.\nFinalize your L2 configuration, service agreements, and deployment schedules\n3.\nLaunch your custom L2 on the mainnet and join other customers like Astar and more.\nServices - Previous\nGelato Rollup-as-a-Service (RaaS)\nNext\nExecution Frameworks\nLast modified 10d ago"
  },
  {
    "title": "Data Availability - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/gelato-rollup-as-a-service-raas/data-availability",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\nDeploy your L2 Chain\nExecution Frameworks\nData Availability\nCelestia\nAvail\nReliability & Security\nScaling Solutions Wiki\nMarketplace\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nData Availability\nWith Gelato RaaS Developers can effortlessly define their own virtual execution environments; similar to virtual machines leveraging Polygon CDK or Op Stack with Avail or Celestia as their Data Availability (DA) layer.\nCelestia\nAvail\nPrevious\nArbitrum Orbit\nNext\nCelestia\nLast modified 11d ago"
  },
  {
    "title": "Execution Frameworks - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/gelato-rollup-as-a-service-raas/execution-frameworks",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\nDeploy your L2 Chain\nExecution Frameworks\nPolygon CDK\nOP Stack\nArbitrum Orbit\nData Availability\nReliability & Security\nScaling Solutions Wiki\nMarketplace\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nExecution Frameworks\nExecution Layer\nGelato offers the industry's most advanced execution environments, combining high scalability and low cost. It utilizes proven and highly performant EVM-compatible frameworks built with optimistic and zero knowledge technologies.\nPolygon CDK\nOP Stack\nArbitrum Orbit\nPrevious\nDeploy your L2 Chain\nNext\nPolygon CDK\nLast modified 11d ago"
  },
  {
    "title": "Social Media - Gelato Network",
    "url": "https://docs.gelato.network/social-media",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nSocial Media\nDiscord: https://discord.com/invite/ApbA39BKyJ​\nTwitter: https://twitter.com/gelatonetwork​\nTelegram: https://t.me/gelatonetwork​\n​\nGELATO DAO - Previous\nGovernance Process\nLast modified 2mo ago"
  },
  {
    "title": "Governance Process - Gelato Network",
    "url": "https://docs.gelato.network/gelato-dao/governance-process",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nGovernance Process\nOne of the GEL token's core functions is to facilitate the governance of the Gelato DAO. \nThe following Medium article describes how our governance process currently operates. \nGelato Network Governance Process\nMedium\nGELATO DAO - Previous\nGEL Token Contracts\nNext\nSocial Media\nLast modified 1yr ago"
  },
  {
    "title": "Supported Networks - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy/supported-networks",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nSupported Networks\nDeprecation Notice: Gelato Functions is set to replace Automate, providing enhanced automation capabilities, access to off-chain data, unified payments across networks, and a performance boost. Migrate your tasks to Gelato Functions before Legacy Automate's end of life on June 30th, 2024 for uninterrupted service.\n​Gelato Automate currently supports the following networks:\nArbitrum\nAvalanche\nBNB Chain (formerly Binance Smart Chain)\nEthereum Mainnet\nFantom\nGnosis Chain (formerly xDAI)\nOptimism\nPolygon\nMore networks are on the way! Please feel free to reach out to us if there's a network where you would like Gelato Automate deployed.\nThe following staging networks are supported:\nGoerli\nMumbai\nArbitrum Goerli\nOptimism Goerli\nBase Goerli\nServices - Previous\nAutomate (Legacy)\nNext\nPaying for your transactions\nLast modified 1mo ago"
  },
  {
    "title": "GEL Token Contracts - Gelato Network",
    "url": "https://docs.gelato.network/gelato-dao/gel-token-contracts",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nGEL Token Contracts\nThe official GEL token contract addresses for each network on which it has been deployed are:\nChain\nGEL Token Contract Address\nEthereum (ERC20)\n0x15b7c0c907e4C6b9AdaAaabC300C08991D6CEA05\nFantom\n0x15b7c0c907e4C6b9AdaAaabC300C08991D6CEA05\nPolygon \n0x15b7c0c907e4C6b9AdaAaabC300C08991D6CEA05\nAny \"GEL\" token with a contract address that is not listed on this page is a fake.\nGELATO DAO - Previous\nDAO & Token (GEL)\nNext - GELATO DAO\nGovernance Process\nLast modified 1yr ago"
  },
  {
    "title": "DAO & Token (GEL) - Gelato Network",
    "url": "https://docs.gelato.network/gelato-dao/dao-and-token-gel",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nDAO & Token (GEL)\nFrom day one, Gelato was envisioned to be an open-source and community-driven project. Gelato is designed to be a protocol owned by the people who use it the most. Making decisions in the Network should be done by all the stakeholders collaboratively giving the power back to the people. \nIn order to achieve this, the Gelato DAO was created. The Gelato DAO is powered by the Gelato token (GEL). The Gelato token is the central focal point of all relevant stakeholders in the network. The token exists as a utility for effective incentive alignment amongst the protocols' participants. Token holders will be able to signal their support for or opposition to Proposals in the Gelato DAO.\n1) Governance\nAll token holders are able to have a say in the future direction of the protocol via voting on proposals in the Gelato DAO. The goal is that in the long run, developers that use Gelato to automate their smart contracts functions will govern over the protocol in order to determine the “rules” by which the Executor bots that serve the network have to adhere by.\nDecisions include setting fees for Executors, deciding on developer incentive schemes, and enforcing that Executors always execute transactions in the best interest of the end-user.\n2) Staking\nFor Executors, in order to be able to participate in executing transactions in the Gelato Network and thus earning rewards from doing so, they will need to acquire & stake $GEL. Staking will allow executors to earn the ability to reserve “slots’’ which give them the exclusive right to earn fees from executing transactions in a certain period of time.\nRewards revenue comes from two sources: 1) transaction fees charged on top of each transaction and 2) market opportunities that can be taken advantage of by back running transactions.\n\nWe are currently heavily optimizing for increasing the number of transactions because this will be the most important factor determining the future success of Gelato in the long run.\nPotentially slashing the stake of Executors will serve the purpose of disincentivizing bad behavior, such as censoring or front running transactions, making such actions uneconomical. The Gelato DAO will have the power to enforce these decisions and the obligation to monitor the behavior of Executors. Executors will become more accountable for their actions which will enable us to further decentralize who can run these Nodes as well as providing some interesting future functionalities such as executing transactions based on off-chain conditions.\nGEL staking, similar to ETH 2.0, is done by operators of the clients as they are doing the work and are also running the risk of getting punished for being down. \nFor passive GEL holders, we envisage that services similar to Lido will emerge that will provide regular holders access to GEL staking rewards without having to actually do the hard work by charging a fee on the revenue earned by these GEL holders. \nThe control of the bots will thus be distributed to the dApps and developers that are using Gelato the most by overseeing the protocol and influencing the decisions within the infrastructure of the network. The infrastructure is designed to extract as much value out of the system to ensure that they continue to operate in the best interests of the end-user. \nWith the Gelato DAO, stakeholders of the network will have the power to check, verify and influence these bots continuously certifying that they are operating as intended. Having a stake in the network will allow governance to monitor and regulate the network of bots ensuring that they are playing by the rules set by the DAO to always operate in the best interests of the user.   \nTotal Supply\nThe initial supply of the Gelato Token will be 420,690,000. After two years, additional tokens can be minted if the Token Holders vote in favor of such a proposal. \n\nHead over to our Medium post for more details.\nGelato Treasury: \nTreasury Address: https://etherscan.io/address/0x163407FDA1a93941358c1bfda39a868599553b6D​\nDAO Address: https://etherscan.io/address/0x4C64ce7C270E1316692067771bbb0DCe6Ec69B7C​\nIntegrations - Previous\nSafe\nNext - GELATO DAO\nGEL Token Contracts\nLast modified 2mo ago"
  },
  {
    "title": "Safe - Gelato Network",
    "url": "https://docs.gelato.network/integrations/safe",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nSafe\nHow to use Safe (formerly Gnosis Safe) with our Gelato App\nWe recommend using our custom app within Safe for a more reliable connection and smoother user experience. Wallet Connect does sometimes encounter issues and is not recommended.\nSetting up Custom Gelato App in Safe\nStep 1: Accessing Safe App\nAccess the official Gnosis Safe website: https://safe.global/​\nOnce there, locate and click on the \"Launch Wallet\" button, highlighted in green and situated in the top right corner.\nStep 2: Navigate to your Dashboard\nIf you're already using Safe, access your dashboard\nStep 3: Adding Custom Safe App\nSelect Custom Apps: Within the Safe Apps section, look for the 'Custom Apps' option. This allows you to add third-party applications that are not listed by default on Safe.\nStep 4: Configuring Gelato App\nTo add the Gelato app, you will need to provide the specific configuration settings. Enter the following details to configure the Gelato app:\nSafe App URL: https://app.gelato.network\nAfter entering the URL, you will see a confirmation screen like the one shown below.\nOnce you have entered the configuration details for the Gelato app and accepted the conditions, click 'Add' to finalize the setup.\nFinal Step: Sign-in with Safe Signature\nAfter completing these steps, the Gelato app will be integrated into your Safe Wallet, ready for you to use. Clicking on it will open up the Gelato app and allow you to sign-in.\nYou'll be required to sign in through the Safe UI:\nIf your Safe requires multiple signatures (multi-sig) the sign-in process will need approvals from the minimum number of signers set for your Safe before it can complete\nAnd that's it! You now have full access to the Gelato app! \nPrevious\nLegacy Automate Migration Guide\nNext - GELATO DAO\nDAO & Token (GEL)\nLast modified 1mo ago"
  },
  {
    "title": "Automate (Legacy) - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/automate-legacy",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nSupported Networks\nPaying for your transactions\nExecution & Balance Alerts\nMethods for submitting your task\nGuides\nMonitoring Automate Tasks\nTemplate real-world examples\nCode Repositories\nContract Addresses\nLegacy Automate Migration Guide\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nAutomate (Legacy)\nReliable, developer-friendly & decentralized smart contract automation\nDeprecation Notice: Gelato Functions is set to replace Automate, providing enhanced automation capabilities, access to off-chain data, unified payments across networks, and a performance boost. Migrate your tasks to Gelato Functions before Legacy Automate's end of life on June 30th, 2024 for uninterrupted service.\nQuick Start\nNew to smart contract automation? To quickly understand the process and how Gelato Automate enables you to automate a contract yourself, we recommend running through the Tutorial. \nGelato Automate provides an intuitive, self-service app for you to create and manage your automation tasks. Before diving we recommend you:\n1.\nCheck we support the network the contract you want to automate is on\n2.\nDoes your task match the types of tasks that can be automated?\n3.\nWhat is going to trigger your task? Is it based on a time frequency? If so Gelato Automate already has you covered. If it is based on more complex conditions (for example, when the yield to harvest exceeds the costs of doing so) then you'll need to consider writing a resolver. \n4.\nWhat arguments does your task require? Are they static or do they also need to be provided from your resolver?\nWith this information you should be good to go through the same Tutorial steps to automate your your real-world contract. The Template real-world examples may also be useful for you. \nIf you hit any problems or have any questions, please do reach out to the team and we'll be happy to help you. \n​\nPrevious\nSupported Networks\nNext\nSupported Networks\nLast modified 2mo ago"
  },
  {
    "title": "VRF - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/vrf",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\n📙\nUnderstanding VRF\n❔\nHow does Gelato VRF Work?\n🔓\nSecurity Considerations\n📄\nTemplate\n🚀\nQuick Start\n💡\nMigrating from Chainlink VRF\n💰\nPricing & Rate Limits\n✅\nSupported Networks\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nVRF\nIn the world of cryptography and decentralized applications, randomness plays a critical role. While randomness is a foundational concept, achieving genuine unpredictability in a transparent and verifiable manner on the blockchain is challenging. Enter Gelato VRF (Verifiable Random Function) - a tool designed to provide robust randomness with inherent verifiability.\nNew to VRFs?\n📙\nUnderstanding VRF\nAlready Familiar?\n🚀\nQuick Start\n🔓\nSecurity Considerations\nPrevious\nSubscription & Payments\nNext\nUnderstanding VRF\nLast modified 1mo ago"
  },
  {
    "title": "Web3 Functions - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/web3-functions",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\n📙\nUnderstanding Web3 Functions\n🔐\nSecurity Considerations\n📝\nTemplate & Use Cases\n🚀\nQuick Start\n🔍\nAnalytics & Monitoring\n✅\nSupported Networks\n🔗\nContract Addresses\n💰\nSubscription & Payments\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nWeb3 Functions\nOverview\nGelato's Web3 Functions is a powerful automation system designed to streamline and enhance Web3 operations. Web3 Functions serve as a comprehensive tool, enabling developers to effortlessly set up, manage, and automate their smart contract tasks.\nNew to Web3 Functions? \n📙\nUnderstanding Web3 Functions\nAlready familiar with Web3 Functions? \n🚀\nQuick Start\n🔐\nSecurity Considerations\nPrevious\nJoin our Discord\nNext\nUnderstanding Web3 Functions\nLast modified 3d ago"
  },
  {
    "title": "Relay - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/relay",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\n📨\nWhat is Relaying?\n🔒\nSecurity Considerations\n🚀\nInstallation\n📜\nTemplates\n🌠\nQuick Start\n🔏\nERC-2771 (recommended)\n🔧\nNon-ERC-2771\n💰\nGelato's Fee Oracle\n❔\nOptional Parameters\n🕵\nTracking your Relay Request\n✅\nSupported Networks\n💸\nSubscriptions and Payments\n📨\nAPI\n⏩\nMigration Guide ethers.js v5 to v6\n⏩\nERC2771 Migration Guide\n✍\nJoin our Discord\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nRelay\nEnabling developers to get transactions validated fast, reliably and securely\nGelato Relay enables web3 developers like you to get on with what you do best, building. Gelato handles the blockchain complexities for you, every step of the way, from the moment you initiate the transaction, to the moment it is validated on-chain. We take the utmost care to make sure your transaction is relayed from off-chain to successfully carried out on-chain in the shortest amount of time, reliably within the next few blocks, and with no downtime. \nWe support 17 EVM networks and a multitude of ways to pay using either native or ERC-20 tokens. In combination with Gelato 1Balance, a flexible cross-chain gas tank system which allows for payment across all supported networks using just one balance on the chain of your choosing.\nWhat is the Gelato Relay SDK?\nGelato Relay SDK offers a convenient suite of functions in order to interact with the Gelato Relay API. Gelato Relay API is a service that allows users and developers to get transactions validated fast, reliably and securely, without having to deal with the low-level complexities of blockchains.\nOverview of how Gelato Relay works\nAs requests are submitted to Gelato Relay, a network of decentralised Gelato Executors will execute and get the transactions validated as soon as possible. EIP-712 signatures enforce the integrity of data, while gas fee payments can be handled in any of our supported payment methods. In this way, developers can rely on Gelato's battle-tested blockchain infrastructure improving the UX, costs, security and liveness of their Web3 systems.​ \nSecurity Considerations\nWhile Gelato Relay offers very powerful features, improper implementation can introduce vulnerabilities in your contracts. We strongly recommend always using the built-in ERC-2771 user signature verification found in our sponsoredCallERC2771 or callWithSyncFeeERC2771 methods to enhance security.\nPlease read the Security Considerations section to understand all potential security risks and measures to mitigate them when using a Gelato Relay.\nHow can I get started with gasless transactions?\n1.\nDeploy a compatible contract, or use one of ours (see code example links below).\n2.\nRun the code examples found on each SDK method page:\n​sponsoredCallERC2771​\n​callWithSyncFeeERC2771​\n​sponsoredCall​\n​callWithSyncFee​\nThat's all it takes to get started with Gelato Relay and the Gelato Relay SDK! \nWe hope you have as much fun using Gelato Relay as we did building it! \n😄\n \nAny feedback, please get in touch!\nAPI Docs\nIf your codebase is not JS compatible, you can use the Gelato Relay API directly. Please find the API docs here. \nPrevious\neth_chainId\nNext\nWhat is Relaying?\nLast modified 14d ago"
  },
  {
    "title": "Account Abstraction - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/account-abstraction",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nSupported Networks\nAdvantages & Highlights\nTemplates & Examples\nBundler API Endpoints\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nAccount Abstraction\nERC-4337 Compatible Bundler & Paymaster\nUsers interact with Ethereum using externally owned accounts (EOAs) which are public-private key pairs. Anyone with access to the private key can perform actions within the rules of the Ethereum Virtual Machine (EVM). By design, the Ethereum network can only go through state transition when an EOA triggers a transaction and consequently pays a gas fee in ETH. These factors limit how users can interact with the blockchain.\n1.\nPoor security\n1.\nLost private keys cannot be recovered\n2.\nCompromised private keys give attackers instant access to all funds in the account\n3.\nRigid security rules (e.g., must use ECDSA)\n2.\nLack of customization\n1.\nMust initiate or sign every transaction\n2.\nNot programmable (i.e., can not define custom rules)\n3.\nGas payment\n1.\nAccount must hold ETH at all times in order to cover transaction fees\n2.\nCan not use other tokens (e.g., ERC20)\nSmart contract wallets are the solution to these problems by allowing users to flexibly program better security and user experiences into their accounts. Account abstraction enables smart contracts to initiate transactions themselves, without the user having to manage a separate EOA and ETH balance. This opens up the door to many exciting use cases.\nWhat is a Smart Wallet?\nSmart wallets are wallets controlled by smart contracts following the ERC-4337 specification. Ethereum has two types of accounts:\n1.\nExternally Owned Accounts (EOAs)\n2.\nContract Accounts (Smart Contracts)\nA Contract Account is managed by a Smart Contract rather than an EOA and relies on code instead of private keys to secure and recover wallet information.\nBenefits of Smart Wallets\n1.\nFully programmable\nCan do anything a smart contract can\nUpgradeable to add new features\n2.\nArbitrary verification logic & recovery\nECDSA (EOA controller account)\nSocial Login\nSession Keys\nBiometric\n3.\nAtomic multi-operations\nCombine multiple transactions into a single atomic transaction\nBetter efficiency as call overhead is only incurred once\nE.g., approve & spend tokens\n4.\nGasless transactions\nFully sponsored & ERC-20 payment\nCompatible with all smart contracts out of the box\n5.\nSemi-abstracted nonces\nConcurrent execution channels\nWhy ERC-4337?\nUnlike other proposals, ERC-4337 avoids changes to the consensus layer itself increasing the chance of faster adoption.\nTerminology\nSender\nThe sender is an ERC-4337 compatible smart contract wallet storing the users assets.\nIt must implement the following interface:\ninterface IAccount {\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external returns (uint256 validationData);\n}\nUserOperation\nA UserOperation is a pseudo-transaction object sent by the user into an alternate mempool.\nIt contains the following fields:\nField\nType\nDescription\nsender\naddress\nAccount requesting the operation\nnonce\nuint256\nAnti-replay parameter\ninitCode\nbytes\nAccount creation code (only required if not yet created i.e., first transaction)\ncallData\nbytes\nData passed to sender during execution\ncallGasLimit\nuint256\nGas allocated for main execution\nverificationGasLimit\nuint256\nGas allocated for verification\npreVerificationGas\nuint256\nAmount allocated to compensate the bundler for any gas overhead not tracked on-chain by the EntryPoint\nmaxFeePerGas\nuint256\nSimilar to EIP-1559​\nmaxPriorityFeePerGas\nuint256\nSimilar to EIP-1559​\npaymasterAndData\nbytes\nPaymaster address and callData (empty for self-sponsored transactions)\nsignature\nbytes\nData passed to the account along with the nonce during the verification step\nEntryPoint\nThe EntryPoint is a singleton smart contract that handles the verification and execution of bundles of UserOperations. This ensures much of the complicated logic is not required in the wallet itself and Instead, wallets trust the EntryPoint to perform proper validation (similar to a trusted forwarder).\nBundler\nA bundler is a node that bundles together multiple UserOperations from an alternate mempool and forwards them to the EntryPoint contract as a single transaction. The bundler executes transactions via EOAs which cover the transaction fees upfront and are later compensated. The Gelato Bundler is built on top of the existing Gelato Relay service and sponsors transactions via 1Balance.\nSee Advantages & Highlights.\nPaymaster\nA paymaster is a service that covers transaction fees on behalf of the user. Unlike other solutions, Gelato does not rely on the on-chain EntryPoint to compensate transaction costs. Instead, fees are settled by the 1Balance paymaster post-execution which avoids overcharging users and reduces the overall on-chain footprint.\nSee Advantages & Highlights.\nPrevious\nSubscription Notifications\nNext\nSupported Networks\nLast modified 2mo ago"
  },
  {
    "title": "Executor Operators - Gelato Network",
    "url": "https://docs.gelato.network/introduction/executor-operators",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nExecutor Operators\nIntroduction to Gelato's \"bots\"\nWhat is an Executor?\nExecutors are Gelato Network participants who provide infrastructure as a service to execute transactions as instructed by users of the Gelato Network. Executors are also referred to as “bots” or \"keepers\".\nHow do they work?\nExecutors receive tasks to be executed via the network Checkers. All Gelato Checkers are connected to all Executors on the network and when a task becomes executable it is shared among the Executors.\nAs soon as Executor receives a task to be executed, the Executor usually performs a simulation and if the simulation does well, the Executor submits the transaction on chain. The Executor then checks for its inclusion on every new block, and, in case of a task execution needing a resubmission, the Executor is responsible for bumping the gas price and re-submitting it.\nCoordination of Executors\nOne of the early core inventions of the Gelato Network was to coordinate task executions on a single platform amongst a broad set of transaction relayers (\"Executors\"). Whilst many Defi protocols that need decentralised keeper services default to primitive coordination mechanisms, such as asking executors to outbid each other in expensive gas wars, Gelato Network employs a coordination mechanism amongst its executors that comes at a fraction of the cost to miners and avoids racing conditions and winner-takes-all games. \n​\nNode operators that take part in the execution of tasks on the Gelato Network are running parallelised software that allocates a distinct portion of the global task pool to them at any given time. This parallel algorithm ensures none of the Executors are forced into expensive bidding wars with other Executors.  One of the breakthroughs of recent Gelato V2 developments was to move from the primitive Round-Robin mechanism it pioneered to a fully parallelised task distribution algorithm that ensures that all open Gelato tasks can be serviced by Executors simultaneously, without racing conditions. \nWho can become an Executor?\nGelato currently works with a set of whitelisted partners who provide Executor services. A core aim for Gelato is to further decentralize and enable anyone with the right resources to become an Executor. Executors will be required to stake a GEL tokens to become an Executor - creating accountability and incentivising them to act in the best interests of the user and protocol. \nINTRODUCTION - Previous\nGelato Network Contracts\nNext - Services\nGelato Rollup-as-a-Service (RaaS)\nLast modified 1yr ago"
  },
  {
    "title": "1Balance - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/1balance",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\n1Balance Alerts\nSubscription Plans\nSubscription Notifications\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\n1Balance\nGelato's unified multi-chain payments system\nOverview\nWhen you use each of Gelato's services there are two costs that you need to pay:\nGas costs of your executed transactions (or those of your end users if you are sponsoring them)\nService fees - Gelato subscriptions or % premiums on the gas costs of each transaction\n1Balance makes it easy for you to pay all of your costs across all the networks that you are using from one single easy-to-manage balance.\nSupported Gelato Services\n​Relay and Web3 Functions are currently integrated with 1Balance. \nGetting Started\nTo get started with 1Balance on mainnets you will need USDC on Polygon (plus some MATIC to cover Polygon gas costs for depositing). We will be extending 1Balance support to other networks. \nWe currently support the bridged version of USDC, USDCe. Make sure you are using the correct USDC token by verifying the contract address. For your convenience, here is the contract address for USDCe on Polygon:\nUSDC.e Contract Address: 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174​\n1.\n​Access the 1Balance in the Gelato app​\n2.\nConnect your wallet if you have not already done so\n3.\nSwitch to Polygon\n4.\nClick on deposit and then approve USDC into your 1Balance\n\n\n\n5.\nAfter confirming your deposit transaction in your wallet you will see a Pending deposit appear in your deposits history: \n\n\n\nOnce the required number of confirmations has been reached your deposit will be credited and your 1Balance is ready for use. \n1Balance does not yet support withdrawals - this feature will be added soon. Please select your deposit amount accordingly.\nFees\nMore details on the fees applied by each service are available:\n​Relay Fees and more detailed guide to using 1Balance with Relay\n​Web3 Function Fees​\nLow Balance Alerts\nTo ensure that your transactions execute as you expect, it is critical that you have sufficient funds deposited in 1Balance. To help you monitor your balance and receive alerts when it drops below you preferred threshold, we provide a 1Balance Alerts service.​\nPrevious\nOthers\nNext\n1Balance Alerts\nLast modified 11d ago"
  },
  {
    "title": "Gelato Rollup-as-a-Service (RaaS) - Gelato Network",
    "url": "https://docs.gelato.network/developer-services/gelato-rollup-as-a-service-raas",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\nDeploy your L2 Chain\nExecution Frameworks\nData Availability\nReliability & Security\nScaling Solutions Wiki\nMarketplace\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nGelato Rollup-as-a-Service (RaaS)\nWelcome to Gelato RaaS!\nGelato is an all-in-one Ethereum Rollup-as-a-Service (RaaS) platform built without limits. \nDesigned to be super-fast, incredibly secure and infinitely scalable, Gelato rollups allow anyone to build and deploy their fully serviced Layer 2 chains at a pace natively integrated with web3's favorite tools and services launching a production-ready web3 development environment right from the Genesis block.\nLeveraging Gelato's Rollup-as-a-Service platform, developers can take full advantage of the benefits offered by zero-knowledge and optimistic Rollup technologies with alternative data availability (DA) layers as an option. This allows them to tap into enhanced scalability and reduced transaction costs.\nThe below image could be divided into rollup frameworks and data availability\nExecution Frameworks\n- OP Stack​\n- Arbitrum Orbit\n- Polygon CDK​\nData Availability\n- Celestia\n- Avail​\nIn addition, Gelato RaaS goes beyond just deploying, hosting, and monitoring your Layer 2 chains. It provides developers with native integrations with Gelato’s industry-leading Web3 middleware services including automation, off-chain data, and Account Abstraction to enable superior UX. Moreover, the platform provides out-of-the-box, native access to tier-one web3 services such as Etherscan, The Graph, LayerZero, and many more.\nGelato is web3’s leading Cloud Platform with over 480 dApps relying on Gelato services to power the execution of millions of transactions across DeFi, NFT, Gaming, and more.\nThis documentation presents detailed guides on:\n​How to deploy your rollup​\n​Execution frameworks​\n​Data availability solutions​\n​Gelato infrastructure marketplace​\nWhy Choose Gelato RaaS?\nEasy to deploy\nComplex operations do not scale. Gelato offers an intuitive UI enabling no-code deployment, monitoring and management of Ethereum rollups leveraging advanced frameworks like Arbitrum Orbit, OP Stack or Polygon CDK and Data Availability layers like Celestia or Avail. \nWorking with Gelato unlocks efficiencies and reduces engineering overhead, which in turn means your developers can spend their time working on new features instead of re-creating or maintaining existing ones. Built ON Gelato means your devs don’t need to worry about infrastructure dependencies, and essential web3 service integrations, ultimately reducing deployment and maintenance time significantly saving up to 1 million dollars of development costs in a year.\nModularity & Performance\nGelato RaaS adopts a modular architecture that significantly improves performance and customization by separating data availability and consensus from execution. The platform provides execution layers and data availability choices, enabling users to select scalable, secure, and cost-effective solutions like Rollups, Validiums, and Plasma. This versatility aids in creating high-volume applications with low transaction fees like on-chain gaming, social/micro DeFi solutions, and secure financial applications for institutions, including payment systems and DeFi platforms.\nNatively Integrated Tools & Services\nGelato RaaS integrates with your favorite Web3 tools and services, providing an end-to-end integrated L2 infrastructure. Features include the Gelato middleware suite with smart contract automation, secure data access with Functions, gasless transactions, verifiable random numbers, auto-scaling RPC nodes, and a block explorer. Additionally, it also integrates with over +23 3rd party infra providers for fully serviced L2 chains with native Safe UI, indexers, oracles, bridges, and more.\nHigh Reliability & Multi-Cloud\nGelato's RaaS offers a multi-cloud and globally distributed infrastructure, designed for high availability and fault tolerance as fundamental principles, resulting in a resilient and robust infrastructure. This approach is essential for mitigating service disruptions and guaranteeing consistent performance.\nDive Deeper into the Gelato RaaS\nReady to deploy your first Gelato L2 chain and learn more about possibilities to customize your chain to your user's needs?\nFollow our simple Getting Started guide to launch your Layer-2 Chains with Gelato.\nFor a detailed overview of Gelato's offerings, read our Execution Framework section to learn about available execution and data availability solutions.\nExplore our turnkey marketplace offering with more than 25+ integrations\nOur team of highly qualified blockchain developers and ecosystem growth experts are here to support you on this journey all the way.\nGelato RaaS is the future of blockchain and Ethereum's scaling.\nYou’re already here, so what are you waiting for?\nINTRODUCTION - Previous\nExecutor Operators\nNext\nDeploy your L2 Chain\nLast modified 8d ago"
  },
  {
    "title": "Gelato Network Contracts - Gelato Network",
    "url": "https://docs.gelato.network/introduction/gelato-network-contracts",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nGelato Network Contracts\nIntro to Gelato's use of the Diamond Proxy pattern\nGelato Network is designed to handle the rapidly evolving multi-chain landscape with its diversity of L1, L2 and sidechain designs. Significant differences can be found across aspects such as consensus mechanisms, block times, likelihood of block re-orgs and transaction fee models. \nTo handle the nuances that each blockchain design entails, GelatoV2 smart contracts follow a modular upgradeability standard: EIP-2535 Diamond Proxy.\nDiamond Proxy Pattern\nA Diamond contains:\nProxy contract that holds all state variables. \nFacets which are smart contracts that implement any desired functionality and can be replaced at any time. \nLibraries, which can be used to share state variables and utility functions across all Facets.\nBenefits of Diamond Proxy Pattern\nHaving a single smart contract holding all the state, while not running into issues of exceeding bytecode size. \nAbility to share state variables and functions between multiple Facets.\nFine-grained control in terms of which components of the protocol to upgrade. This means that protocol upgrades are gas-efficient.\nOptionality of changing GelatoV2 from upgradeable to immutable at any time, simply by revoking rights to upgrade Facets.\nImplementing GelatoV2 as a Diamond means that we can easily accommodate new use cases by eliminating integration friction with users and developers, adapt to lower level changes such as a chain changing from the legacy transaction fee model to EIP-1559, and simply adding or removing features as needed without enforcing strong opinions at the application interface level.\nGelatoV2 on Ethereum mainnet can be found here: https://louper.dev/diamond/0x3CACa7b48D0573D793d3b0279b5F0029180E83b6​\nFacets of GelatoV2\nBrief guide to the facets that make up GelatoV2 on Ethereum mainnet:\nFacet\nFunction\nDiamondCutFacet\nUsed to make upgrades to the Diamond, such as removing and adding new Facets, and possibly initialising their state variables upon deployment.\nDiamondLoupeFacet\nHelper smart contract which allows one to inspect all Facets in the Diamond at any given time.\nOwnershipFacet\nManage the ownership of GelatoV2, whose owner is currently the Gelato Multisig smart contract.\nAddressFacet\nManage Gelato specific utility smart contracts such as the gas price oracle and oracle aggregator.\nGelatoV1Facet\nBackward compatibility with GelatoV1.\nConcurrentCanExecFacet\nCoordination algorithm between multiple Gelato executors.\nExecAccessFacet\nManage Gelato executors.\nExecAccessFlashbotsFacet\nManage Gelato executors that submit their tasks as Flashbots bundles.\nExecAccountingFacet\nManage accounting of transaction fees, and soon also payroll to Gelato executors.\nExecFacet\nMain Facet. All tasks submitted to Gelato will be routed through the exec method.\nPrepaidExecFacet\nFacet where some use-case specific calls will be routed. Currently deprecated.\nUniswapV2SwapFacet\nSimilar to ExecFacet, but automatically handles token swaps upon payment. Currently deprecated.\nTransferFacet\nFee withdrawal from GelatoV2, managed by Gelato Multisig.\nImplementations of GelatoV2 on other chains can also be found on Louper. \nINTRODUCTION - Previous\nArchitecture\nNext - INTRODUCTION\nExecutor Operators\nLast modified 4mo ago"
  },
  {
    "title": "What is Gelato? - Gelato Network",
    "url": "https://docs.gelato.network/introduction/what-is-gelato",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nWhat is Gelato?\nWeb3's decentralized backend\nGelato is web3’s decentralized backend empowering builders to create augmented smart contracts that are automated, gasless & off-chain aware on all major EVM-compatible blockchains including Ethereum, Polygon, Fantom, Arbitrum, BNB Chain, Optimism and many more. \nGelato currently offers 4 main services:\nWeb3 Functions: Connect your smart contracts to off-chain data & computation by running decentralized cloud functions. \nAutomate: Automate your smart contracts by executing transactions automatically in a reliable, developer-friendly & decentralized manner. \nRelay: Give your users access to reliable, robust and scalable gasless transactions via a simple to use API.\nGasless Wallet: A powerful SDK that enables developers to provide a wordclass UX by combining Gelato Relay + Safe's Smart Contract Wallet to enable Account Abstraction.\nOver 200+ web3 projects rely on Gelato for years to power the execution of millions of transactions across DeFi, NFT and Gaming.\nVision\nGelato is web3's decentralized backend that empowers the world to run on smart contracts.\nOur mission is to solve the issues of lacking reliability, scalability, and centralization around web3 applications that want to augment their smart contracts with off-chain computation capabilities to overcome the limitations that current EVM based blockchains impose on them. Gelato solves these issues by providing decentralized backend services that enables developers to make their smart contracts automated, gasless and off-chain aware.\nMission\nWe measure the success of Gelato by the time we accelerated worldwide adoption of smart contracts and web3 technology. This is why we pledged to help developers to onboard the first billion users to web3 by taking care of all their web3 backend services needs so they can focus on building a stellar UX that rivals those of their web2 counterparts.\nUsers of Gelato\nWe've been working with the world's leading projects in the web3 space, from blockchain protocols to DeFi apps and wallets. \n​MakerDAO: DeFi's oldest lending protocol where the stablecoin DAI is created\n​Safe: The most trusted decentralized custody protocol and collective asset management platform on Ethereum and the EVM\n​Connext: The leading protocol for fast, fully noncustodial transfers and contract calls between EVM-compatible chains\n​Optimism: One of the most widely used Ethereum L2 scaling solutions\n​Olympus: A community-owned, decentralized and censorship-resistant reserve currency\n​PancakeSwap: The #1 AMM on BNB Chain with over $100 million daily trading volume\n​Beefy Finance: A decentralized, multi-chain yield optimizer platform on Polygon, BNB Chain, Fantom, Avalanche, and 10 other blockchain networks\n​Abracadabra: Multichain lending and borrowing protocol which generates the stablecoin MIM\nand many more...\nUseful Links:\n​Whitepaper​\n​Social Media​\n​Contact us​\nNext - INTRODUCTION\nHow it works\nLast modified 2d ago"
  },
  {
    "title": "Architecture - Gelato Network",
    "url": "https://docs.gelato.network/introduction/architecture",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nArchitecture\nArchitecture Overview\nAll Gelato's product run on the same core Gelato Network architecture which is responsible for ensuring that tasks are executed correctly and efficiently. \nIn essence the Gelato Network needs to continuously check if the conditions for a task to execute have been met and when they are met, execute the transaction and ensure that it gets confirmed as quickly and efficiently as possible. \nCore Components\nEvent Listener\nThe Event Listener is responsible for continuously querying the chain and monitoring emitted events. \nOn EVM compatible platforms, events are often used as a lower cost option to share data that is not required to be accessed on-chain (i.e data that does not need to be kept in storage thus requiring less gas consumption). Events allow external entities, like our Event Listener, to do efficient queries of indexed data. For a more detailed and technical description of events, please refer to the Solidity Event Documentation.\nEach Checker has access to the Event Listener and can subscribe to an arbitrary number of smart contracts and topics to watch. The tracked events are then decoded/translated into a specific data structure using predefined mappers, resulting in either a new task being created or existent tasks being updated/cancelled/executed.\nChecker\nThe Checker defines arbitrary/custom logic to check if a Gelato task is executable at a given moment. It defines the conditions required for a task to become executable. It can also define other conditions that can update a task's state, such as limit order cancellations.\nGelato Network is composable of several independent Checkers, such as Gelato Automate and Limit Orders for example.\nExecutor\nAn Executor is responsible to reliably submit transactions on chain and making sure that they are mined as quickly as possible with the lowest cost.\nFor a more detailed description of Executors, please refer to the Executor Operators section.\nINTRODUCTION - Previous\nHow it works\nNext - INTRODUCTION\nGelato Network Contracts\nLast modified 1yr ago"
  },
  {
    "title": "How it works - Gelato Network",
    "url": "https://docs.gelato.network/introduction/how-it-works",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nHow it works\nOur mission is to provide developers with modular web3 devops services they can use to build decentralized and robust protocols.\nTo accomplish this, Gelato Network operates as a marketplace bringing together two parties: developers wanting to automate transactions on one side and infrastructure operators on the other side who run executor bots looking for tasks to complete in return for a small fee. \nKey Benefits\n1.\nNo need to self-host servers on AWS or other cloud providers\n2.\nRPC aggregation with multiple fallbacks\n3.\nReliable transaction relay service that always gets transactions mined fast\n4.\nCatches reorgs automatically\n5.\nMulti-chain; works with the most popular EVM-compatible networks\n6.\nNo single point of failure; multiple Executors are operating all over the world\n7.\nNo need to self-manage your private key in the cloud\n8.\nBuilt-in consensus / coordination layer to avoid racing conditions\n9.\nFlexible payment options; pay with a prepaid balance or have txs pay themselves\n10.\nCost effective: cheaper than building, running & maintaining custom servers\nEconomies of scale\nThe Gelato Network is a sustainable, revenue-generating protocol. The network is “transaction hungry” — the more transactions are being automated via the infrastructure services of Executors, the less they need to get paid per transaction, in order to cover their fixed infrastructure costs. \nExecutors will justify the costs of running their infrastructure by the increase in transaction quantity and not the rise of value captured by individuals’ transactions. This makes Gelato more cost effective to use for dApps than running their own centralized keeper system.\nINTRODUCTION - Previous\nWhat is Gelato?\nNext - INTRODUCTION\nArchitecture\nLast modified 1yr ago"
  },
  {
    "title": "What is Gelato? - Gelato Network",
    "url": "https://docs.gelato.network/introduction/what-is-gelato",
    "html": "Gelato Network\nSearch\n⌃\nK\nINTRODUCTION\nWhat is Gelato?\nHow it works\nArchitecture\nGelato Network Contracts\nExecutor Operators\nSERVICES\nGelato Rollup-as-a-Service (RaaS)\n1Balance\nAccount Abstraction\nRelay\nWeb3 Functions\nVRF\nAutomate (Legacy)\nINTEGRATIONS\nSafe\nGELATO DAO\nDAO & Token (GEL)\nGEL Token Contracts\nGovernance Process\nSocial Media\nPowered By GitBook\nWhat is Gelato?\nWeb3's decentralized backend\nGelato is web3’s decentralized backend empowering builders to create augmented smart contracts that are automated, gasless & off-chain aware on all major EVM-compatible blockchains including Ethereum, Polygon, Fantom, Arbitrum, BNB Chain, Optimism and many more. \nGelato currently offers 4 main services:\nWeb3 Functions: Connect your smart contracts to off-chain data & computation by running decentralized cloud functions. \nAutomate: Automate your smart contracts by executing transactions automatically in a reliable, developer-friendly & decentralized manner. \nRelay: Give your users access to reliable, robust and scalable gasless transactions via a simple to use API.\nGasless Wallet: A powerful SDK that enables developers to provide a wordclass UX by combining Gelato Relay + Safe's Smart Contract Wallet to enable Account Abstraction.\nOver 200+ web3 projects rely on Gelato for years to power the execution of millions of transactions across DeFi, NFT and Gaming.\nVision\nGelato is web3's decentralized backend that empowers the world to run on smart contracts.\nOur mission is to solve the issues of lacking reliability, scalability, and centralization around web3 applications that want to augment their smart contracts with off-chain computation capabilities to overcome the limitations that current EVM based blockchains impose on them. Gelato solves these issues by providing decentralized backend services that enables developers to make their smart contracts automated, gasless and off-chain aware.\nMission\nWe measure the success of Gelato by the time we accelerated worldwide adoption of smart contracts and web3 technology. This is why we pledged to help developers to onboard the first billion users to web3 by taking care of all their web3 backend services needs so they can focus on building a stellar UX that rivals those of their web2 counterparts.\nUsers of Gelato\nWe've been working with the world's leading projects in the web3 space, from blockchain protocols to DeFi apps and wallets. \n​MakerDAO: DeFi's oldest lending protocol where the stablecoin DAI is created\n​Safe: The most trusted decentralized custody protocol and collective asset management platform on Ethereum and the EVM\n​Connext: The leading protocol for fast, fully noncustodial transfers and contract calls between EVM-compatible chains\n​Optimism: One of the most widely used Ethereum L2 scaling solutions\n​Olympus: A community-owned, decentralized and censorship-resistant reserve currency\n​PancakeSwap: The #1 AMM on BNB Chain with over $100 million daily trading volume\n​Beefy Finance: A decentralized, multi-chain yield optimizer platform on Polygon, BNB Chain, Fantom, Avalanche, and 10 other blockchain networks\n​Abracadabra: Multichain lending and borrowing protocol which generates the stablecoin MIM\nand many more...\nUseful Links:\n​Whitepaper​\n​Social Media​\n​Contact us​\nNext - INTRODUCTION\nHow it works\nLast modified 2d ago"
  }
]
